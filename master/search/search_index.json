{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Secure Device Onboard is a flexible software solution that simplifies and automates the process of onboarding IoT devices. By \u201conboard\u201d we mean the process by which a device establishes its first trusted connection with a device management service. Today, organizations that deploy IoT devices are struggling with manual methods to securely connect devices with IoT platforms. Traditional onboarding processes are time intensive and require IT expertise. The Secure Device Onboard solution simplifies this process for end customers while simultaneously establishing trust across all organizations who manufacture, distribute, or sell the device and associated IoT solutions. During deployment of a device enable with the Secure Device Onboard solution, all the installer needs to do is add power to the device and connect it to the Internet. The device automatically and rapidly connects to the IoT platform in a secure and trusted manner. Secure Device Onboard combines embedded hardware security credentials with a chain-of-ownership security credential and Rendezvous service to secure the onboarding process and broker the connection to the authorized device management service provider. Today Secure Device Onboard supports Intel \u00ae Enhanced Privacy ID (Intel \u00ae EPID) and Elliptic Curve Digital Signature Algorithm-based embedded hardware security credentials. Devices enabled with Secure Device Onboard technology work with any IoT cloud service providers that have enabled their service to work with Secure Device Onboard. This allows manufacturers to reduce the number of SKUs they need to securely connect with cloud services. Secure Device Onboard Entities \u00b6 The Secure Device Onboard process involves interactions between a number of different entities that participate in the process. Those include: Manufacturer - The manufacture is responsible for loading Secure Device Credentials into a device. They are also directly or indirectly responsible for installing software onto the device that supports the Secure Device Onboard protocols required for device discovery and transfer of ownership. Device - The device runs software which supports the Secure Device Onboard protocols required for devices. The device is initialized with credentials which securely identifies the device. Owner - When a device is transferred to an owner who intends to install the device in their network, the owner (typically the owner's IOT Platform Service) contacts a Rendezvous Service to register the device and indicate where the device is to make contact with the IOT Platform Service. Rendezvous Service - One or more Rendezvous Services operates on the Internet (or in some cases on an intranet). The Rendezvous service supports device registration by the owner (described above) and also provides a well-known endpoint that devices can connect to discover how to contact their owner's IOT Platform Service. The Rendezvous Service supports the Secure Device Onboard protocols required for owner registration and device discovery. IOT Platform Service - Owners of devices typically use a IOT Platform service (also known as a Device Management Service) to manage their devices. The IOT Platform Service must support the Secure Device Onboard protocols required to register devices with the Rendezvous service and to provide devices with the information required to connect to the owner\u2019s network. Secure Device Onboard Protocol Specification \u00b6 The Secure Device Onboard Protocol Specification defines a set of protocols for communications between the entities that participate in the Secure Device Onboard process. Those protocols are: Device Initialization Protocol (DI) - This protocol defines how credentials are inserted into a device during the manufacturing process. Transfer Ownership Protocol 0 (TO0) - This protocol defines how an owner of a device enabled with Secure Device Onboard communicates with a Rendezvous Service to indicate that it has taken ownership of a device. Transfer Ownership Protocol 1 (TO1) - This protocol defines how a device communicates with a Rendezvous Service to identify itself and discover how to make contact with its owners IOT Platform. Transfer Ownership Protocol 2 (TO2) - This protocol defines how a device communicates with its owners IOT Platform to establish trust and transfer ownership. Details of the Secure Device Onboard protocol can be found in the Secure Device Onboard Protocol Specification . Secure Device Onboard Software \u00b6 The Secure Device Onboard project provides software that helps simplify the implementation of an end-to-end Secure Device Onboard capability. The following components are available: Client SDK - The Client SDK provides devices with an implementation of the DI protocol, which initializes the device with credentials, the TO1 protocol, which connects the device to a Rendezvous Service, and the TO2 Protocol, which connects the device to an IOT Platform Service. The Client SDK supports Linux on X86 processors, as well as Linus and SELinux on ARM processors. Manufacturing Toolkit - The Manufacturing Toolkit software enables the manufacturer to load credential into devices. It implements the DI protocol, and includes support for database storage of credentials and is designed to integrate into the manufacturers IT processes. Reseller Toolkit - The Reseller Toolkit enables distributors and System Integrators to manage the ownership credential over the devices lifetime. It implements the DI protocol. Rendezvous Service - The Rendezvous Service software provides a complete Rendezvous service, and implements the TO0 and TO1 protocols required for device registration and discovery. It can be run in the cloud or on-premise and includes an interface to support key attestation. IOT Platform SDK - The IOT Platform SDK provides micro-services to facilitate integration of an IOT Platform in the Secure Device Onboard processes. It implements the TOO protocol required for device registration, and the TO2 protocol required for device ownership transfer. Protocol Reference Implementation - The Protocol Reference Implementation provides a self-contained implementation of the Secure Device Onboard protocols, which can be used as a reference implementation, as a place to get started prototyping new protocol features, or as a validation tool A directory of documentation and source repositories for the Secure Device Onboard software can be found on the Reference page . The Secure Device Onboard Process \u00b6 This section describes a typical process in which Secure Device Onboard is used to automatically and securely onboard a device onto an owners network. Those process include: Device Initialization - A manufacturer initializes a device enabled with Secure Device Onboard Client software by setting the initial credentials in the device\u2019s firmware, copying required files to the device\u2019s OS, and storing the required security data in a backend IT system. Credential Management \u2013 The manufacturers and supply chain integrators run a tool to manage security keys and ownership credentials that correspond to each device. These credentials do not reside on the device and are used to negotiate trust as devices are bought and sold. Transfer To IoT Platform \u2013 The ownership credentials are imported into an SDO-enabled IoT Platform. Device Registration \u2013 The ownership credentials are synchronized between the device management service and the rendezvous server. Onboarding - The process of verifying the device identity with the rendezvous server and brokering a trusted connection to the intended IoT platform when a device is powered on and connected to the Internet. The following diagram shows an example of a possible IoT supply chain and the steps taken by each participant in the Secure Device Onboard service. Each step is described in more detail in following sections. Enablement and Onboarding Process Step 1: Manufacturing \u00b6 The manufacturer sets up a manufacturing station that uses the Secure Device Onboard Manufacturer Toolkit to initialize the device. Device initialization puts the Secure Device Onboard client software and security credentials on the device. Device initialization also creates an ownership voucher. The ownership voucher is a digital document that securely records changes in ownership. The ownership voucher travels with the device but is never physically on a device, which is similar to, for example, a shipping invoice. Each device has a unique ownership voucher. The ownership voucher contains the following information: Device GUID : A unique string that identifies the device Credential ID : A reference to the ownership voucher Rendezvous Server Location : One or more URIs identifying where a Secure Device Onboard Rendezvous Service can be contacted by the device Manufacturers public key : A key uniquely identifying the manufacturer of the device Behind the scenes, the Manufacturer Toolkit uses the Device Initialize (DI) protocol to perform device initialization. After device initialization is complete, the manufacturer associates the ownership voucher with the device, for example, by associating the GUID with the device serial number. For tracking, the manufacturer can also print the GUID on a label on the device box. When the manufacturer sells the device to a distributor, the manufacturer acquires the distributor\u2019s public key as a part of the ordering process. The manufacturer then uses the Manufacturer Toolkit to counter-sign the ownership voucher. This requires adding the distributor\u2019s public key to the ownership voucher. The manufacturer then ships the device to the distributor and sends the ownership voucher to the distributor via either a file or through B2B integration. Step 2: Distribution \u00b6 The distributor receives the device and ownership voucher from the manufacturer. Like the manufacturer, the distributor associates the ownership voucher with the device, for example, by associating the GUID with the device serial number. When the distributor sells the device to the system integrator or another retailer, the distributor acquires the buyer\u2019s public key as a part of the ordering process. The distributor then uses SDO reseller toolkit to counter-sign the ownership voucher. The distributor then ships the device to the buyer and sends the ownership voucher via either a file or through B2B integration. The preceding process continues until the device is sold to a system integrator. Step 3: System Integration \u00b6 The system integrator receives the device and ownership voucher from the distributor. Like the distributor, the system integrator associates the ownership voucher with the device, for example, by associating the GUID with the device serial number. The system integrator acquires the IoT Platform provider\u2019s public key and uses the Secure Device Onboard Reseller Toolkit to counter-sign the ownership voucher for the last time. The system integrator then sends the ownership voucher to the IoT Platform service provider via either a file or through B2B integration. Step 4: Ownership \u00b6 The IoT Platform provider registers the ownership voucher with the Rendezvous Service . The Rendezvous Service may be operated by a cloud service provider, the IOT Platform service provider, or other service provider entity. Behind the scenes, the IOT Platform uses the Transfer Ownership 0 (TO0) protocol to communicate with the Rendezvous server. To facilitate easy integration with Secure Device Onboard, the IOT Platform can use the Secure Device Onboard IOT Platform SDK , which implements the protocol features required by the IPT Platform to communicate with the Rendezvous service, and provides an easy REST-based interface to communicate between the SDK components and the IOT Platform. Step 5: Device Discovers IOT Platform \u00b6 At this point, the system integrator installs the device, applies power, and connects it to the Internet. The device uses the location of the rendezvous server provided in step 1 to contact the Rendezvous Service, whereupon it receives a URI indicating where to connect to the IoT platform provider. Behind the scenes, the Secure Device Onboard Client SDK software uses the Transfer Ownership 1 (TO1) protocol to communicate with the Rendezvous Service. Note that ideally, the system integrator waits to install the device until it has received confirmation from the IoT Platform that Step 4 is complete. However, if the device contacts the rendezvous server before Step 4 is complete, the device will continue to retry the connection to the server until it gets the IoT Platform location. Step 6: Device Onboards \u00b6 After receiving the IoT Platform URI, the device contacts the IoT platform. The IoT platform provides new security credentials. The credentials programmed during device initialization are now replaced with the new credentials. Behind the scenes, the device uses the Transfer Ownership 2 (TO2) protocol to communicate with the IOT Platform SDK. At this point, the onboarding is complete. The system integrator and IoT Platform can now complete additional provisioning steps on their own because a trusted connection has been established between the device and the IoT Platform. Next Steps \u00b6 Contributors \u00b6 Contributors can get started by visiting the Secure Device Onboard Community page. Developers and Integrators \u00b6 Developers and Integrators can take the next step by reviewing the documentation for the components they are interested in. The Reference page provides links to all of Secure Device Onboard documentation mentioned here, links to the Secure Device Onboard project source repositories, and a glossary of Secure Device Onboard terminology. The Releases page provide links to Secure Device Onboard binary releases. The Secure Device Onboard Protocol Specification provides developers with the details of protocol operation. The Protocol Reference Implementation provides a self-contained implementation of the Secure Device Onboard protocol, which can be used as a reference implementation, as a place to get started prototyping new protocol features, or as a validation tool All-In-One Demo \u00b6 The All-In-One Demo runs the Rendezvous Service, a simulated IOT Platform using the IOT Platform SDK , and the Manufacturing Toolkit . Using it, you can run a device enable with the Client SDK software through the entire Secure Device Onboard lifecycle. Manufacturers \u00b6 Manufacturers interested in implementing support for Secure Device Onboard in their factories can learn more by referring to the Secure Device Onboard Manufacturer Enablement Guide . Distributers and Resellers \u00b6 Distributers and resellers interested in implementing support for Secure Device Onboard in their business processes can learn more by referring to the Secure Device Onboard Reseller Enablement Guide IOT Platform Providers \u00b6 IOT Platform Providers interested in implementing support for Secure Device Onboard in their IOT Platforms can learn more by referring to the Secure Device Onboard IoT Platform Integration SDK Reference Guide Cloud Service Operators \u00b6 Cloud Service Operators interested in supporting Secure Device Onboarding in their IOT services can learn more by referring to the Secure Device Onboard Protocol , the Rendezvous Service implementation, and the Protocol Reference Implementation .","title":"Home"},{"location":"#introduction","text":"Secure Device Onboard is a flexible software solution that simplifies and automates the process of onboarding IoT devices. By \u201conboard\u201d we mean the process by which a device establishes its first trusted connection with a device management service. Today, organizations that deploy IoT devices are struggling with manual methods to securely connect devices with IoT platforms. Traditional onboarding processes are time intensive and require IT expertise. The Secure Device Onboard solution simplifies this process for end customers while simultaneously establishing trust across all organizations who manufacture, distribute, or sell the device and associated IoT solutions. During deployment of a device enable with the Secure Device Onboard solution, all the installer needs to do is add power to the device and connect it to the Internet. The device automatically and rapidly connects to the IoT platform in a secure and trusted manner. Secure Device Onboard combines embedded hardware security credentials with a chain-of-ownership security credential and Rendezvous service to secure the onboarding process and broker the connection to the authorized device management service provider. Today Secure Device Onboard supports Intel \u00ae Enhanced Privacy ID (Intel \u00ae EPID) and Elliptic Curve Digital Signature Algorithm-based embedded hardware security credentials. Devices enabled with Secure Device Onboard technology work with any IoT cloud service providers that have enabled their service to work with Secure Device Onboard. This allows manufacturers to reduce the number of SKUs they need to securely connect with cloud services.","title":"Introduction"},{"location":"#secure-device-onboard-entities","text":"The Secure Device Onboard process involves interactions between a number of different entities that participate in the process. Those include: Manufacturer - The manufacture is responsible for loading Secure Device Credentials into a device. They are also directly or indirectly responsible for installing software onto the device that supports the Secure Device Onboard protocols required for device discovery and transfer of ownership. Device - The device runs software which supports the Secure Device Onboard protocols required for devices. The device is initialized with credentials which securely identifies the device. Owner - When a device is transferred to an owner who intends to install the device in their network, the owner (typically the owner's IOT Platform Service) contacts a Rendezvous Service to register the device and indicate where the device is to make contact with the IOT Platform Service. Rendezvous Service - One or more Rendezvous Services operates on the Internet (or in some cases on an intranet). The Rendezvous service supports device registration by the owner (described above) and also provides a well-known endpoint that devices can connect to discover how to contact their owner's IOT Platform Service. The Rendezvous Service supports the Secure Device Onboard protocols required for owner registration and device discovery. IOT Platform Service - Owners of devices typically use a IOT Platform service (also known as a Device Management Service) to manage their devices. The IOT Platform Service must support the Secure Device Onboard protocols required to register devices with the Rendezvous service and to provide devices with the information required to connect to the owner\u2019s network.","title":"Secure Device Onboard Entities"},{"location":"#secure-device-onboard-protocol-specification","text":"The Secure Device Onboard Protocol Specification defines a set of protocols for communications between the entities that participate in the Secure Device Onboard process. Those protocols are: Device Initialization Protocol (DI) - This protocol defines how credentials are inserted into a device during the manufacturing process. Transfer Ownership Protocol 0 (TO0) - This protocol defines how an owner of a device enabled with Secure Device Onboard communicates with a Rendezvous Service to indicate that it has taken ownership of a device. Transfer Ownership Protocol 1 (TO1) - This protocol defines how a device communicates with a Rendezvous Service to identify itself and discover how to make contact with its owners IOT Platform. Transfer Ownership Protocol 2 (TO2) - This protocol defines how a device communicates with its owners IOT Platform to establish trust and transfer ownership. Details of the Secure Device Onboard protocol can be found in the Secure Device Onboard Protocol Specification .","title":"Secure Device Onboard Protocol Specification"},{"location":"#secure-device-onboard-software","text":"The Secure Device Onboard project provides software that helps simplify the implementation of an end-to-end Secure Device Onboard capability. The following components are available: Client SDK - The Client SDK provides devices with an implementation of the DI protocol, which initializes the device with credentials, the TO1 protocol, which connects the device to a Rendezvous Service, and the TO2 Protocol, which connects the device to an IOT Platform Service. The Client SDK supports Linux on X86 processors, as well as Linus and SELinux on ARM processors. Manufacturing Toolkit - The Manufacturing Toolkit software enables the manufacturer to load credential into devices. It implements the DI protocol, and includes support for database storage of credentials and is designed to integrate into the manufacturers IT processes. Reseller Toolkit - The Reseller Toolkit enables distributors and System Integrators to manage the ownership credential over the devices lifetime. It implements the DI protocol. Rendezvous Service - The Rendezvous Service software provides a complete Rendezvous service, and implements the TO0 and TO1 protocols required for device registration and discovery. It can be run in the cloud or on-premise and includes an interface to support key attestation. IOT Platform SDK - The IOT Platform SDK provides micro-services to facilitate integration of an IOT Platform in the Secure Device Onboard processes. It implements the TOO protocol required for device registration, and the TO2 protocol required for device ownership transfer. Protocol Reference Implementation - The Protocol Reference Implementation provides a self-contained implementation of the Secure Device Onboard protocols, which can be used as a reference implementation, as a place to get started prototyping new protocol features, or as a validation tool A directory of documentation and source repositories for the Secure Device Onboard software can be found on the Reference page .","title":"Secure Device Onboard Software"},{"location":"#the-secure-device-onboard-process","text":"This section describes a typical process in which Secure Device Onboard is used to automatically and securely onboard a device onto an owners network. Those process include: Device Initialization - A manufacturer initializes a device enabled with Secure Device Onboard Client software by setting the initial credentials in the device\u2019s firmware, copying required files to the device\u2019s OS, and storing the required security data in a backend IT system. Credential Management \u2013 The manufacturers and supply chain integrators run a tool to manage security keys and ownership credentials that correspond to each device. These credentials do not reside on the device and are used to negotiate trust as devices are bought and sold. Transfer To IoT Platform \u2013 The ownership credentials are imported into an SDO-enabled IoT Platform. Device Registration \u2013 The ownership credentials are synchronized between the device management service and the rendezvous server. Onboarding - The process of verifying the device identity with the rendezvous server and brokering a trusted connection to the intended IoT platform when a device is powered on and connected to the Internet. The following diagram shows an example of a possible IoT supply chain and the steps taken by each participant in the Secure Device Onboard service. Each step is described in more detail in following sections. Enablement and Onboarding Process","title":"The Secure Device Onboard Process"},{"location":"#step-1-manufacturing","text":"The manufacturer sets up a manufacturing station that uses the Secure Device Onboard Manufacturer Toolkit to initialize the device. Device initialization puts the Secure Device Onboard client software and security credentials on the device. Device initialization also creates an ownership voucher. The ownership voucher is a digital document that securely records changes in ownership. The ownership voucher travels with the device but is never physically on a device, which is similar to, for example, a shipping invoice. Each device has a unique ownership voucher. The ownership voucher contains the following information: Device GUID : A unique string that identifies the device Credential ID : A reference to the ownership voucher Rendezvous Server Location : One or more URIs identifying where a Secure Device Onboard Rendezvous Service can be contacted by the device Manufacturers public key : A key uniquely identifying the manufacturer of the device Behind the scenes, the Manufacturer Toolkit uses the Device Initialize (DI) protocol to perform device initialization. After device initialization is complete, the manufacturer associates the ownership voucher with the device, for example, by associating the GUID with the device serial number. For tracking, the manufacturer can also print the GUID on a label on the device box. When the manufacturer sells the device to a distributor, the manufacturer acquires the distributor\u2019s public key as a part of the ordering process. The manufacturer then uses the Manufacturer Toolkit to counter-sign the ownership voucher. This requires adding the distributor\u2019s public key to the ownership voucher. The manufacturer then ships the device to the distributor and sends the ownership voucher to the distributor via either a file or through B2B integration.","title":"Step 1: Manufacturing"},{"location":"#step-2-distribution","text":"The distributor receives the device and ownership voucher from the manufacturer. Like the manufacturer, the distributor associates the ownership voucher with the device, for example, by associating the GUID with the device serial number. When the distributor sells the device to the system integrator or another retailer, the distributor acquires the buyer\u2019s public key as a part of the ordering process. The distributor then uses SDO reseller toolkit to counter-sign the ownership voucher. The distributor then ships the device to the buyer and sends the ownership voucher via either a file or through B2B integration. The preceding process continues until the device is sold to a system integrator.","title":"Step 2: Distribution"},{"location":"#step-3-system-integration","text":"The system integrator receives the device and ownership voucher from the distributor. Like the distributor, the system integrator associates the ownership voucher with the device, for example, by associating the GUID with the device serial number. The system integrator acquires the IoT Platform provider\u2019s public key and uses the Secure Device Onboard Reseller Toolkit to counter-sign the ownership voucher for the last time. The system integrator then sends the ownership voucher to the IoT Platform service provider via either a file or through B2B integration.","title":"Step 3: System Integration"},{"location":"#step-4-ownership","text":"The IoT Platform provider registers the ownership voucher with the Rendezvous Service . The Rendezvous Service may be operated by a cloud service provider, the IOT Platform service provider, or other service provider entity. Behind the scenes, the IOT Platform uses the Transfer Ownership 0 (TO0) protocol to communicate with the Rendezvous server. To facilitate easy integration with Secure Device Onboard, the IOT Platform can use the Secure Device Onboard IOT Platform SDK , which implements the protocol features required by the IPT Platform to communicate with the Rendezvous service, and provides an easy REST-based interface to communicate between the SDK components and the IOT Platform.","title":"Step 4: Ownership"},{"location":"#step-5-device-discovers-iot-platform","text":"At this point, the system integrator installs the device, applies power, and connects it to the Internet. The device uses the location of the rendezvous server provided in step 1 to contact the Rendezvous Service, whereupon it receives a URI indicating where to connect to the IoT platform provider. Behind the scenes, the Secure Device Onboard Client SDK software uses the Transfer Ownership 1 (TO1) protocol to communicate with the Rendezvous Service. Note that ideally, the system integrator waits to install the device until it has received confirmation from the IoT Platform that Step 4 is complete. However, if the device contacts the rendezvous server before Step 4 is complete, the device will continue to retry the connection to the server until it gets the IoT Platform location.","title":"Step 5: Device Discovers IOT Platform"},{"location":"#step-6-device-onboards","text":"After receiving the IoT Platform URI, the device contacts the IoT platform. The IoT platform provides new security credentials. The credentials programmed during device initialization are now replaced with the new credentials. Behind the scenes, the device uses the Transfer Ownership 2 (TO2) protocol to communicate with the IOT Platform SDK. At this point, the onboarding is complete. The system integrator and IoT Platform can now complete additional provisioning steps on their own because a trusted connection has been established between the device and the IoT Platform.","title":"Step 6: Device Onboards"},{"location":"#next-steps","text":"","title":"Next Steps"},{"location":"#contributors","text":"Contributors can get started by visiting the Secure Device Onboard Community page.","title":"Contributors"},{"location":"#developers-and-integrators","text":"Developers and Integrators can take the next step by reviewing the documentation for the components they are interested in. The Reference page provides links to all of Secure Device Onboard documentation mentioned here, links to the Secure Device Onboard project source repositories, and a glossary of Secure Device Onboard terminology. The Releases page provide links to Secure Device Onboard binary releases. The Secure Device Onboard Protocol Specification provides developers with the details of protocol operation. The Protocol Reference Implementation provides a self-contained implementation of the Secure Device Onboard protocol, which can be used as a reference implementation, as a place to get started prototyping new protocol features, or as a validation tool","title":"Developers and Integrators"},{"location":"#all-in-one-demo","text":"The All-In-One Demo runs the Rendezvous Service, a simulated IOT Platform using the IOT Platform SDK , and the Manufacturing Toolkit . Using it, you can run a device enable with the Client SDK software through the entire Secure Device Onboard lifecycle.","title":"All-In-One Demo"},{"location":"#manufacturers","text":"Manufacturers interested in implementing support for Secure Device Onboard in their factories can learn more by referring to the Secure Device Onboard Manufacturer Enablement Guide .","title":"Manufacturers"},{"location":"#distributers-and-resellers","text":"Distributers and resellers interested in implementing support for Secure Device Onboard in their business processes can learn more by referring to the Secure Device Onboard Reseller Enablement Guide","title":"Distributers and Resellers"},{"location":"#iot-platform-providers","text":"IOT Platform Providers interested in implementing support for Secure Device Onboard in their IOT Platforms can learn more by referring to the Secure Device Onboard IoT Platform Integration SDK Reference Guide","title":"IOT Platform Providers"},{"location":"#cloud-service-operators","text":"Cloud Service Operators interested in supporting Secure Device Onboarding in their IOT services can learn more by referring to the Secure Device Onboard Protocol , the Rendezvous Service implementation, and the Protocol Reference Implementation .","title":"Cloud Service Operators"},{"location":"community/","text":"Community \u00b6 Welcome to the Secure Device Onboard community! Join the Discussion \u00b6 Report issues using each component's respective github repository. Contribute \u00b6 Secure Device Onboard is made available under the Apache License 2.0. The project accepts contributions via GitHub pull requests. If you are contemplating a large change or major contribution to the Secure Device Onboard project, please first submit an issue outlining your proposed changes or contribution. This will allow the community to provide feedback on the proposal and ensure alignment with project goals and processes. The Commit Process \u00b6 When contributing code, please follow these guidelines: Your contribution must be submitted under the Apache License 2.0. Include the Apache License header or SPDX header in every source file. See the following for specific guidance: https://www.apache.org/licenses/LICENSE-2.0#apply https://spdx.org/licenses/Apache-2.0.html Any 3rd-party dependencies required by your code to execute must be available under the Apache 2.0 license. Exceptions should be discussed in advance by submitting an issue for review. Fork the repository and make your changes in a feature branch Include unit and integration tests for any new features, as well as updates to existing tests Ensure that existing unit and integration tests run successfully. Instructions on how to run unit tests can be found in the readme in each component's respective repository. Ensure that coding style checks pass. Instructions on how to run coding style checks can be found in the readme in each components respective repository. Pull Request Guidelines \u00b6 A pull request can contain a single commit or multiple commits. The most important guideline is that a single commit should map to a single fix or enhancement. Here are some example scenarios: If a pull request adds a feature but also fixes two bugs, the pull request should have three commits: one commit for the feature change and two commits for the bug fixes. If a pull request is opened with five commits that contain changes to fix a single issue, the pull request should be rebased to a single commit. If a pull request is opened with several commits, where the first commit fixes one issue and the rest fix a separate issue, the pull request should be rebased to two commits (one for each issue). Note Your pull request should be rebased against the current master branch. Do not merge the current master branch in with your topic branch. Do not use the Update Branch button provided by GitHub on the pull request page. Commit Messages \u00b6 Commit messages should follow common Git conventions, such as using the imperative mood, separate subject lines, and a line length of 72 characters. These guidelines and more are documented here: https://chris.beams.io/posts/git-commit/#seven-rules Signed-off-by \u00b6 Each commit must include a \u201cSigned-off-by\u201d line in the commit message (git commit -s). This sign-off indicates that you agree the commit satisfies the Developer Certificate of Origin ( DCO ). Commit Email Address \u00b6 Your commit email address must match your GitHub email address. For more information, see https://help.github.com/articles/setting-your-commit-email-address-in-git/ Important GitHub Requirements \u00b6 A pull request cannot merged until it has passed these status checks: The build must pass on Jenkins The pull request must be approved by at least two reviewers without any outstanding requests for changes Reporting Issues \u00b6 Report issues using each component's respective github repository. Code of Conduct \u00b6 When participating, please be respectful and courteous. The Secure Device Onboard project follows the LF Edge Code of Conduct: https://lfprojects.org/policies/code-of-conduct/ Acknowledgements \u00b6 This project uses software developed by the OpenSSL* Project for use in the OpenSSL* Toolkit ( http://www.openssl.org/ ). This project relies on other third-party components. For details, see the NOTICE file and/or folder in each components respective repository.","title":"Community"},{"location":"community/#community","text":"Welcome to the Secure Device Onboard community!","title":"Community"},{"location":"community/#join-the-discussion","text":"Report issues using each component's respective github repository.","title":"Join the Discussion"},{"location":"community/#contribute","text":"Secure Device Onboard is made available under the Apache License 2.0. The project accepts contributions via GitHub pull requests. If you are contemplating a large change or major contribution to the Secure Device Onboard project, please first submit an issue outlining your proposed changes or contribution. This will allow the community to provide feedback on the proposal and ensure alignment with project goals and processes.","title":"Contribute"},{"location":"community/#the-commit-process","text":"When contributing code, please follow these guidelines: Your contribution must be submitted under the Apache License 2.0. Include the Apache License header or SPDX header in every source file. See the following for specific guidance: https://www.apache.org/licenses/LICENSE-2.0#apply https://spdx.org/licenses/Apache-2.0.html Any 3rd-party dependencies required by your code to execute must be available under the Apache 2.0 license. Exceptions should be discussed in advance by submitting an issue for review. Fork the repository and make your changes in a feature branch Include unit and integration tests for any new features, as well as updates to existing tests Ensure that existing unit and integration tests run successfully. Instructions on how to run unit tests can be found in the readme in each component's respective repository. Ensure that coding style checks pass. Instructions on how to run coding style checks can be found in the readme in each components respective repository.","title":"The Commit Process"},{"location":"community/#pull-request-guidelines","text":"A pull request can contain a single commit or multiple commits. The most important guideline is that a single commit should map to a single fix or enhancement. Here are some example scenarios: If a pull request adds a feature but also fixes two bugs, the pull request should have three commits: one commit for the feature change and two commits for the bug fixes. If a pull request is opened with five commits that contain changes to fix a single issue, the pull request should be rebased to a single commit. If a pull request is opened with several commits, where the first commit fixes one issue and the rest fix a separate issue, the pull request should be rebased to two commits (one for each issue). Note Your pull request should be rebased against the current master branch. Do not merge the current master branch in with your topic branch. Do not use the Update Branch button provided by GitHub on the pull request page.","title":"Pull Request Guidelines"},{"location":"community/#commit-messages","text":"Commit messages should follow common Git conventions, such as using the imperative mood, separate subject lines, and a line length of 72 characters. These guidelines and more are documented here: https://chris.beams.io/posts/git-commit/#seven-rules","title":"Commit Messages"},{"location":"community/#signed-off-by","text":"Each commit must include a \u201cSigned-off-by\u201d line in the commit message (git commit -s). This sign-off indicates that you agree the commit satisfies the Developer Certificate of Origin ( DCO ).","title":"Signed-off-by"},{"location":"community/#commit-email-address","text":"Your commit email address must match your GitHub email address. For more information, see https://help.github.com/articles/setting-your-commit-email-address-in-git/","title":"Commit Email Address"},{"location":"community/#important-github-requirements","text":"A pull request cannot merged until it has passed these status checks: The build must pass on Jenkins The pull request must be approved by at least two reviewers without any outstanding requests for changes","title":"Important GitHub Requirements"},{"location":"community/#reporting-issues","text":"Report issues using each component's respective github repository.","title":"Reporting Issues"},{"location":"community/#code-of-conduct","text":"When participating, please be respectful and courteous. The Secure Device Onboard project follows the LF Edge Code of Conduct: https://lfprojects.org/policies/code-of-conduct/","title":"Code of Conduct"},{"location":"community/#acknowledgements","text":"This project uses software developed by the OpenSSL* Project for use in the OpenSSL* Toolkit ( http://www.openssl.org/ ). This project relies on other third-party components. For details, see the NOTICE file and/or folder in each components respective repository.","title":"Acknowledgements"},{"location":"reference/","text":"Project Documentation \u00b6 The Introduction provides and overview of Secure Device Onboard operation, its associated protocols, and the software components that implement those protocols and support the Secure Device Onboard ecosystem. All-in-one Demo documentation provided information on how to run All-in-one Demo that facilitates an easy demonstration of Secure Device Onboard protocols. Client SDK documentation provides information for device manufacturers on how to use the Client SDK to support Secure Device Onboard on their devices. The Client SDK is a portable implementation of the Secure Device Onboard protocol state machines, cryptographic operations, and associated support software. IOT Platform SDK documentation provides developers and system integrators with information on how to use the IOT Platform SDK to integrate Secure Device Onboard capabilities into their IOT Platform or Device Management System. Rendezvous Service documentation provides information on how to configure and operate the Rendezvous service component software. Manufacturing Tools documentation provides information for device manufactures on how to use the Manufacturing Toolkit to integrate Secure Device Onboard into their manufacturing processes. Reseller Tools documentation provides information for resellers of enabled devices to use the Reseller Toolkit to prepare devices for transfer of ownership to new entities. Key Store Setup documentation provides manufacturers and resellers with information on how to set up key-store capability for different Secure Device Onboard components. Protocol Reference Implementation documentation provides developers with information on how to operate the reference implementation of the Secure Device Onboard protocol. Protocol Specification documentation provides developers with complete details of the Secure Device Onboard protocol. Project Repositories \u00b6 Component Source Repository All-in-one Demo https://github.com/secure-device-onboard/all-in-one-demo Client SDK https://github.com/secure-device-onboard/client-sdk Reseller and Manufacturing Toolkits https://github.com/secure-device-onboard/supply-chain-tools IOT Platform SDK https://github.com/secure-device-onboard/iot-platform-sdk Rendezvous Service https://github.com/secure-device-onboard/rendezvous-service Protocol Reference Implementation https://github.com/secure-device-onboard/pri Terminology \u00b6 Term Description API Acronym - Application Programming Interface. An Application Programming Interface is a set of subroutine definitions, protocols, and tools for building application software. Application Whitelisting Term - Application whitelisting is the practice of specifying an index of approved software applications that are permitted to be present and active on a computer system. The goal of whitelisting is to protect computers and networks from potentially harmful applications. A minimum IoT Security best practice to allow an explicit, limited list of applications to run on an IoT Device. Compare to Anti-Virus which blacklists known bad applications to disallow their execution, but only (long) after they have been discovered to be bad. Whitelisting disallows ALL applications, except those known good ones on the IoT Device\u2019s Whitelist. Board or System OEM Term - An IoT Device manufacturer (OEM/ODM) who designs the hardware & software, assembles a board and/or system using a processor. CA Acronym - Certificate Authority. In cryptography, a certificate authority or certification authority (CA) is an entity that issues digital certificates. A digital certificate certifies the ownership of a public key by the named subject of the certificate. Client Term \u2013 Secure Device Onboard code that implements the Secure Device Onboard Ownership transfer within an IoT Device. CoAP Acronym - Constrained Application Protocol. A specialized web transfer protocol for use with constrained nodes and constrained networks in the Internet of Things. The protocol is designed for machine-to-machine (M2M) applications such as smart energy and building automation. COS Acronym - Code Origination Scan. An audit process for software code. Run on created software that may be using open source code or samples. It allows companies to properly attribute all code snippets and usage to the correct owners as well as any hazardous code usage. The code scan is a discovery process that removes uncertainties around IP ownership. Counter-signed Ownership Voucher Term - The Ownership Voucher can be extended by each entity in the supply chain that legally and physically possesses/owns the IoT Device on the way to its ultimate Owner. The counter-signing is accomplished electronically by adding a subsequent signature to the (counter-signed) Ownership Voucher received from the previous possessor in the Supply Chain \u2013 without having to open the shipping container and without powering the IoT Device on. CRL Certificate Revocation List CSP Acronym - Cloud Service Provider. A cloud provider is a company that offers some component of cloud computing \u2013 typically Infrastructure as a Service (IaaS), Software as a Service (SaaS) or Platform as a Service (PaaS) \u2013 to other businesses or individuals. CSR Acronym - Certificate Signing Request DAA Acronym - Direct Anonymous Attestation. Device A gateway, microprocessor, or microcontroller that is capable of sending information via a network protocol such as HTTP or Bluetooth\u00ae and is enabled with Secure Device Onboard. Device Credentials Term - The Ownership data embedded in an Secure Device Onboard enabled-device used to establish Trust with an IOT Platform Service by proving the authenticity of the Ownership Voucher presented by the Secure Device Onboard Owner. Device GUID Term/Acronym - Device Global Unique Identification. A Globally Unique ID that is a not-easily guessable ID that is generally randomly generated and sparsely populated within a large set of possible values. It is embedded in the IoT Device, included in the Ownership Voucher and printed on the outside of the shipping container. It is used to extend the Ownership Voucher without opening the shipping container and to identify an IoT Device within the Secure Device Onboard service as an index for the rendezvous between the IoT Platform Service and the IoT Device. Device Management Agent Term - Code that runs on an IoT Device to provide the normal, day-to-day, minute-to-minute interaction with the Device Management Service after the IoT Device is onboarded. The agent can be distributed with the Secure Device Onboard device, or downloaded to the Device during Secure Device Onboard onboarding. Device Management Service Term - Back end service used by customer that ultimately will take ownership-on-behalf-of an IoT Device to manage services, security or access. Can include Cloud Service Provider (CSP), Identity and Access Management platform (IAM), IoT Platform Management services (like Building Management Services (BMS), Oil and Gas platform management services, etc.) and other Independent Software Vendors (ISV). The Secure Device Onboard Owner functions are implemented within the Device Management Service to accomplish the Secure Device Onboard ownership transfer on behalf of the service in the legal owner\u2019s account. DHKEX Acronym - Diffie-Hellman Key EXchange protocol. A method of securely exchanging cryptographic keys over a public channel and was one of the first public-key protocols as originally conceptualized by Ralph Merkle and named after Whitfield Diffie and Martin Hellman. The protocol is one of the earliest practical examples of public key exchange that is implemented within the field of cryptography. DI Device Initialization Distributor/Reseller Term - An entity in the supply chain between the Board/System OEM and the Owner. DSA Acronym - Digital Signature Algorithm. The Digital Signature Algorithm (DSA) is a Federal Information Processing Standard for digital signatures. ECC Acronym - Elliptical Curve Cryptography. Elliptic Curve Cryptography Elliptic curve cryptography is an approach to public key cryptography based on the algebraic structure of elliptic curves over finite fields. EC-DSA Acronym - Elliptic Curve DSA. The Elliptic Curve Digital Signature Algorithm (ECDSA) is a variant of the Digital Signature Algorithm (DSA) which uses elliptic curve cryptography. EPID (group) public-key, EPID (private) member-key Term - EPID keys come as Group keys; there is one public-key associated with many private-keys in a group. All members of a group can sign with their unique member-key and the signature can be verified with the group public-key, without revealing which specific member did the signing (privacy attribute). Group based revocation Term - The issuer revokes the whole Intel \u00ae EPID group by revoking the group public key. Group based revocation is expected to be a rare event and would only happen under limited criteria. The GroupRL nomenclature is used to denote the revocation list corresponding to this method. GroupRL Acronym - Group Revocation List. A list of certificates that have been revoked and are no longer valid. The GroupRL nomenclature is used to denote the revocation list corresponding to this method. GUID Acronym - Globally Unique Identifier. A GUID is a term used for a number that is generated to create a unique identity for an entity such as a document. Hardware Root of Trust Term - Acronym - HWRoT - A hardware key provisioned into the device during its manufacture, whose signatures can be verified to have this providence. HMAC Acronym - Hash-based Message Authentication Code. In cryptography, a keyed-hash message authentication code (HMAC) is a specific type of message authentication code (MAC) involving a cryptographic hash function and a secret cryptographic key. IANA Acronym - Internet Assigned Numbers Authority. The global coordination of the DNS Root, IP addressing, and other Internet protocol resources is performed as the Internet Assigned Numbers Authority. Installer Tool Term \u2013 Android based tool to provide network connection to Secure Device Onboard Clients Device OEM/ODM Term - A Board or System OEM/ODM that builds an IoT Device. Intel Client Term \u2013 Secure Device Onboard Client implementation done on an Intel X86-based platform using Intel \u00ae ME technology. Intel \u00ae EPID Acronym - Intel \u00ae Enhanced Privacy ID. Intel \u00ae EPID is an algorithm developed by Intel Corporation for attestation of a trusted system while preserving privacy. Intel \u00ae ME Acronym \u2013 Intel \u00ae Management Engine. A secondary (service) processor located on the motherboard, and uses TLS-secured communication and strong encryption to provide additional security. IoT Attack Map Term - A map of devices and the infrastructure they inhabit, control or monitor, that allows an attacker to plan or implement an attack on those devices or that physical infrastructure because of a cyberspace vulnerability that exists now or is discovered the future. IoT Device Term - A \u201cThing\u201d on the Internet of Things. An embedded system that usually resides at or near the edge of a network and provides functionality more in a Machine-to-Machine (M2M) fashion than with a direct user-interface. IOT or IoT Acronym - Internet of Things IoT Platform Term \u2013 Software solution to manage IoT devices. IoT Platform SDK Term \u2013 Secure Device Onboard code that implements the Secure Device Onboard Ownership transfer on behalf of the IoT Platform Service. Usually integrated with or contained in the IOT Platform or Device Management Service. JHI Acronym \u2013 Java* Host Interface JKS Acronym - Java* Keystore File.A file with extension jks serves as keystore. The Java Development Kit maintains a CA keystore in folder jre/lib/security/cacerts. JDKs provide a tool named keytool to manipulate the keystore. JNI Acronym \u2013 Java* Native Interface. A programming framework that enables Java code running in a Java Virtual Machine (JVM) to call and be called by native applications (programs specific to a hardware and operating system platform) and libraries written in other languages such as C, C++ and assembly. JSON* Acronym - JavaScript Object Notation. A lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. KDC Acronym - Key Distribution Center. Acts as both an Authentication Server and as a Ticket Granting Server. When a client needs to access a resource on the server, the user credentials (password, Smart Card, biometrics) are presented to the Key Distribution Center for authentication. If the user credentials are successfully verified in the Key Distribution Center then a Ticket Granting Ticket (TGT) is issued to the client. The TGT is cached in the local machine for future use. The TGT expires when the user disconnects or log off the network, or after it expires. The default expiry time is one day (86400 seconds). KDF Acronym - Key Derivation Function. A key derivation function (KDF) derives one or more secret keys from a secret value such as a master key, a password, or a passphrase using a pseudo-random function. Manufacturer The initial installer of Secure Device Onboard onto a device. Manufacturing Credential Term - An ownership credential stored in the device during manufacturing that contains the identity of the manufacturer and a device info string that indicates the kind of device this is. It does not otherwise identify the Device. MCU Acronym - Microcontroller Unit. A small computer on a single integrated circuit. Modules Modules are defined by the device manufacturer (ODM) and are pieces of code that have a specific name and perform a specific function. Firmware update, key provisioning, and Wi-Fi* network setup are some examples of common functionality that could be provided by modules. NO Acronym \u2013 New Owner identity protocol OC Ownership Credentials OCF Acronym - Open Conductivity Framework or Open Conductivity Forum OCSP Online Certificate Status Protocol ODM Acronym - An Original Design Manufacturer (ODM) is a company that designs and manufactures a product as specified and eventually rebranded by another firm for sale. Onboarding Term - Establishing a two-way trust relationship between an IoT Device and a Device Management Service, including provisioning of credentials and instructions/policies to allow the IoT Device to be controlled by the Device Management Service. OP Older acronym for Ownership Voucher OPS Acronym \u2013 Owner Protocol Service OSI Acronym \u2013 Owner Service Information. Owner Service Information is information accepted by the module, from the Owner Service. OV Ownership Voucher Owner Same as \u2018IoT Platform SDK\u2019 Owner Term \u2013 The final purchaser and legal owner of an IoT Device. Ownership Credential Term - In Secure Device Onboard, a credential stored in the Device during manufacturing that contains a public key and a GUID. Ownership Voucher Term - An electronic ownership record used to prove ownership to the IoT Device. It can be extended in the supply chain by adding subsequent signatures. The Owner provides the Ownership Voucher to the IoT Platform of their choosing. The Device Management Service uses the Ownership Voucher to register its ownership-on-behalf-of claim with the Rendezvous Service and then prove it to the IoT Device. PEM Acronym \u2013 Privacy-Enhanced Mail. An Internet standard that provides for secure exchange of electronic mail. PKI Acronym - Public Key Infrastructure. A set of roles, policies, and procedures needed to create, manage, distribute, use, store, and revoke digital certificates and manage public-key encryption PRI Acronym - Protocol Reference Implementation. A reference implementation of the Secure Device Onboard protocols. Private-key based revocation Term - The issuer revokes a member based on the member\u2019s private key. This revocation method is used when a member\u2019s private key becomes exposed and subject to revocation criteria. The PrivRL nomenclature is used to denote the revocation list corresponding to the private key list. PrivRL Acronym - Private-key based Revocation List. See above. PSI Acronym \u2013 Pre-Service Info. Pre-Service Info consists of an Owner Server\u2019s expectations in terms of module support. PXE Acronym - Preboot eXecution Environment. A specification describes a standardized client-server environment that boots a software assembly, retrieved from a network, on PXE-enabled clients. On the client side it requires only a PXE-capable network interface controller (NIC), and uses a small set of industry-standard network protocols such as DHCP and TFTP. Rendezvous Service Term - A service to arrange a rendezvous between two entities that want to establish trust between them. Secure Device Onboard does not create the trust, rather, after the two devices rendezvous, they independently establish Trust between themselves. Retailer Term - An entity at the final transaction in the supply chain that sells an IoT Device directly to an Owner. RNG Acronym - Random Number Generator. The generation of a sequence of numbers or symbols that cannot be reasonably predicted better than by a random chance. RoT Acronym - Root of Trust. An authoritative entity for which trust is assumed and not derived. RTOS Real-Time Operating System RV Rendezvous Service SDK Acronym - Software Development ToolKit Secure Device Onboard Secure Device Onboard is the name of the protocol used for onboarding the devices to IoT Platform. Secure Device Onboard IoT Device Agent Term - The application that runs at initial boot on an IoT Device to accomplish \u201czero touch\u201d onboarding with the Device Management Service using the Rendezvous Service. Secure Device Onboard Protocols Term - The API code used by the Device Management Service to enable their services. (For example, take in the Ownership Voucher, associate it with a registered user account and interact with the Rendezvous Service and the IoT Device Secure Device Onboard Onboarding Agent. Secure Device Onboard URL Acronym \u2013 The Secure Device Onboard URL that is imbedded in an IoT device used to contact the Rendezvous Service upon first time power-on to accomplish the rendezvous protocol with its device management service. SEK Session Encryption Key SHA Acronym - Secure Hash Algorithm Signature based revocation Term - The issuer revokes a member based on the signature generated by the member. This revocation method is used when a key becomes subject to revocation criteria but has not be exposed yet. The SigRL nomenclature is used to denote the revocation list corresponding to this method. SigRL Acronym - Signature based Revocation List. See above. Supply Chain Toolkit Term \u2013 Secure Device Onboard code that performs device initialization, management of signing keys, and counter-signing of ownership vouchers while a device is traveling through the supply chain. SVK Session Verification Key TA Acronym - Trusted Application. Trusted applications are applications are signed to run within a TEE. TB Acronym - Trust Broker. A specifically identified agent that can manage trust between entities. TCB Acronym - Trusted Computing Base. A computer system is the set of all hardware, firmware, and/or software components that are critical to its security, in the sense that bugs or vulnerabilities occurring inside the TCB might jeopardize the security properties of the entire system. TEE Acronym - Trusted Execution Environment. A segmented computing environment which runs a body of code that is believed to be trusted when installed. The reason for this original belief can vary. It is typical to cryptographically link a TEE back to its original trusted state, such as using digital signatures or crypto-hashes to prove that it has not been tampered with. The key used to do this is commonly called the Hardware Root of Trust. TLS Acronym - Transport Level Security TO0 Acronym - Transfer of Ownership, step 0: establishes a connection with the Owner to the Rendezvous server and creates trust that it has ownership of an Ownership Voucher so Service Info can be transmitted. TO0Client A utility program that runs the TO0 protocol. It takes an Ownership Voucher as input, runs the TO0 protocol, resulting in the OP being stored in the Rendezvous server. TO1 Acronym - Transfer of Ownership, step 1: Establishes a connection from a Device to the Rendezvous server. TO2 Acronym - Transfer of Ownership, step 2: Establishes a trusted, secure connection between the Device and the final Owner and enables the Owner to configure the device as per the requirement from DMS. TOFU Acronym - Trust On First Use TPM Acronym - Trusted Platform Module URI Uniform Resource Identifier (URI) URL Acronym - Uniform Resource Locator. A web address, is a reference to a web resource that specifies its location on a computer network and a mechanism for retrieving it. A URL is a specific type of Uniform Resource Identifier (URI). Verifier blacklist revocation The verifier blacklists a member based on the name-based signature generated by the member. This revocation method is used when the verifier suspects a key becomes subject to his own revocation criteria. The VerifierRL nomenclature is used to denote the revocation list corresponding to this method. VerifierRL Acronym - Verifier Revocation List. See above.","title":"Reference"},{"location":"reference/#project-documentation","text":"The Introduction provides and overview of Secure Device Onboard operation, its associated protocols, and the software components that implement those protocols and support the Secure Device Onboard ecosystem. All-in-one Demo documentation provided information on how to run All-in-one Demo that facilitates an easy demonstration of Secure Device Onboard protocols. Client SDK documentation provides information for device manufacturers on how to use the Client SDK to support Secure Device Onboard on their devices. The Client SDK is a portable implementation of the Secure Device Onboard protocol state machines, cryptographic operations, and associated support software. IOT Platform SDK documentation provides developers and system integrators with information on how to use the IOT Platform SDK to integrate Secure Device Onboard capabilities into their IOT Platform or Device Management System. Rendezvous Service documentation provides information on how to configure and operate the Rendezvous service component software. Manufacturing Tools documentation provides information for device manufactures on how to use the Manufacturing Toolkit to integrate Secure Device Onboard into their manufacturing processes. Reseller Tools documentation provides information for resellers of enabled devices to use the Reseller Toolkit to prepare devices for transfer of ownership to new entities. Key Store Setup documentation provides manufacturers and resellers with information on how to set up key-store capability for different Secure Device Onboard components. Protocol Reference Implementation documentation provides developers with information on how to operate the reference implementation of the Secure Device Onboard protocol. Protocol Specification documentation provides developers with complete details of the Secure Device Onboard protocol.","title":"Project Documentation"},{"location":"reference/#project-repositories","text":"Component Source Repository All-in-one Demo https://github.com/secure-device-onboard/all-in-one-demo Client SDK https://github.com/secure-device-onboard/client-sdk Reseller and Manufacturing Toolkits https://github.com/secure-device-onboard/supply-chain-tools IOT Platform SDK https://github.com/secure-device-onboard/iot-platform-sdk Rendezvous Service https://github.com/secure-device-onboard/rendezvous-service Protocol Reference Implementation https://github.com/secure-device-onboard/pri","title":"Project Repositories"},{"location":"reference/#terminology","text":"Term Description API Acronym - Application Programming Interface. An Application Programming Interface is a set of subroutine definitions, protocols, and tools for building application software. Application Whitelisting Term - Application whitelisting is the practice of specifying an index of approved software applications that are permitted to be present and active on a computer system. The goal of whitelisting is to protect computers and networks from potentially harmful applications. A minimum IoT Security best practice to allow an explicit, limited list of applications to run on an IoT Device. Compare to Anti-Virus which blacklists known bad applications to disallow their execution, but only (long) after they have been discovered to be bad. Whitelisting disallows ALL applications, except those known good ones on the IoT Device\u2019s Whitelist. Board or System OEM Term - An IoT Device manufacturer (OEM/ODM) who designs the hardware & software, assembles a board and/or system using a processor. CA Acronym - Certificate Authority. In cryptography, a certificate authority or certification authority (CA) is an entity that issues digital certificates. A digital certificate certifies the ownership of a public key by the named subject of the certificate. Client Term \u2013 Secure Device Onboard code that implements the Secure Device Onboard Ownership transfer within an IoT Device. CoAP Acronym - Constrained Application Protocol. A specialized web transfer protocol for use with constrained nodes and constrained networks in the Internet of Things. The protocol is designed for machine-to-machine (M2M) applications such as smart energy and building automation. COS Acronym - Code Origination Scan. An audit process for software code. Run on created software that may be using open source code or samples. It allows companies to properly attribute all code snippets and usage to the correct owners as well as any hazardous code usage. The code scan is a discovery process that removes uncertainties around IP ownership. Counter-signed Ownership Voucher Term - The Ownership Voucher can be extended by each entity in the supply chain that legally and physically possesses/owns the IoT Device on the way to its ultimate Owner. The counter-signing is accomplished electronically by adding a subsequent signature to the (counter-signed) Ownership Voucher received from the previous possessor in the Supply Chain \u2013 without having to open the shipping container and without powering the IoT Device on. CRL Certificate Revocation List CSP Acronym - Cloud Service Provider. A cloud provider is a company that offers some component of cloud computing \u2013 typically Infrastructure as a Service (IaaS), Software as a Service (SaaS) or Platform as a Service (PaaS) \u2013 to other businesses or individuals. CSR Acronym - Certificate Signing Request DAA Acronym - Direct Anonymous Attestation. Device A gateway, microprocessor, or microcontroller that is capable of sending information via a network protocol such as HTTP or Bluetooth\u00ae and is enabled with Secure Device Onboard. Device Credentials Term - The Ownership data embedded in an Secure Device Onboard enabled-device used to establish Trust with an IOT Platform Service by proving the authenticity of the Ownership Voucher presented by the Secure Device Onboard Owner. Device GUID Term/Acronym - Device Global Unique Identification. A Globally Unique ID that is a not-easily guessable ID that is generally randomly generated and sparsely populated within a large set of possible values. It is embedded in the IoT Device, included in the Ownership Voucher and printed on the outside of the shipping container. It is used to extend the Ownership Voucher without opening the shipping container and to identify an IoT Device within the Secure Device Onboard service as an index for the rendezvous between the IoT Platform Service and the IoT Device. Device Management Agent Term - Code that runs on an IoT Device to provide the normal, day-to-day, minute-to-minute interaction with the Device Management Service after the IoT Device is onboarded. The agent can be distributed with the Secure Device Onboard device, or downloaded to the Device during Secure Device Onboard onboarding. Device Management Service Term - Back end service used by customer that ultimately will take ownership-on-behalf-of an IoT Device to manage services, security or access. Can include Cloud Service Provider (CSP), Identity and Access Management platform (IAM), IoT Platform Management services (like Building Management Services (BMS), Oil and Gas platform management services, etc.) and other Independent Software Vendors (ISV). The Secure Device Onboard Owner functions are implemented within the Device Management Service to accomplish the Secure Device Onboard ownership transfer on behalf of the service in the legal owner\u2019s account. DHKEX Acronym - Diffie-Hellman Key EXchange protocol. A method of securely exchanging cryptographic keys over a public channel and was one of the first public-key protocols as originally conceptualized by Ralph Merkle and named after Whitfield Diffie and Martin Hellman. The protocol is one of the earliest practical examples of public key exchange that is implemented within the field of cryptography. DI Device Initialization Distributor/Reseller Term - An entity in the supply chain between the Board/System OEM and the Owner. DSA Acronym - Digital Signature Algorithm. The Digital Signature Algorithm (DSA) is a Federal Information Processing Standard for digital signatures. ECC Acronym - Elliptical Curve Cryptography. Elliptic Curve Cryptography Elliptic curve cryptography is an approach to public key cryptography based on the algebraic structure of elliptic curves over finite fields. EC-DSA Acronym - Elliptic Curve DSA. The Elliptic Curve Digital Signature Algorithm (ECDSA) is a variant of the Digital Signature Algorithm (DSA) which uses elliptic curve cryptography. EPID (group) public-key, EPID (private) member-key Term - EPID keys come as Group keys; there is one public-key associated with many private-keys in a group. All members of a group can sign with their unique member-key and the signature can be verified with the group public-key, without revealing which specific member did the signing (privacy attribute). Group based revocation Term - The issuer revokes the whole Intel \u00ae EPID group by revoking the group public key. Group based revocation is expected to be a rare event and would only happen under limited criteria. The GroupRL nomenclature is used to denote the revocation list corresponding to this method. GroupRL Acronym - Group Revocation List. A list of certificates that have been revoked and are no longer valid. The GroupRL nomenclature is used to denote the revocation list corresponding to this method. GUID Acronym - Globally Unique Identifier. A GUID is a term used for a number that is generated to create a unique identity for an entity such as a document. Hardware Root of Trust Term - Acronym - HWRoT - A hardware key provisioned into the device during its manufacture, whose signatures can be verified to have this providence. HMAC Acronym - Hash-based Message Authentication Code. In cryptography, a keyed-hash message authentication code (HMAC) is a specific type of message authentication code (MAC) involving a cryptographic hash function and a secret cryptographic key. IANA Acronym - Internet Assigned Numbers Authority. The global coordination of the DNS Root, IP addressing, and other Internet protocol resources is performed as the Internet Assigned Numbers Authority. Installer Tool Term \u2013 Android based tool to provide network connection to Secure Device Onboard Clients Device OEM/ODM Term - A Board or System OEM/ODM that builds an IoT Device. Intel Client Term \u2013 Secure Device Onboard Client implementation done on an Intel X86-based platform using Intel \u00ae ME technology. Intel \u00ae EPID Acronym - Intel \u00ae Enhanced Privacy ID. Intel \u00ae EPID is an algorithm developed by Intel Corporation for attestation of a trusted system while preserving privacy. Intel \u00ae ME Acronym \u2013 Intel \u00ae Management Engine. A secondary (service) processor located on the motherboard, and uses TLS-secured communication and strong encryption to provide additional security. IoT Attack Map Term - A map of devices and the infrastructure they inhabit, control or monitor, that allows an attacker to plan or implement an attack on those devices or that physical infrastructure because of a cyberspace vulnerability that exists now or is discovered the future. IoT Device Term - A \u201cThing\u201d on the Internet of Things. An embedded system that usually resides at or near the edge of a network and provides functionality more in a Machine-to-Machine (M2M) fashion than with a direct user-interface. IOT or IoT Acronym - Internet of Things IoT Platform Term \u2013 Software solution to manage IoT devices. IoT Platform SDK Term \u2013 Secure Device Onboard code that implements the Secure Device Onboard Ownership transfer on behalf of the IoT Platform Service. Usually integrated with or contained in the IOT Platform or Device Management Service. JHI Acronym \u2013 Java* Host Interface JKS Acronym - Java* Keystore File.A file with extension jks serves as keystore. The Java Development Kit maintains a CA keystore in folder jre/lib/security/cacerts. JDKs provide a tool named keytool to manipulate the keystore. JNI Acronym \u2013 Java* Native Interface. A programming framework that enables Java code running in a Java Virtual Machine (JVM) to call and be called by native applications (programs specific to a hardware and operating system platform) and libraries written in other languages such as C, C++ and assembly. JSON* Acronym - JavaScript Object Notation. A lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. KDC Acronym - Key Distribution Center. Acts as both an Authentication Server and as a Ticket Granting Server. When a client needs to access a resource on the server, the user credentials (password, Smart Card, biometrics) are presented to the Key Distribution Center for authentication. If the user credentials are successfully verified in the Key Distribution Center then a Ticket Granting Ticket (TGT) is issued to the client. The TGT is cached in the local machine for future use. The TGT expires when the user disconnects or log off the network, or after it expires. The default expiry time is one day (86400 seconds). KDF Acronym - Key Derivation Function. A key derivation function (KDF) derives one or more secret keys from a secret value such as a master key, a password, or a passphrase using a pseudo-random function. Manufacturer The initial installer of Secure Device Onboard onto a device. Manufacturing Credential Term - An ownership credential stored in the device during manufacturing that contains the identity of the manufacturer and a device info string that indicates the kind of device this is. It does not otherwise identify the Device. MCU Acronym - Microcontroller Unit. A small computer on a single integrated circuit. Modules Modules are defined by the device manufacturer (ODM) and are pieces of code that have a specific name and perform a specific function. Firmware update, key provisioning, and Wi-Fi* network setup are some examples of common functionality that could be provided by modules. NO Acronym \u2013 New Owner identity protocol OC Ownership Credentials OCF Acronym - Open Conductivity Framework or Open Conductivity Forum OCSP Online Certificate Status Protocol ODM Acronym - An Original Design Manufacturer (ODM) is a company that designs and manufactures a product as specified and eventually rebranded by another firm for sale. Onboarding Term - Establishing a two-way trust relationship between an IoT Device and a Device Management Service, including provisioning of credentials and instructions/policies to allow the IoT Device to be controlled by the Device Management Service. OP Older acronym for Ownership Voucher OPS Acronym \u2013 Owner Protocol Service OSI Acronym \u2013 Owner Service Information. Owner Service Information is information accepted by the module, from the Owner Service. OV Ownership Voucher Owner Same as \u2018IoT Platform SDK\u2019 Owner Term \u2013 The final purchaser and legal owner of an IoT Device. Ownership Credential Term - In Secure Device Onboard, a credential stored in the Device during manufacturing that contains a public key and a GUID. Ownership Voucher Term - An electronic ownership record used to prove ownership to the IoT Device. It can be extended in the supply chain by adding subsequent signatures. The Owner provides the Ownership Voucher to the IoT Platform of their choosing. The Device Management Service uses the Ownership Voucher to register its ownership-on-behalf-of claim with the Rendezvous Service and then prove it to the IoT Device. PEM Acronym \u2013 Privacy-Enhanced Mail. An Internet standard that provides for secure exchange of electronic mail. PKI Acronym - Public Key Infrastructure. A set of roles, policies, and procedures needed to create, manage, distribute, use, store, and revoke digital certificates and manage public-key encryption PRI Acronym - Protocol Reference Implementation. A reference implementation of the Secure Device Onboard protocols. Private-key based revocation Term - The issuer revokes a member based on the member\u2019s private key. This revocation method is used when a member\u2019s private key becomes exposed and subject to revocation criteria. The PrivRL nomenclature is used to denote the revocation list corresponding to the private key list. PrivRL Acronym - Private-key based Revocation List. See above. PSI Acronym \u2013 Pre-Service Info. Pre-Service Info consists of an Owner Server\u2019s expectations in terms of module support. PXE Acronym - Preboot eXecution Environment. A specification describes a standardized client-server environment that boots a software assembly, retrieved from a network, on PXE-enabled clients. On the client side it requires only a PXE-capable network interface controller (NIC), and uses a small set of industry-standard network protocols such as DHCP and TFTP. Rendezvous Service Term - A service to arrange a rendezvous between two entities that want to establish trust between them. Secure Device Onboard does not create the trust, rather, after the two devices rendezvous, they independently establish Trust between themselves. Retailer Term - An entity at the final transaction in the supply chain that sells an IoT Device directly to an Owner. RNG Acronym - Random Number Generator. The generation of a sequence of numbers or symbols that cannot be reasonably predicted better than by a random chance. RoT Acronym - Root of Trust. An authoritative entity for which trust is assumed and not derived. RTOS Real-Time Operating System RV Rendezvous Service SDK Acronym - Software Development ToolKit Secure Device Onboard Secure Device Onboard is the name of the protocol used for onboarding the devices to IoT Platform. Secure Device Onboard IoT Device Agent Term - The application that runs at initial boot on an IoT Device to accomplish \u201czero touch\u201d onboarding with the Device Management Service using the Rendezvous Service. Secure Device Onboard Protocols Term - The API code used by the Device Management Service to enable their services. (For example, take in the Ownership Voucher, associate it with a registered user account and interact with the Rendezvous Service and the IoT Device Secure Device Onboard Onboarding Agent. Secure Device Onboard URL Acronym \u2013 The Secure Device Onboard URL that is imbedded in an IoT device used to contact the Rendezvous Service upon first time power-on to accomplish the rendezvous protocol with its device management service. SEK Session Encryption Key SHA Acronym - Secure Hash Algorithm Signature based revocation Term - The issuer revokes a member based on the signature generated by the member. This revocation method is used when a key becomes subject to revocation criteria but has not be exposed yet. The SigRL nomenclature is used to denote the revocation list corresponding to this method. SigRL Acronym - Signature based Revocation List. See above. Supply Chain Toolkit Term \u2013 Secure Device Onboard code that performs device initialization, management of signing keys, and counter-signing of ownership vouchers while a device is traveling through the supply chain. SVK Session Verification Key TA Acronym - Trusted Application. Trusted applications are applications are signed to run within a TEE. TB Acronym - Trust Broker. A specifically identified agent that can manage trust between entities. TCB Acronym - Trusted Computing Base. A computer system is the set of all hardware, firmware, and/or software components that are critical to its security, in the sense that bugs or vulnerabilities occurring inside the TCB might jeopardize the security properties of the entire system. TEE Acronym - Trusted Execution Environment. A segmented computing environment which runs a body of code that is believed to be trusted when installed. The reason for this original belief can vary. It is typical to cryptographically link a TEE back to its original trusted state, such as using digital signatures or crypto-hashes to prove that it has not been tampered with. The key used to do this is commonly called the Hardware Root of Trust. TLS Acronym - Transport Level Security TO0 Acronym - Transfer of Ownership, step 0: establishes a connection with the Owner to the Rendezvous server and creates trust that it has ownership of an Ownership Voucher so Service Info can be transmitted. TO0Client A utility program that runs the TO0 protocol. It takes an Ownership Voucher as input, runs the TO0 protocol, resulting in the OP being stored in the Rendezvous server. TO1 Acronym - Transfer of Ownership, step 1: Establishes a connection from a Device to the Rendezvous server. TO2 Acronym - Transfer of Ownership, step 2: Establishes a trusted, secure connection between the Device and the final Owner and enables the Owner to configure the device as per the requirement from DMS. TOFU Acronym - Trust On First Use TPM Acronym - Trusted Platform Module URI Uniform Resource Identifier (URI) URL Acronym - Uniform Resource Locator. A web address, is a reference to a web resource that specifies its location on a computer network and a mechanism for retrieving it. A URL is a specific type of Uniform Resource Identifier (URI). Verifier blacklist revocation The verifier blacklists a member based on the name-based signature generated by the member. This revocation method is used when the verifier suspects a key becomes subject to his own revocation criteria. The VerifierRL nomenclature is used to denote the revocation list corresponding to this method. VerifierRL Acronym - Verifier Revocation List. See above.","title":"Terminology"},{"location":"releases/","text":"Releases \u00b6 The details about Secure Device Onboard releases are available on GitHub .","title":"Releases"},{"location":"releases/#releases","text":"The details about Secure Device Onboard releases are available on GitHub .","title":"Releases"},{"location":"all-in-one-demo/introduction/","text":"All-in-one Demo Introduction \u00b6 The All-in-one Demo README provides a quick start guide for building and running the Secure Device Onboard All-in-one Demo.","title":"Introduction"},{"location":"all-in-one-demo/introduction/#all-in-one-demo-introduction","text":"The All-in-one Demo README provides a quick start guide for building and running the Secure Device Onboard All-in-one Demo.","title":"All-in-one Demo Introduction"},{"location":"client-sdk/client-sdk-api-reference/","text":"SDO Client SDK API Reference \u00b6 This section describes the APIs provided by the SDO Client SDK as well as public data structures required to support them. Data Structures \u00b6 These structures are defined in the SDO Client SDK header file and used by various SDK APIs. Generic API Return Status \u00b6 This type is returned by all APIs and indicates whether the API call succeeded or failed. Syntax typedef enum { SDO_SUCCESS = 0, SDO_INVALID_PATH, SDO_CONFIG_NOT_FOUND, SDO_INVALID_STATE, SDO_RESALE_NOT_SUPPORTED, SDO_RESALE_NOT_READY, SDO_WARNING, SDO_ERROR SDO_ABORT } sdoSdkStatus; Members SDO_SUCCESS The API call succeeded. SDO_INVALID_PATH A path or address specified was not found or not accessible. SDO_CONFIG_NOT_FOUND An expected configuration file was not found or not accessible. SDO_INVALID_STATE The SDK is in an invalid state to perform the requested operation. SDO_RESALE_NOT_SUPPORTED This configuration of the SDK does not support the Resale Protocol. SDO_RESALE_NOT_READY The SDK is not in a state to execute the Resale Protocol. This error will occur when the Resale API (sdoSdkResale) is called when device ownership transfer has not yet completed successfully. SDO_WARNING This value is used in the SDK error callback to notify the Application that a transient failure occurred. See Error Handling Callback for details. SDO_ERROR The API call did not succeed. We might extend this later (TBD) to allow returning of specific error types as positive values (for example, memory allocation failure, communications failure, and so on). SDO_ABORT This value is returned by the error callback function to prevent the SDK from continuing the transfer of ownership protocol if an error occurred. Details are provided in Error Handling Callback. SDO Device Status \u00b6 This type indicates the current SDO protocol status of the device. Syntax typedef enum { SDO_STATE_PRE_DI = 2, SDO_STATE_PRE_TO1, SDO_STATE_IDLE, SDO_STATE_RESALE, SDO_STATE_ERROR } sdoSdkDeviceStatus; Members SDO_STATE_PRE_DI The SDK is in the pre-Device Initialization state. It is ready to run the DI protocol which can be initiated by calling the sdoSdkRun() API. SDO_STATE_PRE_TO1 The SDK has completed the DI stage and is ready for Device onboarding. The SDK will run the TO1 protocol if the sdoSdkRun() API is called. SDO_STATE_IDLE The SDK has completed ownership transfer and is in the idle state. Calling sdoSdkRun() will have no effect. The Application may only call the sdoSdkResale() API to initiate the Resale protocol at his point. SDO_STATE_RESALE The SDK has is now ready for resale. Calling sdoSdkRun() will run the TO1 & TO2 protocols, to carryout onboarding to the new (post-resale) device owner. SDO_STATE_ERROR This API failed due to an internal error. SDO SDK Error Values \u00b6 This type is passed from the SDK to the Application when an error occurs and indicates details of the error. It is used by the error callback \u2013 see Error Handling Callback. Syntax typedef enum { SDO_RV_TIMEOUT = 1, SDO_CONN_TIMEOUT, SDO_DI_ERROR, SDO_TO1_ERROR, SDO_TO2_ERROR } sdoSdkError; Members SDO_RV_TIMEOUT A timeout occurred when trying to contact the Rendezvous Server. SDO_CONN_TIMEOUT A connection to either the Rendezvous or Owner Server timed out. SDO_DI_ERROR A generic error occurred during the DI stage. SDO_TO1_ERROR A generic error occurred during the TO1 protocol stage. SDO_TO2_ERROR A generic error occurred during the TO2 protocol stage. SDO Service Callback Type \u00b6 This type value indicates the type of function the module callback must perform. These values are used by the Service Information Module Callback function. Syntax typedef enum { SDO_SI_START, SDO_SI_GET_DSI_COUNT, SDO_SI_SET_PSI, SDO_SI_GET_DSI, SDO_SI_SET_OSI, SDO_SI_END, SDO_SI_FAILURE } sdoSdkSiType; Members Below are the parameters of the Service Information Module Callback function described in Service Information Module Callback function. SDO_SI_START This value indicates that the SDK is starting Service Info rounds. The module may perform pre-preparation operations at this time. The count and si parameters will be NULL. SDO_SI_SET_PSI This value indicates that the SDK is returning a pre-service information (PSI) key-value pair that was received from the server to the module. The si.key contains the received key name and is a NULL terminated ASCII string. The si.value parameter contains the PSI value and is assumed to be a NULL terminated string. If no value was received, this value will by NULL . The count will contain the \u2018index\u2019 of the invocation, starting from 0 and incrementing on each subsequent call. If the module needs to retain the contents of the si.key or si.value parameters after the call returns, it must make an internal, local copy. SDO_SI_GET_DSI_COUNT This value indicates that the SDK is requesting the module to return the total number of Device Service Info (DSI) strings it needs to send to the Owner Server. The maximum size of a string is 1,200 bytes. Strings larger than 1,200 bytes need to be split across multiple strings and this count must be factored into the total number of DSI strings for the module. On receiving this call, the module must place the number of DSI strings the module will report into the *count parameter. The si pointer will be NULL . SDO_SI_GET_DSI This value indicates that the SDK is requesting the module to return a particular Device Service Info string. The count parameter contains the index of the DSI value requested. It will progress from zero to the value returned by the response to the SDO_SI_GET_DSI_COUNT callback minus 1. A module must use this value to track where in the DSI list it currently is. The module must set prepare two NULL terminated strings \u2013 one for the DSI key and another for the DSI value. The si.key and si.value pointers must point at these strings before returning from the callback. The memory allocated for si.key and si.value must remain valid (that is, not be freed) until the next time this callback is invoked \u2013 the service info callback sequence will end with SDO_SI_END or SDO_SI_ERROR . SDO_SI_SET_OSI This value indicates that the SDK is providing a valid Owner Service Info (OSI) key-value pair to the module and it must process the provide OSI information. The count parameter is a progressively increasing index value of the provided OSI. The si.key will contain the key value and the si.value will contain the value of the string. Both are valid, NULL terminated strings. The value might be Base 64 encoded binary data. This encoding is module-dependent and should be indicated by the si.key contents. SDO_SI_END This value indicates that the SDK has completed all Service Info rounds and the module can perform cleanup or final operations if required (like saving a file to disk, and so on) The count and the si parameters will be NULL . SDO_SI_FAILURE This value indicates that an error occurred and the SDK is aborting or abandoning this Service Info round. The module must ignore all the information it received thus far (if any) and reset to its pre-Service Info state. The count and si parameters will be NULL. Service Information Key Value Pair \u00b6 This type contains a key name string and associated value string. Both items are pointers to ASCII NULL terminated strings. Syntax typedef struct sdoSdkSiKeyValue { char *key; char *value; } sdoSdkSiKeyValue; Members key NULL terminated string containing the Key Name. value NULL terminated string containing the Value associated with the Key Name. Binary values must be encoded in Base-64 format. Service Information Module Callback \u00b6 This type is a pointer to a callback function that is used to process Owner Service Information messages received from the Owner Server for a specific Service Information module. See Service Information Module Description for how it is used. This callback function is invoked in the context of the executing onboarding protocol hence, although there is no fixed timeline, the module must complete execution in the shortest possible time. Syntax typedef int (*sdoSdkServiceInfoCB)(sdoSdkSiType type, int *count, sdoSdkSiKeyValue *si); Parameters type This indicates the type of the callback as specified in the SDO Service Callback Type section. count An integer pointer that is used for multiple purposes. In the case of SDO_SI_GET_DSI_COUNT , the module must return the number of DSI entries it will send. For SDO_SET_PSI, SDO_SI_GET_DSI and SDO_SI_SET_OSI , it contains an index value into the PSI, DSI, and OSI lists respectively. si A pointer to a service info key-value pair of type sdoSdkSiKeyValue that contains a key and its corresponding value, both of which are NULL terminated strings. Return Value The return value could be one of the following: SDO_SI_CONTENT_ERROR : Indicates that the module could not process the Service Information due to invalid content of either the key or value. An error will cause the onboarding protocol to fail and be retried. SDO_SI_INTERNAL_ERROR : Indicates that the module could not process the Service Information due to an internal error. An error will cause the onboarding protocol to fail and be retried. SDO_SI_SUCCESS : Indicates that the module was able to successfully process the Service Information (or ignored it successfully). Service Information Module Description \u00b6 This structure describes a Service Information module that implements module functionality as described Section 2.3 and Section 2.5. Supported modules are known to the Application ahead of time and each module must have one Service Information Module entry, which is passed to the SDK in the sdoSdkInit() API. Syntax typedef struct { char moduleName[16]; sdoSdkServiceInfoCB serviceInfoCallback; } sdoSdkServiceInfoModule; Members moduleName The symbolic name of the Service Information Module. This should be a NULL terminated string, no larger than 15 characters. serviceInfoCallback This callback function will be invoked by the SDK to obtain Device Service Info from the module as well as pass Pre-Service Info and Owner Service Info to the module. This callback will be executed in the context of the onboarding protocol. See Service Information Module Callback. Error Handling Callback \u00b6 This type is a pointer to a callback function that is used to process errors during protocol execution. The Application can use information provided by this callback to perform application-specific operations. The Application can also control the execution of the protocol state machine by return different values as specified below. Syntax typedef int (*sdoSdkErrorCB)(sdoSdkStatus type, sdoSdkError errorCode); Parameters type This value specifies the type of error that occurred. It will be one of the following values (other sdoSdkStatus values are not used here): SDO_ERROR : This indicates an unrecoverable error occurred. The SDK will continue with protocol restart for these types of errors but it is unlikely that the operation will succeed. It is advisable to abort the operation and retry at a later time. SDO_WARNING : This indicates that a transient error occurred. The SDK will continue with protocol restart, which might fix the problem. It is advisable that the Application allows the restart to take place. errorCode This value indicates details of the error that occurred. See description in SDO SDK Error Values. Return Value The return value could be one of the following constants ( Note: These values are constants that are defined in the SDO SDK header file): SDO_SUCCESS : Indicates that the error was handled and the SDK should continue with its recovery or restart as required. SDO_ABORT : This causes the SDK to terminate protocol processing and return to the caller (such as, the sdoSdkRun() API returns). The Application can re-invoke this API at a later time to re-initiate the SDO onboarding process. SDK API Functions \u00b6 The following functions are provided by the SDK and defined in the SDK API header file. Initialize SDO SDK \u00b6 The Application must invoke this API before any other APIs since this API initializes all internal data and state of the SDK. Syntax sdoSdkStatus sdoSdkInit( sdoSdkErrorCB *errorHandlingCallback, uint32_t numModules, sdoSdkModuleInfo *moduleInformation, ); Parameters errorHandlingCallback* This is the Application\u2019s error handling function and will be called by the SDK when an error is encountered. This value can be NULL in which case, errors will not be reported to the Application, and the SDK will take the appropriate recovery and/or restart action as required. Note: Passing NULL might cause the SDK to remain in an infinite loop until the onboarding process completes successfully. *numModules Number of Service Information modules contained in the following moduleInformation list parameter. If no Application-specific modules are available, this value should be zero. moduleInformation Service Module Information description for each available Service Information module as described in Service Information Module Description. If no Application-specific modules are available, this value should be NULL . Return Value This function returns success or an error code as defined in Generic API Return Status. \u2003 Get Current SDO SDK Status \u00b6 This function returns the current state of the SDO SDK. It may only be called after the SDK has been initialized using the sdoSdkInit() API. Syntax sdoSdkDeviceState sdoSdkGetStatus(void); Return Value This function returns a value of type sdoSdkDeviceStatus as described in SDO Device Status. Execute SDO SDK Onboarding Protocol \u00b6 The Application invokes this API to begin the onboarding process that is, TO1. The onboarding process has completed successfully when this function returns SDO_SUCCESS . If this API returns an error, the Application may retry the onboarding process by calling this API again immediately or after a sleep/reset cycle as determined by the use case. The SDK will invoke the Application error callback if an error occurs in this phase. Additionally, module-specific callbacks will be invoked when Service Information is received from the Owner Server during the course of the TO2 stage. These callbacks are invoked in the context of the callers thread and the callbacks must not call any SDK APIs since the SDK is not yet re-entrant. Syntax sdoSdkStatus sdoSdkRun(void); Return Value This function returns success or an error code as defined in Generic API Return Status. Prepare the SDO SDK for Resale \u00b6 The Application invokes this API to prepare the device for resale. The SDK marks internal state to pre-TO1 and returns. After preparing the SDK for resale, a subsequent call to the sdoSdkRun() API will cause the SDK to perform the TO1 stage again, with new owner credentials that were updated at the end of the previous TO2 protocol stage. Syntax sdoSdkStatus sdoSdkResale(void); Return Value This function returns success or an error code as defined in Generic API Return Status","title":"API Reference"},{"location":"client-sdk/client-sdk-api-reference/#sdo-client-sdk-api-reference","text":"This section describes the APIs provided by the SDO Client SDK as well as public data structures required to support them.","title":"SDO Client SDK API Reference"},{"location":"client-sdk/client-sdk-api-reference/#data-structures","text":"These structures are defined in the SDO Client SDK header file and used by various SDK APIs.","title":"Data Structures"},{"location":"client-sdk/client-sdk-api-reference/#generic-api-return-status","text":"This type is returned by all APIs and indicates whether the API call succeeded or failed. Syntax typedef enum { SDO_SUCCESS = 0, SDO_INVALID_PATH, SDO_CONFIG_NOT_FOUND, SDO_INVALID_STATE, SDO_RESALE_NOT_SUPPORTED, SDO_RESALE_NOT_READY, SDO_WARNING, SDO_ERROR SDO_ABORT } sdoSdkStatus; Members SDO_SUCCESS The API call succeeded. SDO_INVALID_PATH A path or address specified was not found or not accessible. SDO_CONFIG_NOT_FOUND An expected configuration file was not found or not accessible. SDO_INVALID_STATE The SDK is in an invalid state to perform the requested operation. SDO_RESALE_NOT_SUPPORTED This configuration of the SDK does not support the Resale Protocol. SDO_RESALE_NOT_READY The SDK is not in a state to execute the Resale Protocol. This error will occur when the Resale API (sdoSdkResale) is called when device ownership transfer has not yet completed successfully. SDO_WARNING This value is used in the SDK error callback to notify the Application that a transient failure occurred. See Error Handling Callback for details. SDO_ERROR The API call did not succeed. We might extend this later (TBD) to allow returning of specific error types as positive values (for example, memory allocation failure, communications failure, and so on). SDO_ABORT This value is returned by the error callback function to prevent the SDK from continuing the transfer of ownership protocol if an error occurred. Details are provided in Error Handling Callback.","title":"Generic API Return Status"},{"location":"client-sdk/client-sdk-api-reference/#sdo-device-status","text":"This type indicates the current SDO protocol status of the device. Syntax typedef enum { SDO_STATE_PRE_DI = 2, SDO_STATE_PRE_TO1, SDO_STATE_IDLE, SDO_STATE_RESALE, SDO_STATE_ERROR } sdoSdkDeviceStatus; Members SDO_STATE_PRE_DI The SDK is in the pre-Device Initialization state. It is ready to run the DI protocol which can be initiated by calling the sdoSdkRun() API. SDO_STATE_PRE_TO1 The SDK has completed the DI stage and is ready for Device onboarding. The SDK will run the TO1 protocol if the sdoSdkRun() API is called. SDO_STATE_IDLE The SDK has completed ownership transfer and is in the idle state. Calling sdoSdkRun() will have no effect. The Application may only call the sdoSdkResale() API to initiate the Resale protocol at his point. SDO_STATE_RESALE The SDK has is now ready for resale. Calling sdoSdkRun() will run the TO1 & TO2 protocols, to carryout onboarding to the new (post-resale) device owner. SDO_STATE_ERROR This API failed due to an internal error.","title":"SDO Device Status"},{"location":"client-sdk/client-sdk-api-reference/#sdo-sdk-error-values","text":"This type is passed from the SDK to the Application when an error occurs and indicates details of the error. It is used by the error callback \u2013 see Error Handling Callback. Syntax typedef enum { SDO_RV_TIMEOUT = 1, SDO_CONN_TIMEOUT, SDO_DI_ERROR, SDO_TO1_ERROR, SDO_TO2_ERROR } sdoSdkError; Members SDO_RV_TIMEOUT A timeout occurred when trying to contact the Rendezvous Server. SDO_CONN_TIMEOUT A connection to either the Rendezvous or Owner Server timed out. SDO_DI_ERROR A generic error occurred during the DI stage. SDO_TO1_ERROR A generic error occurred during the TO1 protocol stage. SDO_TO2_ERROR A generic error occurred during the TO2 protocol stage.","title":"SDO SDK Error Values"},{"location":"client-sdk/client-sdk-api-reference/#sdo-service-callback-type","text":"This type value indicates the type of function the module callback must perform. These values are used by the Service Information Module Callback function. Syntax typedef enum { SDO_SI_START, SDO_SI_GET_DSI_COUNT, SDO_SI_SET_PSI, SDO_SI_GET_DSI, SDO_SI_SET_OSI, SDO_SI_END, SDO_SI_FAILURE } sdoSdkSiType; Members Below are the parameters of the Service Information Module Callback function described in Service Information Module Callback function. SDO_SI_START This value indicates that the SDK is starting Service Info rounds. The module may perform pre-preparation operations at this time. The count and si parameters will be NULL. SDO_SI_SET_PSI This value indicates that the SDK is returning a pre-service information (PSI) key-value pair that was received from the server to the module. The si.key contains the received key name and is a NULL terminated ASCII string. The si.value parameter contains the PSI value and is assumed to be a NULL terminated string. If no value was received, this value will by NULL . The count will contain the \u2018index\u2019 of the invocation, starting from 0 and incrementing on each subsequent call. If the module needs to retain the contents of the si.key or si.value parameters after the call returns, it must make an internal, local copy. SDO_SI_GET_DSI_COUNT This value indicates that the SDK is requesting the module to return the total number of Device Service Info (DSI) strings it needs to send to the Owner Server. The maximum size of a string is 1,200 bytes. Strings larger than 1,200 bytes need to be split across multiple strings and this count must be factored into the total number of DSI strings for the module. On receiving this call, the module must place the number of DSI strings the module will report into the *count parameter. The si pointer will be NULL . SDO_SI_GET_DSI This value indicates that the SDK is requesting the module to return a particular Device Service Info string. The count parameter contains the index of the DSI value requested. It will progress from zero to the value returned by the response to the SDO_SI_GET_DSI_COUNT callback minus 1. A module must use this value to track where in the DSI list it currently is. The module must set prepare two NULL terminated strings \u2013 one for the DSI key and another for the DSI value. The si.key and si.value pointers must point at these strings before returning from the callback. The memory allocated for si.key and si.value must remain valid (that is, not be freed) until the next time this callback is invoked \u2013 the service info callback sequence will end with SDO_SI_END or SDO_SI_ERROR . SDO_SI_SET_OSI This value indicates that the SDK is providing a valid Owner Service Info (OSI) key-value pair to the module and it must process the provide OSI information. The count parameter is a progressively increasing index value of the provided OSI. The si.key will contain the key value and the si.value will contain the value of the string. Both are valid, NULL terminated strings. The value might be Base 64 encoded binary data. This encoding is module-dependent and should be indicated by the si.key contents. SDO_SI_END This value indicates that the SDK has completed all Service Info rounds and the module can perform cleanup or final operations if required (like saving a file to disk, and so on) The count and the si parameters will be NULL . SDO_SI_FAILURE This value indicates that an error occurred and the SDK is aborting or abandoning this Service Info round. The module must ignore all the information it received thus far (if any) and reset to its pre-Service Info state. The count and si parameters will be NULL.","title":"SDO Service Callback Type"},{"location":"client-sdk/client-sdk-api-reference/#service-information-key-value-pair","text":"This type contains a key name string and associated value string. Both items are pointers to ASCII NULL terminated strings. Syntax typedef struct sdoSdkSiKeyValue { char *key; char *value; } sdoSdkSiKeyValue; Members key NULL terminated string containing the Key Name. value NULL terminated string containing the Value associated with the Key Name. Binary values must be encoded in Base-64 format.","title":"Service Information Key Value Pair"},{"location":"client-sdk/client-sdk-api-reference/#service-information-module-callback","text":"This type is a pointer to a callback function that is used to process Owner Service Information messages received from the Owner Server for a specific Service Information module. See Service Information Module Description for how it is used. This callback function is invoked in the context of the executing onboarding protocol hence, although there is no fixed timeline, the module must complete execution in the shortest possible time. Syntax typedef int (*sdoSdkServiceInfoCB)(sdoSdkSiType type, int *count, sdoSdkSiKeyValue *si); Parameters type This indicates the type of the callback as specified in the SDO Service Callback Type section. count An integer pointer that is used for multiple purposes. In the case of SDO_SI_GET_DSI_COUNT , the module must return the number of DSI entries it will send. For SDO_SET_PSI, SDO_SI_GET_DSI and SDO_SI_SET_OSI , it contains an index value into the PSI, DSI, and OSI lists respectively. si A pointer to a service info key-value pair of type sdoSdkSiKeyValue that contains a key and its corresponding value, both of which are NULL terminated strings. Return Value The return value could be one of the following: SDO_SI_CONTENT_ERROR : Indicates that the module could not process the Service Information due to invalid content of either the key or value. An error will cause the onboarding protocol to fail and be retried. SDO_SI_INTERNAL_ERROR : Indicates that the module could not process the Service Information due to an internal error. An error will cause the onboarding protocol to fail and be retried. SDO_SI_SUCCESS : Indicates that the module was able to successfully process the Service Information (or ignored it successfully).","title":"Service Information Module Callback"},{"location":"client-sdk/client-sdk-api-reference/#service-information-module-description","text":"This structure describes a Service Information module that implements module functionality as described Section 2.3 and Section 2.5. Supported modules are known to the Application ahead of time and each module must have one Service Information Module entry, which is passed to the SDK in the sdoSdkInit() API. Syntax typedef struct { char moduleName[16]; sdoSdkServiceInfoCB serviceInfoCallback; } sdoSdkServiceInfoModule; Members moduleName The symbolic name of the Service Information Module. This should be a NULL terminated string, no larger than 15 characters. serviceInfoCallback This callback function will be invoked by the SDK to obtain Device Service Info from the module as well as pass Pre-Service Info and Owner Service Info to the module. This callback will be executed in the context of the onboarding protocol. See Service Information Module Callback.","title":"Service Information Module Description"},{"location":"client-sdk/client-sdk-api-reference/#error-handling-callback","text":"This type is a pointer to a callback function that is used to process errors during protocol execution. The Application can use information provided by this callback to perform application-specific operations. The Application can also control the execution of the protocol state machine by return different values as specified below. Syntax typedef int (*sdoSdkErrorCB)(sdoSdkStatus type, sdoSdkError errorCode); Parameters type This value specifies the type of error that occurred. It will be one of the following values (other sdoSdkStatus values are not used here): SDO_ERROR : This indicates an unrecoverable error occurred. The SDK will continue with protocol restart for these types of errors but it is unlikely that the operation will succeed. It is advisable to abort the operation and retry at a later time. SDO_WARNING : This indicates that a transient error occurred. The SDK will continue with protocol restart, which might fix the problem. It is advisable that the Application allows the restart to take place. errorCode This value indicates details of the error that occurred. See description in SDO SDK Error Values. Return Value The return value could be one of the following constants ( Note: These values are constants that are defined in the SDO SDK header file): SDO_SUCCESS : Indicates that the error was handled and the SDK should continue with its recovery or restart as required. SDO_ABORT : This causes the SDK to terminate protocol processing and return to the caller (such as, the sdoSdkRun() API returns). The Application can re-invoke this API at a later time to re-initiate the SDO onboarding process.","title":"Error Handling Callback"},{"location":"client-sdk/client-sdk-api-reference/#sdk-api-functions","text":"The following functions are provided by the SDK and defined in the SDK API header file.","title":"SDK API Functions"},{"location":"client-sdk/client-sdk-api-reference/#initialize-sdo-sdk","text":"The Application must invoke this API before any other APIs since this API initializes all internal data and state of the SDK. Syntax sdoSdkStatus sdoSdkInit( sdoSdkErrorCB *errorHandlingCallback, uint32_t numModules, sdoSdkModuleInfo *moduleInformation, ); Parameters errorHandlingCallback* This is the Application\u2019s error handling function and will be called by the SDK when an error is encountered. This value can be NULL in which case, errors will not be reported to the Application, and the SDK will take the appropriate recovery and/or restart action as required. Note: Passing NULL might cause the SDK to remain in an infinite loop until the onboarding process completes successfully. *numModules Number of Service Information modules contained in the following moduleInformation list parameter. If no Application-specific modules are available, this value should be zero. moduleInformation Service Module Information description for each available Service Information module as described in Service Information Module Description. If no Application-specific modules are available, this value should be NULL . Return Value This function returns success or an error code as defined in Generic API Return Status.","title":"Initialize SDO SDK"},{"location":"client-sdk/client-sdk-api-reference/#get-current-sdo-sdk-status","text":"This function returns the current state of the SDO SDK. It may only be called after the SDK has been initialized using the sdoSdkInit() API. Syntax sdoSdkDeviceState sdoSdkGetStatus(void); Return Value This function returns a value of type sdoSdkDeviceStatus as described in SDO Device Status.","title":"Get Current SDO SDK Status"},{"location":"client-sdk/client-sdk-api-reference/#execute-sdo-sdk-onboarding-protocol","text":"The Application invokes this API to begin the onboarding process that is, TO1. The onboarding process has completed successfully when this function returns SDO_SUCCESS . If this API returns an error, the Application may retry the onboarding process by calling this API again immediately or after a sleep/reset cycle as determined by the use case. The SDK will invoke the Application error callback if an error occurs in this phase. Additionally, module-specific callbacks will be invoked when Service Information is received from the Owner Server during the course of the TO2 stage. These callbacks are invoked in the context of the callers thread and the callbacks must not call any SDK APIs since the SDK is not yet re-entrant. Syntax sdoSdkStatus sdoSdkRun(void); Return Value This function returns success or an error code as defined in Generic API Return Status.","title":"Execute SDO SDK Onboarding Protocol"},{"location":"client-sdk/client-sdk-api-reference/#prepare-the-sdo-sdk-for-resale","text":"The Application invokes this API to prepare the device for resale. The SDK marks internal state to pre-TO1 and returns. After preparing the SDK for resale, a subsequent call to the sdoSdkRun() API will cause the SDK to perform the TO1 stage again, with new owner credentials that were updated at the end of the previous TO2 protocol stage. Syntax sdoSdkStatus sdoSdkResale(void); Return Value This function returns success or an error code as defined in Generic API Return Status","title":"Prepare the SDO SDK for Resale"},{"location":"client-sdk/client-sdk-reference-guide/","text":"Introduction \u00b6 The Secure Device Onboard Client SDK is a portable implementation of the Secure Device Onboard (SDO) protocol state machines, cryptographic operations, and associated components. While the Client SDK was developed and tested on the Linux* OS, the core components of the SDK are isolated from OS-specific components via an abstraction layer. Well-known open-source implementations of cryptographic libraries are used for cryptographic operations. In addition, the Client SDK is ported to the following Arm* platforms: Nucleo development board (NUCLEO-F429ZI) running STM32F429ZI ARM Cortex -M4 MCU over Mbed* OS. NUCLEO-F767ZI development board running STM32F767ZI Arm Cortex -M7 MCU over Mbed* OS. WaRP7 development board running i.MX 7 series Arm Cortex-A7 MPU over Mbed Linux. Raspberry Pi* development board running Arm Cortex-A53 MPU over Raspbian OS. The Client SDK is a reference implementation that can be used to onboard a device and then give control to the device application or IOT Platform Service. \u201cOnboarding\u201d means the process by which a device establishes its first trusted connection with an IOT Platform Service. Linux provides an easy-to-use development environment for SDK development, debug, and validation. When the SDK is ported to a particular environment, the abstraction layer will be ported to the target environment and real-time operating system (RTOS) (or bare metal). If the target environment supports hardware-accelerated cryptography, the cryptography interfaces will also be ported. If the target environment does not support cryptographic acceleration, the software cryptography libraries used by the SDK will need to be ported. The core SDK can be recompiled in the target environment with no change. Note The hardware abstraction layer (HAL) implementation provided in this release is for reference only and not intended for production. It does not provide the level of security required by industry standards for a fully secure production environment. Terminology \u00b6 Refer to the Secure Device Onboard Reference page . Reference Documents \u00b6 Refer to the Secure Device Onboard Reference page . Client SDK Overview \u00b6 Like any SDK, the Client SDK is expected to be embedded within a custom implementation that provides overall device functionality while using the SDK to perform SDO-based device onboarding. The SDK will be statically linked to an application that invokes SDK APIs to trigger onboarding functionality. This implementation is referred to as the \u2018Application\u2019 in this document. Figure 1. SDO Client Block Diagram Note EPID is an acronym for Enhanced Privacy ID. SDO is an acronym for Secure Device Onboard. Before initiating the Secure Device Onboard functionality, the Application must first initialize the SDK. After initializing the SDK, the Application can initiate the onboarding by calling the sdo_sdk_run() API. The SDK maintains persistent data such as configuration and state information that are used to track the onboarding state and store credentials, among others. This information is stored in the SDK Configuration file that persists across reboots. Threading Model \u00b6 The SDO Client SDK is single threaded and the APIs are non-reentrant and blocking. SDK code executes in the context of the calling application thread and will make OS calls via the abstraction layer for storage and networking services within the context of this thread. OS service such as storage and network are assumed to be blocking. During the execution of the onboarding protocol, the SDK receives data from the Owner Server that must be passed back to application modules (Pre-Service & Owner Service Information).This is achieved via module-specific callback functions that are registered during the SDK initialization. These callback functions are also called within the context of the application thread that entered the SDK via one of the SDK\u2019s APIs ( sdo_sdk_run ). The application must not invoke an SDK API from within the callback \u2013 SDK flows have been designed such that this is not required. In addition to module specific callbacks, the SDK requires an additional callback that is used to inform the Application of events occurring during long-running activities, such as network connection retries, as well as errors, such as network connection drop. Networking \u00b6 It is assumed that the machine on which the SDK runs has access to the network. The SDK uses standard POSIX sockets interface to connect to external back-end Rendezvous and Owner Servers. The SDK uses the OpenSSL* toolkit for SSL support. The SDK will initiate connections to the following external ports, which must not be blocked by a firewall: 8039: The SDK connects to the SDO Manufacturer Server on this port. 8041: The SDK connects to the SDO Rendezvous Server on this port. 8042: The SDK connects to the SDO Owner Server on this port. For details on the Manufacturer Server, Rendezvous Server, and Owner Server refer to the Reference Documents. Device-Specific Modules \u00b6 SDO is a generic mechanism of establishing trust between a device and the final owner\u2019s cloud-based IOT Platform Service (known as the Owner Service). Once this trust is established, the Owner Service must perform the following actions: Setup the device for final operation. This requires configuration of device specific operational parameters. This is determined by the device being onboarded, for example, it is device specific. Full integration into the organization\u2019s IOT Platform Service. This is specific to the IOT Platform Service being used. Since SDO cannot define these steps for all devices and IOT Platforms, it provides a flexible method to allow these operations to be carried out in a secure manner using Modules. Modules are defined by the device manufacturer (ODM) and are pieces of code that have a specific name and perform a specific function. Firmware update, key provisioning, and Wi-Fi* network setup are some examples of common functionality that could be provided by modules. A module must be able to report information [called the Device Service Information (DSI) ], to IOT Platform, and accept configuration information [called the Owner Service Information (OSI) ], from the Owner Service. A module must also be able to publish details of what information it will report as DSI and what information it will accept as OSI. This is done in the form of key-value pairs. The key identifies a parameter and the value provides the value of the parameter. A module will publish its interface in the form of DSI keys with associated valid values and OSI keys with associated valid values. The Owner Service is expected to be aware of all devices it will onboard and associated DSI and OSI interfaces. Note The expectation is that over time, much like reusable libraries, modules providing specific functionality such as firmware updates or key provisioning will become standardized in terms of their capabilities and interfaces. Device manufactures will simply port the modules and include these libraries to their device implementation. A similar development is expected to occur on the Owner Server side where standard libraries will be developed to interact with the device module and included in the Owner Server implementation. When a device is onboarded, a secure channel is established between the device and Owner Server after the device has authenticated the Owner Server and vice-versa (during the TO2 protocol). At this point, the Owner Server can query information from the device (DSI) and send down configuration information to the device (OSI). The secure channel uses encryption and integrity protection to secure DSI/OSI data in transit from/to the device. In addition to DSI and OSI, SDO defines Pre-Service Info or PSI , a mechanism that the Owner Server can use to inform the device of its expectations in terms of module support. This precedes DSI and OSI and contains a list of expected modules along with basic capabilities expected of the module. The following section details the interactions between the Application, Client SDK and Device-specific Modules. Integrated Operational Flows \u00b6 This SDK release requires all software components to be linked together into a single binary image and execute at the same privilege level. While some systems might include overlays and Trusted Execution Environments, these are not considered for this version. Figure 2. Integrated Image and Execution Flow The integrated image and execution flows from system boot are shown above and each step is described below: On reset, the Board Support Package (BSP) and RTOS initialize the hardware and pass the control to the Application. On Linux* systems, this is the normal OS boot flow and is complete by the time the Application executes. The Application initializes all SDO modules if required. The Application also initializes the SDK by calling the sdo_sdk_init() API and registers each module with the SDK by passing the module\u2019s name and callback address to the SDK (in the sdo_sdk_service_info_module structure). The Application checks if SDO onboarding has been completed by calling the sdo_sdk_get_status() API. If the status SDO_SDK_STATE_IDLE is returned, onboarding has been completed and the Application goes to step 6. If not, the Application goes to step 4. The Application initiates SDO onboarding by calling the sdo_sdk_run() API. This call returns either a successful completion of onboarding or an error. If an error occurs, the Application will reset the device and retry the sequence, with some delay. On successful completion of onboarding, the Application goes to step 6. During the onboarding process, the SDK will call registered modules during the Service Info stage of the protocol. This is done by calling the registered module callback. Details of this interaction are provided in the Figure 3. The onboarding process will succeed only if all module interactions at this stage are successful. The Application has successfully completed onboarding and continues normal operation of the device. The Application continues operating until the system is powered off or reset. On System restart, the preceding steps are re-executed. SDO Module Flows \u00b6 As mentioned in Device Specific Modules section , three types of information exchange occur between each module and the Owner Service: Pre-Service Info (PSI) Device Service Info (DSI) Owner Service Info (OSI) Each of these is described as follows: Figure 3. Service Info Exchanges between Device and Owner Server As shown in the diagram, PSI is \u2018global\u2019 to all modules and occurs once between the device and Owner Server. DSI and OSI are module specific. Module Initialization \u00b6 For each registered module, the SDK initializes the module by call its callback with the SDO_SI_START type. The module is expected to prepare to receive PSI, DSI, and OSI calls after initialization. If an error occurs after a module has been initialized, during the remainder of TO2 protocol execution and the Application is restarted, the SDK will again call this API to initialize each registered module. The module must be prepared for multiple such calls due to the SDK\u2019s retry-based approach to error recovery. Pre-Service Info (PSI) \u00b6 The intent of PSI is described in the SDO Protocol specification. Basically, PSI provides the Owner Server with a way to inform a module what to expect during the next two service info sequences (such as, DSI and OSI). The module should use this information to prepare itself for the subsequent exchanges. PSI is an ASCII string containing one or more 2-tuple of the format [module-name][module-data] . The SDK parses the PSI string and locates the module specified by module-name. If this module is not found, the SDK ignores it and continues with the next PSI touple in the string. The [module-data] is a key-value pair where the value is optional (depending on the key) and is encoded as key~value (the \u2018~\u2019 char is the delimiter). The SDK will parse this substring to extract the key and value. If the module is found, the SDK invokes the modules callback function with type SDO_SI_SET_PSI and passes the module-data to it in the sv parameter. The key is contained in sv.key and the value if present, is in sv.value . If no value is present, the sv.value will be NULL . The module is expected to process the key-value and return either success or failure. A failure response will cause the entire onboarding sequence to fail and the Application must retry it at a later time. In most cases the Owner Server will use PSI to allow the module to perform basic initialization and setup for the following DSI and OSI rounds in terms of allocating resources, and others. From a format standpoint, both key and value are NULL terminated ASCII strings. The value may optionally contain base64 encoded binary data. A PSI string could contain multiple 2-touples with the same module-name. In this case, the SDK will invoke the same module multiple times, once for each occurrence of module-name in the PSI string. The corresponding key-value pairs will be passed in each of these invocations. The count parameter will act as an \u2018index\u2019 starting at 0 for the first invocation and incremented for subsequent invocations. Note The PSI is considered the module configuration data and is independent of the DSI (see next section), which is the device information. The number of PSI elements is hence decoupled from the number of DSI elements. If the module wishes to retain either the key of value parameters for later use, it must make a local copy of the contents. The pointers passed during the invocation will be invalid after the callback returns to the SDK. Note PSI is one-way, from the Owner Server to the device. Apart from reporting success or failure, the device has no way of communicating any other information back to the Owner Server during this exchange. Device Service Info (DSI) \u00b6 DSI follows PSI. The module needs to determine in advance how many DSI key-value pairs it needs to send to the Owner Service. In some cases, this is determined statically while in others, the module uses information obtained from the Owner Server in PSI to determine how many DSI key-values it needs to upload. On completing the PSI round, the SDK queries each registered module for the number of DSI rounds it requires. This is done by invoking the modules callback with the SDO_SI_GET_DSI_COUNT type. The module is expected to return the number of DSI key-value pairs it requires in the count callback parameter. When the DSI round for a module begins, the SDK will call the modules callback with the SDO_SI_GET_DSI type. The count parameter will indicate the \u2018index\u2019 of the DSI key-value pair being requested by the SDK. The SDK uploads each key-value pair to the Owner Server in the same order. The module may choose to ignore the \u2018index\u2019 sent by the SDK but it is advisable for the module to return key-value data based on this index. This callback will be invoked as many times as specified by the module by the prior SDO_SI_GET_DSI_COUNT return value (the \u2018index\u2019 value will vary from 0 to count-1 ). Key-values are returned in the sv.key and sv.value parameter fields. The sv.key must strictly be an NULL terminated ASCII string. The sv.value is also a NULL terminated ASCII string but could also be a Base64 encoded binary value. It is assumed that the Owner Server knows how to interpret a particular key-value from a particular module. The module must include Base64 encoding capabilities if required. The very first key-value returned by a module (\u2018index\u2019 zero) must be an activation value indicating whether the module is active or not. The key value must be \u201cactive\u201d and the value must be \u201c1\u201d if the module is active or \u201c0\u201d if the module is not active. If the module is not active, the Owner Server will not send and DSI messages to the module. This requires each module to have at least one DSI \u2013 that is, the count value returned for the SDO_SI_GET_DSI_COUNT callback type must be at least 1. See the SDO Protocol Specification for more information on module activation and deactivation. Note that DSI is one way \u2013 from device to Owner Server. The Owner Server cannot respond to any DSI message during this phase. It can however respond to a prior DSI message in the next, OSI phase. Owner Service Info (OSI) \u00b6 OSI follows DSI. Unlike DSI, neither the SDK nor the module can determine in advance how many OSI key-values they are going to receive. On receiving an OSI, the SDK locates the module and invokes its callback with the SDO_SI_SET_OSI type. Received key-values are passed to the module in the sv.key and sv.value callback parameter fields. The sv.key must strictly be an NULL terminated ASCII string. The sv.value is also a NULL terminated ASCII string but could also be a Base64 encoded binary value. It is assumed that the module knows how to interpret the value for a particular key based on the key name. In addition to the sv parameter, the SDK will pass an \u2018index\u2019 of the OSI in the count parameter. The \u2018index\u2019 begins at 0 and increments for each OSI key-value pair received for the module. Corresponding to the activation message in DSI, the Owner Server could send a deactivation message to a module if it is not planning to use the module. The message will have a key of \u201cactive\u201d and value of \u201c0\u201d . On receiving this message, a module may free allocated resources and effectively shutdown from an SDO perspective. Unlike the activation message, this message is optional and will only be sent if the Owner Server is not going to use the module. A module must expect to remain active unless it explicitly receives a deactivation message or it already indicated that is not active in the earlier DSI stage. See the SDO Protocol Specification for more information on module activation and deactivation. If a module receives an OSI when it is in the deactivated state, it should return a status of SDO SI_CONTENT_ERROR indicating that the received element was not expected. The module is expected to process the key-value pair and return a result indicating if the operation was successful or failed. The module may return SDO_SI_CONTENT_ERROR or SDO_SI_INTERNAL_ERROR to differentiate between invalid value contents or a module run-time error. This information is reported to the Owner Server. The module must return SDO_SI_SUCCESS on successful completion. Note that OSI is one way \u2013 from Owner Server to the device. Apart from indicating failure, the device cannot respond to an OSI message. Module Completion \u00b6 When all service information rounds of all modules have completed successfully, the SDK calls each module\u2019s callback with the SDO_SI_END type. All other callback parameters are NULL . Modules can commit configuration information at this point if not already done so. The SDK will not call into the module after this. The SDK will ignore the return value of this callback since no further failure is expected at this point. Module Errors \u00b6 If an error occurs during the service information phase, the TO2 protocol is considered to have failed and will be aborted. The Application will need to retry onboarding at a later time. A failure could occur for multiple reasons including failure of device/server interaction, failure of signature or hash verification, malformed messages and also if a module returns a failure while processing a PSI, DSI, or OSI command/request. On failure, all modules must clean up internal state and discard any configuration information they might have got from the Owner Server. Conversely, the Owner Server will also discard all data it might have received from modules. When all service information rounds of all modules have completed successfully, the SDK calls each module\u2019s callback with the SDO_SI_FAILURE type. All other callback parameters are NULL . Modules must discard all information received via PSI or OSI commands until this point. If operations have been performed, or data already committed, they should be undone to return the system to a pre-service information state. The SDK will not call into the module after this. The SDK will ignore the return value of this callback since no further failure is expected at this point. Run the Client SDK \u00b6 The Client SDK includes a binary package, intended to get you started quickly and a source package. For details on downloading the packages, refer to the Get Started Guide. Prerequisites \u00b6 The requirements for the computer that you will run Client SDK on are as follows: Table 1. Prerequisites Software \u00b7 Linux* Ubuntu* 16.04 / Ubuntu* 18.04 using OpenSSL* 1.1.1f \u00b7 JDK11 \u00b7 SDO release binaries package (for running test servers) o The root directory of extracted binary package is referred to as in subsequent sections. \u00b7 SDO Client SDK alpha-release binary package o The root directory of extracted binary package is referred to as < SDOClientSDK> in subsequent sections. \u00b7 SDO Client SDK alpha-release sources package o The root directory of extracted source code is referred to as < SDOClientSDK> in subsequent sections. \u00b7 Apache Maven* (for building sample Java* based test owner service) Additional Ubuntu* 16.04/18.04 prerequisites can be found in the /SDOClientSDK/README.md Enhanced Privacy ID (EPID) EPID SDK v6.0.1 \u00b7 Download EPID SDK v6.0.1: https://github.com/Intel-EPID-SDK/epid-sdk/releases \u00b7 Extract the tar.gz and open doc/index.html in a browser \u00b7 Follow the instructions in the \u201cBuilding from Source\u201d topic \u00b7 Recommend using scons for build Safestring library Safestring library v1.0.0 \u00b7 Download safestringlib from https://github.com/intel/safestringlib \u00b7 cd safestringlib \u00b7 mkdir obj \u00b7 make \u00b7 The library file libsafestring.a will be created after make. Java* Set the $JAVA_HOME environment variable. Run the Binary Package \u00b6 The following subsections provide the steps to run the binary package. Get the Device Private Key (EPID or ECDSA P-256 based) \u00b6 The SDK requires a device Private Key as input for device attestation process (to prove itself to Rendezvous or Owner Server during TO1 or TO2 protocol). The key could be based on EPID or ECDSA (on curve P-256/P-384) based on the device attestation method being used on the field. This key must be stored in a specific file and is read by the SDK on startup. For EPID based device-attestation method: In case of EPID, place the EPID private Key with the name epidprivkey.dat in the following location: data/epidprivkey.dat For ECDSA (P-256) based device-attestation method: In case of ECDSA, place the ECDSA P-256 private Key with the name ecdsa256privkey.dat in the following location: data/ecdsa256privkey.dat For ECDSA (P-384) based device-attestation method: For ECDSA384, place the ECDSA P-384 private Key with the name ecdsa384privkey.dat in the following location: data/ecdsa384privkey.data Follow All-in-one Demo README to start the SDO Manufacturer, Rendezvous, and Owner Service: PRI Owner Service and PRI Rendezvous Service. To run SDO ARM Cortex-M4 or Cortex-A7 based devices, follow the detailed steps (including flashing and device preparation) mentioned in the [README](https://github.com/secure-device-onboard/client-sdk/blob/master/README.md) document. Terminal #1: Start All-in-one Demo Device Initialization \u00b6 This section describes about running the SDO reference device (based on Linux* reference implementation) only. Going forward, refers to the location where the SDO Client application 'linux-client' and the related 'data' folder are placed. Note Running the device the first time completes DI. Running the device the second time on boards the device. Between subsequent device runs, it is assumed that ownership proxy is correctly extended and TO0 is successfully completed. Terminal 2: Run the device for device initialization: $ cd <sdo-client-sdk-bindir> $ ./linux-client` $ ./linux-client --------DI successful-------- This step completes Device Initialization. Device Onboarding \u00b6 Run the device again to onboard the device: $ cd <sdo-client-sdk-bindir> $ ./linux-client` $ ./linux-client --------TO2 successful-------- @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @Secure Device Onboarding Complete@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ This step successfully onboards the device. Note To run SDO ARM Cortex-M4 or Cortex-A7 based devices, follow the detailed steps (including flashing and device preparation) mentioned in the README document. Build the Source \u00b6 Follow these steps to build the source package: Make sure you have completed the pre-requisites. Download source code from Github repository . Follow the instructions provided in the README to build the source code by setting the necessary environment variables. The SDO Client binary is generated either in build/linux/debug or build/linux/release folder, depending on the build mode. Ensure to copy them to the root folder before proceeding with the next steps. Run the PRI Servers Complete Device Initialization Complete Device Onboarding Custom Pluggable Modules \u00b6 As part of the onboard protocol, the Client SDK supports custom pluggable modules. OEMs can develop their desired functionality by following the module protocol. This module functionality will be called during the onboard protocol. A sample device module, sdo_sys has been developed and is available for reference. sdo_sys device module is intended to collect the data (typically files and scripts) sent from the SDO Owner to the SDO device, process, and execute the data in some meaningful way. To use sdo_sys device module, follow these steps: To use the sample device module sdo_sys : Build Client SDK either in release or debug mode using MODULES=true flag. $ cd client-sdk/ $ make pristine $ make MODULES=true The binary would be created either in build/linux/debug or build/linux/release folder. Copy them to the root folder before proceeding with the next steps. Run the SDO Linux* device for Device Initialization (DI) protocol: $ ./linux-client --------DI successful-------- Run the SDO Linux* device for Transfer of Ownership (TO1/TO2) protocol (it is assumed that ownership voucher is correctly extended and TO0 is successfully completed prior to this step): $ ./linux-client --------TO2 successful-------- @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @Secure Device Onboarding Complete@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Known Issues and Limitations \u00b6 The following are the known issues: \u2022 The HAL implementation provided in this release is for reference only and not intended for production. It does not provide the level of security required by industry standards for a fully secure production environment. \u2022 \u2018sdo_sys\u2019 module source within 'device_modules' folder is an example code demonstrating SDO device module implementation for reference purpose only. This code is not written following secure production level coding and checks. This sample code must not to be used as it is. The following are the known limitations: \u2022 EPID based device-attestation (DA) method is not supported with STM32F429ZI MCU due to memory constraints in the underlying development board NUCLEO-F429ZI. \u2022 Network discovery and CSR feature is not supported for ARM Cortex M4, M7, and A7 devices.","title":"Introduction"},{"location":"client-sdk/client-sdk-reference-guide/#introduction","text":"The Secure Device Onboard Client SDK is a portable implementation of the Secure Device Onboard (SDO) protocol state machines, cryptographic operations, and associated components. While the Client SDK was developed and tested on the Linux* OS, the core components of the SDK are isolated from OS-specific components via an abstraction layer. Well-known open-source implementations of cryptographic libraries are used for cryptographic operations. In addition, the Client SDK is ported to the following Arm* platforms: Nucleo development board (NUCLEO-F429ZI) running STM32F429ZI ARM Cortex -M4 MCU over Mbed* OS. NUCLEO-F767ZI development board running STM32F767ZI Arm Cortex -M7 MCU over Mbed* OS. WaRP7 development board running i.MX 7 series Arm Cortex-A7 MPU over Mbed Linux. Raspberry Pi* development board running Arm Cortex-A53 MPU over Raspbian OS. The Client SDK is a reference implementation that can be used to onboard a device and then give control to the device application or IOT Platform Service. \u201cOnboarding\u201d means the process by which a device establishes its first trusted connection with an IOT Platform Service. Linux provides an easy-to-use development environment for SDK development, debug, and validation. When the SDK is ported to a particular environment, the abstraction layer will be ported to the target environment and real-time operating system (RTOS) (or bare metal). If the target environment supports hardware-accelerated cryptography, the cryptography interfaces will also be ported. If the target environment does not support cryptographic acceleration, the software cryptography libraries used by the SDK will need to be ported. The core SDK can be recompiled in the target environment with no change. Note The hardware abstraction layer (HAL) implementation provided in this release is for reference only and not intended for production. It does not provide the level of security required by industry standards for a fully secure production environment.","title":"Introduction"},{"location":"client-sdk/client-sdk-reference-guide/#terminology","text":"Refer to the Secure Device Onboard Reference page .","title":"Terminology"},{"location":"client-sdk/client-sdk-reference-guide/#reference-documents","text":"Refer to the Secure Device Onboard Reference page .","title":"Reference Documents"},{"location":"client-sdk/client-sdk-reference-guide/#client-sdk-overview","text":"Like any SDK, the Client SDK is expected to be embedded within a custom implementation that provides overall device functionality while using the SDK to perform SDO-based device onboarding. The SDK will be statically linked to an application that invokes SDK APIs to trigger onboarding functionality. This implementation is referred to as the \u2018Application\u2019 in this document. Figure 1. SDO Client Block Diagram Note EPID is an acronym for Enhanced Privacy ID. SDO is an acronym for Secure Device Onboard. Before initiating the Secure Device Onboard functionality, the Application must first initialize the SDK. After initializing the SDK, the Application can initiate the onboarding by calling the sdo_sdk_run() API. The SDK maintains persistent data such as configuration and state information that are used to track the onboarding state and store credentials, among others. This information is stored in the SDK Configuration file that persists across reboots.","title":"Client SDK Overview"},{"location":"client-sdk/client-sdk-reference-guide/#threading-model","text":"The SDO Client SDK is single threaded and the APIs are non-reentrant and blocking. SDK code executes in the context of the calling application thread and will make OS calls via the abstraction layer for storage and networking services within the context of this thread. OS service such as storage and network are assumed to be blocking. During the execution of the onboarding protocol, the SDK receives data from the Owner Server that must be passed back to application modules (Pre-Service & Owner Service Information).This is achieved via module-specific callback functions that are registered during the SDK initialization. These callback functions are also called within the context of the application thread that entered the SDK via one of the SDK\u2019s APIs ( sdo_sdk_run ). The application must not invoke an SDK API from within the callback \u2013 SDK flows have been designed such that this is not required. In addition to module specific callbacks, the SDK requires an additional callback that is used to inform the Application of events occurring during long-running activities, such as network connection retries, as well as errors, such as network connection drop.","title":"Threading Model"},{"location":"client-sdk/client-sdk-reference-guide/#networking","text":"It is assumed that the machine on which the SDK runs has access to the network. The SDK uses standard POSIX sockets interface to connect to external back-end Rendezvous and Owner Servers. The SDK uses the OpenSSL* toolkit for SSL support. The SDK will initiate connections to the following external ports, which must not be blocked by a firewall: 8039: The SDK connects to the SDO Manufacturer Server on this port. 8041: The SDK connects to the SDO Rendezvous Server on this port. 8042: The SDK connects to the SDO Owner Server on this port. For details on the Manufacturer Server, Rendezvous Server, and Owner Server refer to the Reference Documents.","title":"Networking"},{"location":"client-sdk/client-sdk-reference-guide/#device-specific-modules","text":"SDO is a generic mechanism of establishing trust between a device and the final owner\u2019s cloud-based IOT Platform Service (known as the Owner Service). Once this trust is established, the Owner Service must perform the following actions: Setup the device for final operation. This requires configuration of device specific operational parameters. This is determined by the device being onboarded, for example, it is device specific. Full integration into the organization\u2019s IOT Platform Service. This is specific to the IOT Platform Service being used. Since SDO cannot define these steps for all devices and IOT Platforms, it provides a flexible method to allow these operations to be carried out in a secure manner using Modules. Modules are defined by the device manufacturer (ODM) and are pieces of code that have a specific name and perform a specific function. Firmware update, key provisioning, and Wi-Fi* network setup are some examples of common functionality that could be provided by modules. A module must be able to report information [called the Device Service Information (DSI) ], to IOT Platform, and accept configuration information [called the Owner Service Information (OSI) ], from the Owner Service. A module must also be able to publish details of what information it will report as DSI and what information it will accept as OSI. This is done in the form of key-value pairs. The key identifies a parameter and the value provides the value of the parameter. A module will publish its interface in the form of DSI keys with associated valid values and OSI keys with associated valid values. The Owner Service is expected to be aware of all devices it will onboard and associated DSI and OSI interfaces. Note The expectation is that over time, much like reusable libraries, modules providing specific functionality such as firmware updates or key provisioning will become standardized in terms of their capabilities and interfaces. Device manufactures will simply port the modules and include these libraries to their device implementation. A similar development is expected to occur on the Owner Server side where standard libraries will be developed to interact with the device module and included in the Owner Server implementation. When a device is onboarded, a secure channel is established between the device and Owner Server after the device has authenticated the Owner Server and vice-versa (during the TO2 protocol). At this point, the Owner Server can query information from the device (DSI) and send down configuration information to the device (OSI). The secure channel uses encryption and integrity protection to secure DSI/OSI data in transit from/to the device. In addition to DSI and OSI, SDO defines Pre-Service Info or PSI , a mechanism that the Owner Server can use to inform the device of its expectations in terms of module support. This precedes DSI and OSI and contains a list of expected modules along with basic capabilities expected of the module. The following section details the interactions between the Application, Client SDK and Device-specific Modules.","title":"Device-Specific Modules"},{"location":"client-sdk/client-sdk-reference-guide/#integrated-operational-flows","text":"This SDK release requires all software components to be linked together into a single binary image and execute at the same privilege level. While some systems might include overlays and Trusted Execution Environments, these are not considered for this version. Figure 2. Integrated Image and Execution Flow The integrated image and execution flows from system boot are shown above and each step is described below: On reset, the Board Support Package (BSP) and RTOS initialize the hardware and pass the control to the Application. On Linux* systems, this is the normal OS boot flow and is complete by the time the Application executes. The Application initializes all SDO modules if required. The Application also initializes the SDK by calling the sdo_sdk_init() API and registers each module with the SDK by passing the module\u2019s name and callback address to the SDK (in the sdo_sdk_service_info_module structure). The Application checks if SDO onboarding has been completed by calling the sdo_sdk_get_status() API. If the status SDO_SDK_STATE_IDLE is returned, onboarding has been completed and the Application goes to step 6. If not, the Application goes to step 4. The Application initiates SDO onboarding by calling the sdo_sdk_run() API. This call returns either a successful completion of onboarding or an error. If an error occurs, the Application will reset the device and retry the sequence, with some delay. On successful completion of onboarding, the Application goes to step 6. During the onboarding process, the SDK will call registered modules during the Service Info stage of the protocol. This is done by calling the registered module callback. Details of this interaction are provided in the Figure 3. The onboarding process will succeed only if all module interactions at this stage are successful. The Application has successfully completed onboarding and continues normal operation of the device. The Application continues operating until the system is powered off or reset. On System restart, the preceding steps are re-executed.","title":"Integrated Operational Flows"},{"location":"client-sdk/client-sdk-reference-guide/#sdo-module-flows","text":"As mentioned in Device Specific Modules section , three types of information exchange occur between each module and the Owner Service: Pre-Service Info (PSI) Device Service Info (DSI) Owner Service Info (OSI) Each of these is described as follows: Figure 3. Service Info Exchanges between Device and Owner Server As shown in the diagram, PSI is \u2018global\u2019 to all modules and occurs once between the device and Owner Server. DSI and OSI are module specific.","title":"SDO Module Flows"},{"location":"client-sdk/client-sdk-reference-guide/#module-initialization","text":"For each registered module, the SDK initializes the module by call its callback with the SDO_SI_START type. The module is expected to prepare to receive PSI, DSI, and OSI calls after initialization. If an error occurs after a module has been initialized, during the remainder of TO2 protocol execution and the Application is restarted, the SDK will again call this API to initialize each registered module. The module must be prepared for multiple such calls due to the SDK\u2019s retry-based approach to error recovery.","title":"Module Initialization"},{"location":"client-sdk/client-sdk-reference-guide/#pre-service-info-psi","text":"The intent of PSI is described in the SDO Protocol specification. Basically, PSI provides the Owner Server with a way to inform a module what to expect during the next two service info sequences (such as, DSI and OSI). The module should use this information to prepare itself for the subsequent exchanges. PSI is an ASCII string containing one or more 2-tuple of the format [module-name][module-data] . The SDK parses the PSI string and locates the module specified by module-name. If this module is not found, the SDK ignores it and continues with the next PSI touple in the string. The [module-data] is a key-value pair where the value is optional (depending on the key) and is encoded as key~value (the \u2018~\u2019 char is the delimiter). The SDK will parse this substring to extract the key and value. If the module is found, the SDK invokes the modules callback function with type SDO_SI_SET_PSI and passes the module-data to it in the sv parameter. The key is contained in sv.key and the value if present, is in sv.value . If no value is present, the sv.value will be NULL . The module is expected to process the key-value and return either success or failure. A failure response will cause the entire onboarding sequence to fail and the Application must retry it at a later time. In most cases the Owner Server will use PSI to allow the module to perform basic initialization and setup for the following DSI and OSI rounds in terms of allocating resources, and others. From a format standpoint, both key and value are NULL terminated ASCII strings. The value may optionally contain base64 encoded binary data. A PSI string could contain multiple 2-touples with the same module-name. In this case, the SDK will invoke the same module multiple times, once for each occurrence of module-name in the PSI string. The corresponding key-value pairs will be passed in each of these invocations. The count parameter will act as an \u2018index\u2019 starting at 0 for the first invocation and incremented for subsequent invocations. Note The PSI is considered the module configuration data and is independent of the DSI (see next section), which is the device information. The number of PSI elements is hence decoupled from the number of DSI elements. If the module wishes to retain either the key of value parameters for later use, it must make a local copy of the contents. The pointers passed during the invocation will be invalid after the callback returns to the SDK. Note PSI is one-way, from the Owner Server to the device. Apart from reporting success or failure, the device has no way of communicating any other information back to the Owner Server during this exchange.","title":"Pre-Service Info (PSI)"},{"location":"client-sdk/client-sdk-reference-guide/#device-service-info-dsi","text":"DSI follows PSI. The module needs to determine in advance how many DSI key-value pairs it needs to send to the Owner Service. In some cases, this is determined statically while in others, the module uses information obtained from the Owner Server in PSI to determine how many DSI key-values it needs to upload. On completing the PSI round, the SDK queries each registered module for the number of DSI rounds it requires. This is done by invoking the modules callback with the SDO_SI_GET_DSI_COUNT type. The module is expected to return the number of DSI key-value pairs it requires in the count callback parameter. When the DSI round for a module begins, the SDK will call the modules callback with the SDO_SI_GET_DSI type. The count parameter will indicate the \u2018index\u2019 of the DSI key-value pair being requested by the SDK. The SDK uploads each key-value pair to the Owner Server in the same order. The module may choose to ignore the \u2018index\u2019 sent by the SDK but it is advisable for the module to return key-value data based on this index. This callback will be invoked as many times as specified by the module by the prior SDO_SI_GET_DSI_COUNT return value (the \u2018index\u2019 value will vary from 0 to count-1 ). Key-values are returned in the sv.key and sv.value parameter fields. The sv.key must strictly be an NULL terminated ASCII string. The sv.value is also a NULL terminated ASCII string but could also be a Base64 encoded binary value. It is assumed that the Owner Server knows how to interpret a particular key-value from a particular module. The module must include Base64 encoding capabilities if required. The very first key-value returned by a module (\u2018index\u2019 zero) must be an activation value indicating whether the module is active or not. The key value must be \u201cactive\u201d and the value must be \u201c1\u201d if the module is active or \u201c0\u201d if the module is not active. If the module is not active, the Owner Server will not send and DSI messages to the module. This requires each module to have at least one DSI \u2013 that is, the count value returned for the SDO_SI_GET_DSI_COUNT callback type must be at least 1. See the SDO Protocol Specification for more information on module activation and deactivation. Note that DSI is one way \u2013 from device to Owner Server. The Owner Server cannot respond to any DSI message during this phase. It can however respond to a prior DSI message in the next, OSI phase.","title":"Device Service Info (DSI)"},{"location":"client-sdk/client-sdk-reference-guide/#owner-service-info-osi","text":"OSI follows DSI. Unlike DSI, neither the SDK nor the module can determine in advance how many OSI key-values they are going to receive. On receiving an OSI, the SDK locates the module and invokes its callback with the SDO_SI_SET_OSI type. Received key-values are passed to the module in the sv.key and sv.value callback parameter fields. The sv.key must strictly be an NULL terminated ASCII string. The sv.value is also a NULL terminated ASCII string but could also be a Base64 encoded binary value. It is assumed that the module knows how to interpret the value for a particular key based on the key name. In addition to the sv parameter, the SDK will pass an \u2018index\u2019 of the OSI in the count parameter. The \u2018index\u2019 begins at 0 and increments for each OSI key-value pair received for the module. Corresponding to the activation message in DSI, the Owner Server could send a deactivation message to a module if it is not planning to use the module. The message will have a key of \u201cactive\u201d and value of \u201c0\u201d . On receiving this message, a module may free allocated resources and effectively shutdown from an SDO perspective. Unlike the activation message, this message is optional and will only be sent if the Owner Server is not going to use the module. A module must expect to remain active unless it explicitly receives a deactivation message or it already indicated that is not active in the earlier DSI stage. See the SDO Protocol Specification for more information on module activation and deactivation. If a module receives an OSI when it is in the deactivated state, it should return a status of SDO SI_CONTENT_ERROR indicating that the received element was not expected. The module is expected to process the key-value pair and return a result indicating if the operation was successful or failed. The module may return SDO_SI_CONTENT_ERROR or SDO_SI_INTERNAL_ERROR to differentiate between invalid value contents or a module run-time error. This information is reported to the Owner Server. The module must return SDO_SI_SUCCESS on successful completion. Note that OSI is one way \u2013 from Owner Server to the device. Apart from indicating failure, the device cannot respond to an OSI message.","title":"Owner Service Info (OSI)"},{"location":"client-sdk/client-sdk-reference-guide/#module-completion","text":"When all service information rounds of all modules have completed successfully, the SDK calls each module\u2019s callback with the SDO_SI_END type. All other callback parameters are NULL . Modules can commit configuration information at this point if not already done so. The SDK will not call into the module after this. The SDK will ignore the return value of this callback since no further failure is expected at this point.","title":"Module Completion"},{"location":"client-sdk/client-sdk-reference-guide/#module-errors","text":"If an error occurs during the service information phase, the TO2 protocol is considered to have failed and will be aborted. The Application will need to retry onboarding at a later time. A failure could occur for multiple reasons including failure of device/server interaction, failure of signature or hash verification, malformed messages and also if a module returns a failure while processing a PSI, DSI, or OSI command/request. On failure, all modules must clean up internal state and discard any configuration information they might have got from the Owner Server. Conversely, the Owner Server will also discard all data it might have received from modules. When all service information rounds of all modules have completed successfully, the SDK calls each module\u2019s callback with the SDO_SI_FAILURE type. All other callback parameters are NULL . Modules must discard all information received via PSI or OSI commands until this point. If operations have been performed, or data already committed, they should be undone to return the system to a pre-service information state. The SDK will not call into the module after this. The SDK will ignore the return value of this callback since no further failure is expected at this point.","title":"Module Errors"},{"location":"client-sdk/client-sdk-reference-guide/#run-the-client-sdk","text":"The Client SDK includes a binary package, intended to get you started quickly and a source package. For details on downloading the packages, refer to the Get Started Guide.","title":"Run the Client SDK"},{"location":"client-sdk/client-sdk-reference-guide/#prerequisites","text":"The requirements for the computer that you will run Client SDK on are as follows: Table 1. Prerequisites Software \u00b7 Linux* Ubuntu* 16.04 / Ubuntu* 18.04 using OpenSSL* 1.1.1f \u00b7 JDK11 \u00b7 SDO release binaries package (for running test servers) o The root directory of extracted binary package is referred to as in subsequent sections. \u00b7 SDO Client SDK alpha-release binary package o The root directory of extracted binary package is referred to as < SDOClientSDK> in subsequent sections. \u00b7 SDO Client SDK alpha-release sources package o The root directory of extracted source code is referred to as < SDOClientSDK> in subsequent sections. \u00b7 Apache Maven* (for building sample Java* based test owner service) Additional Ubuntu* 16.04/18.04 prerequisites can be found in the /SDOClientSDK/README.md Enhanced Privacy ID (EPID) EPID SDK v6.0.1 \u00b7 Download EPID SDK v6.0.1: https://github.com/Intel-EPID-SDK/epid-sdk/releases \u00b7 Extract the tar.gz and open doc/index.html in a browser \u00b7 Follow the instructions in the \u201cBuilding from Source\u201d topic \u00b7 Recommend using scons for build Safestring library Safestring library v1.0.0 \u00b7 Download safestringlib from https://github.com/intel/safestringlib \u00b7 cd safestringlib \u00b7 mkdir obj \u00b7 make \u00b7 The library file libsafestring.a will be created after make. Java* Set the $JAVA_HOME environment variable.","title":"Prerequisites"},{"location":"client-sdk/client-sdk-reference-guide/#run-the-binary-package","text":"The following subsections provide the steps to run the binary package.","title":"Run the Binary Package"},{"location":"client-sdk/client-sdk-reference-guide/#get-the-device-private-key-epid-or-ecdsa-p-256-based","text":"The SDK requires a device Private Key as input for device attestation process (to prove itself to Rendezvous or Owner Server during TO1 or TO2 protocol). The key could be based on EPID or ECDSA (on curve P-256/P-384) based on the device attestation method being used on the field. This key must be stored in a specific file and is read by the SDK on startup. For EPID based device-attestation method: In case of EPID, place the EPID private Key with the name epidprivkey.dat in the following location: data/epidprivkey.dat For ECDSA (P-256) based device-attestation method: In case of ECDSA, place the ECDSA P-256 private Key with the name ecdsa256privkey.dat in the following location: data/ecdsa256privkey.dat For ECDSA (P-384) based device-attestation method: For ECDSA384, place the ECDSA P-384 private Key with the name ecdsa384privkey.dat in the following location: data/ecdsa384privkey.data Follow All-in-one Demo README to start the SDO Manufacturer, Rendezvous, and Owner Service: PRI Owner Service and PRI Rendezvous Service. To run SDO ARM Cortex-M4 or Cortex-A7 based devices, follow the detailed steps (including flashing and device preparation) mentioned in the [README](https://github.com/secure-device-onboard/client-sdk/blob/master/README.md) document. Terminal #1: Start All-in-one Demo","title":"Get the Device Private Key (EPID or ECDSA P-256 based)"},{"location":"client-sdk/client-sdk-reference-guide/#device-initialization","text":"This section describes about running the SDO reference device (based on Linux* reference implementation) only. Going forward, refers to the location where the SDO Client application 'linux-client' and the related 'data' folder are placed. Note Running the device the first time completes DI. Running the device the second time on boards the device. Between subsequent device runs, it is assumed that ownership proxy is correctly extended and TO0 is successfully completed. Terminal 2: Run the device for device initialization: $ cd <sdo-client-sdk-bindir> $ ./linux-client` $ ./linux-client --------DI successful-------- This step completes Device Initialization.","title":"Device Initialization"},{"location":"client-sdk/client-sdk-reference-guide/#device-onboarding","text":"Run the device again to onboard the device: $ cd <sdo-client-sdk-bindir> $ ./linux-client` $ ./linux-client --------TO2 successful-------- @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @Secure Device Onboarding Complete@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ This step successfully onboards the device. Note To run SDO ARM Cortex-M4 or Cortex-A7 based devices, follow the detailed steps (including flashing and device preparation) mentioned in the README document.","title":"Device Onboarding"},{"location":"client-sdk/client-sdk-reference-guide/#build-the-source","text":"Follow these steps to build the source package: Make sure you have completed the pre-requisites. Download source code from Github repository . Follow the instructions provided in the README to build the source code by setting the necessary environment variables. The SDO Client binary is generated either in build/linux/debug or build/linux/release folder, depending on the build mode. Ensure to copy them to the root folder before proceeding with the next steps. Run the PRI Servers Complete Device Initialization Complete Device Onboarding","title":"Build the Source"},{"location":"client-sdk/client-sdk-reference-guide/#custom-pluggable-modules","text":"As part of the onboard protocol, the Client SDK supports custom pluggable modules. OEMs can develop their desired functionality by following the module protocol. This module functionality will be called during the onboard protocol. A sample device module, sdo_sys has been developed and is available for reference. sdo_sys device module is intended to collect the data (typically files and scripts) sent from the SDO Owner to the SDO device, process, and execute the data in some meaningful way. To use sdo_sys device module, follow these steps: To use the sample device module sdo_sys : Build Client SDK either in release or debug mode using MODULES=true flag. $ cd client-sdk/ $ make pristine $ make MODULES=true The binary would be created either in build/linux/debug or build/linux/release folder. Copy them to the root folder before proceeding with the next steps. Run the SDO Linux* device for Device Initialization (DI) protocol: $ ./linux-client --------DI successful-------- Run the SDO Linux* device for Transfer of Ownership (TO1/TO2) protocol (it is assumed that ownership voucher is correctly extended and TO0 is successfully completed prior to this step): $ ./linux-client --------TO2 successful-------- @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @Secure Device Onboarding Complete@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@","title":"Custom Pluggable Modules"},{"location":"client-sdk/client-sdk-reference-guide/#known-issues-and-limitations","text":"The following are the known issues: \u2022 The HAL implementation provided in this release is for reference only and not intended for production. It does not provide the level of security required by industry standards for a fully secure production environment. \u2022 \u2018sdo_sys\u2019 module source within 'device_modules' folder is an example code demonstrating SDO device module implementation for reference purpose only. This code is not written following secure production level coding and checks. This sample code must not to be used as it is. The following are the known limitations: \u2022 EPID based device-attestation (DA) method is not supported with STM32F429ZI MCU due to memory constraints in the underlying development board NUCLEO-F429ZI. \u2022 Network discovery and CSR feature is not supported for ARM Cortex M4, M7, and A7 devices.","title":"Known Issues and Limitations"},{"location":"iot-platform-sdk/development-guide/","text":"The IOT Platform SDK consists of Owner Companion Service (OCS) that can be implemented to integrate any other device management solution. Both the OPS and To0Scheduler are bound to the OCS by a set of pre-defined REST contracts, as specified in the module libocs , that can be implemented to perform certain pre-defined tasks. Each REST API must carry out only the corresponding task, and must accept/return only the corresponding Message Type object. The implementation of these REST contracts in an OCS can be done in any programming language. A sample java-based reference implementation of OCS is provided by the module ocsfs that uses file-system as database. As such, both OPS and To0Scheduler will work out-of-the-box with any implementation of OCS that supports the pre-defined REST contracts. Rest Contracts between OCS (server) and OPS/To0Scheduler (client) \u00b6 Following are the pre-defined REST API specifications for all the resource paths that must be implemented and exposed by an OCS implementation. Both, OPS and To0Scheduler makes requests to the OCS implementation, as clients, using this format. Operation Description Path/Query Parameters Request Body Response Body GET /v1/devices/{deviceId}/voucher Get the ownership voucher corresponding to the deviceId . Path: deviceId : Device identifier OwnerVoucher POST /v1/devices/voucher Store the ownership voucher. OwnerVoucher GET /v1/devices/{deviceId}/state Get the state information corresponding to the deviceId . Path: deviceId : Device identifier DeviceState POST /v1/devices/{deviceId}/state Store the state information corresponding to the deviceId . Path: deviceId : Device identifier DeviceState GET /v1/devices/{deviceId}/msgs Get service info array corresponding to the deviceId . Path: deviceId : Device identifier [SviMessage] POST /v1/devices/{deviceId}/msgs Store service info array corresponding to the deviceId . Path: deviceId : Device identifier [SviMessage] PUT /v1/devices/{deviceId}/msgs Store module message info corresponding to the deviceId . Path: deviceId : Device identifier ModuleMessage DELETE /v1/devices/{deviceId}/msgs Delete service info array corresponding to the deviceId . Path: deviceId : Device identifier GET /v1/devices/{deviceId}/psi Get module message array corresponding to the deviceId . Path: deviceId : Device identifier [ModuleMessage] GET /v1/ devices/{deviceId}/values/{valueId} Get the serviceinfo value corresponding to the valueId for the device identified by deviceId . Path: deviceId : Device identifier, valueId : Serviceinfo resource identifier Query start : start index, end : end index Byte Array PUT /v1/ devices/{deviceId}/values/{valueId} Store the serviceinfo value corresponding to the valueId for the device identified by deviceId . Path: deviceId : Device identifier, valueId : Serviceinfo resource identifier Byte Array DELETE /v1/ devices/{deviceId}/values/{valueId} Delete the serviceinfo value corresponding to the valueId for the device identified by deviceId . Path: deviceId : Device identifier, valueId : Serviceinfo resource identifier GET /v1/devices/{deviceId}/setupinfo Get new setup information corresponding to the deviceId . Path: deviceId : Device identifier SetupInfoResponse POST /v1/devices/{deviceId}/errors Store the error information corresponding to the deviceId . Path: deviceId : Device identifier DeviceState POST /v1/signatures/{deviceId} Generate signature of input data and return it along with associated info, corresponding to the deviceId . Path: deviceId : Device identifier String POST /v1/ciphers/{deviceId} Perform the operation and return data corresponding to the . Path: deviceId : Device identifier; Query: operation : encipher/decipher Byte Array Byte Array DELETE /devices/{deviceId}/blob Delete the deviceId along with all the associated data. Path: deviceId : Device identifier GET /v1/devices/{deviceId}/sessioninfo Get the TO2 session info corresponding to the deviceId . Path: deviceId : Device identifier To2DeviceSessionInfo POST /v1/devices/{deviceId}/sessioninfo Update the TO2 session info corresponding to the deviceId . Path: deviceId : Device identifier To2DeviceSessionInfo DELETE /v1/devices/{deviceId}/sessioninfo Delete the TO2 session info corresponding to the deviceId . Path: deviceId : Device identifier Rest Contracts between To0Scheduler (server) and OCS (client) \u00b6 An OCS implementation must, also, acta as a client to trigger TO0 for set of devices, by making the following request to To0Scheduler. To0Scheduler accepts the request from OCS to initiate TO0 for the list of devices. Operation Description Path/Query Parameters Request Body Response Body POST /v1/to0/devices Trigger TO0 for an array of devices. To0Request Message Types \u00b6 Following is a list of message types that are sent in the message body of each request/response. Each message type follows the standard JSON* schema. Statements after '#' inside the JavaScript Object Notation (JSON), represents the purpose of the field. DeviceState \u00b6 This JSON* structure represents the state information of the device. Message Body: { \"to2Error\": ProtocolError Object, # TO2 failure information \"to2Timestamp\": String, # Successful TO2 completion time \"g3\": String, # Device Identifier/GUID \"to0Error\": String, # TO0 failure information \"to0Timestamp\": String, # Successful TO0 completion time \"to0Ws\": Integer, # Number of seconds for which last successul TO0 is valid. \"to2State\": String # TO2 state } Every field is optional. ProtocolError \u00b6 This JSON* structure represents the device's error information that occurred during execution of the protocol. Message Body: { \"ec\": Integer, # Error code \"emsg\": Integer, # Message ID \"em\": String # Error message } ModuleMessage \u00b6 This JSON* structure contains the key-value pairs for a particular module name. It is used to store, both, the device's serviceinfo, and the owner's pre-serviceinfo. Message Body: { \"module\": String, # module name \"msg\": String, # (pre-)serviceinfo key \"value\": String # (pre-)serviceinfo value } SviMessage \u00b6 This JSON* structure represents information about the owner service info. Message Body: { \"module\": String, # Module name \"msg\": String, # Message to be sent \"valueLen\": Integer, # Length of the value of the message \"valueId\": String, # Key to use when retrieving the serviceinfo value \"enc\": String # Encoding expected to use when sending the value } SetupInfoResponse \u00b6 This JSON* structure represents the new Device identifier and the Rendezvous information. Message Body: { \"g3\": String, # New device identifier/GUID \"r3\": [ RendezvousInstruction Object # Array of RendezvousInstruction objects ] } RendezvousInstruction \u00b6 This JSON* structure represents the rendezvous information. Please refer to the RendezvousInfo to know about these values. Message Body: { \"only\": String, \"ip\": String, \"po\": Integer, \"pow\": Integer, \"dn\": String, \"sch\": String, \"cch\": String, \"ui\": Integer, \"ss\": String, \"pw\": String, \"wsp\": String, \"me\": String, \"pr\": String, \"delaysec\": Integer } SignatureResponse \u00b6 This JSON* structure represents the response to the signature operation. Message Body: { \"sg\": String, # Base-64 encoded signature information \"pk\": String, # Base-64 encode public key information that can verify the signature \"alg\": String # Algorithm of the public key } OwnerVoucher \u00b6 This JSON* structure represents the Ownership voucher of the device. Please refer to the Ownership Voucher about the structure. Message41Store \u00b6 This JSON* structure represents the information from Secure Device Onboard protocol's request TO2.HelloDevice, Type 40 and its subsequent response TO2.ProveOPHdr, Type 41 . This information is stored as a part of TO2 session information per device. Message Body: { \"n6\": String, # Nonce n6 \"kx\": String, # Key exchange information \"ownershipVoucher\": String, # ownership voucher \"cs\": String, # cipher suite \"kxEcdhPublicKey\": String, # Public key being used for ECDH key exchange \"kxEcdhPrivateKey\": String, # Private key being used for ECDH key exchange \"kxEcdhRandom\": String, # Random being used for ECDH key exchange \"kxDhPublicKey\": String, # Public key being used for DH key exchange \"kxDhPrivateKey\": String, # Public key being used for DH key exchange \"asymRandom\": String # Random being used for Asymmetric key exchange } Message45Store \u00b6 This JSON* structure represents the information from Secure Device Onboard protocol's request TO2.ProveDevice, Type 44 and its subsequent response TO2.GetNextDeviceServiceInfo, Type 45 . This information is stored as a part of TO2 session information per device. Message Body: { \"n7\": String, # Nonce n7 \"nn\": Integer, # Total number of serviceinfo \"xb\": String # Second part of key-exchange } Message47Store \u00b6 This JSON* structure contains the new ownership voucher information, temporarily, until till the end of TO2 protocol, created during response generation of TO2.SetupDevice, Type 47 . This information is stored as a part of TO2 session information per device. Message Body: { \"newOwnershipVoucher\": String # the new ownership voucher structure without hmac } DeviceCryptoInfo \u00b6 This JSON* structure contains the nonce and counter of the Initialization Vector for the Secure Device Onboard TO2 cipher mode of operation. Message Body: { \"ctrNonce\": String, # Nonce used for CTR mode \"ctrCounter\": Long # Counter value used for CTR mode } To2DeviceSessionInfo \u00b6 This JSON* structure represents the complete TO2 session information. It's a combination of multiple structures, where each structure is either null or contains values. If any of the structure is null, OCS treats the structure as non-updatable in its store, while OPS considers the same to be an erroneous case. If any of the structure contains appropriate information, OCS overrides the current content with the new content, while OPS processes the content during TO2 protocol execution. Message Body: { \"messsage41Store\": Message41Store Object, \"messsage45Store\": Message45Store Object, \"messsage47Store\": Message47Store Object, \"deviceCryptoInfo\": DeviceCryptoInfo Object } To0Request \u00b6 This JSON* structure represents the request message that is sent from the OCS to schedule an array of devices for TO0. Message Body: { \"guids\": [ String # Array of Device Identifiers/GUID ], \"waitSeconds\": String # Suggested number of seconds for which TO0 will be valid }","title":"Development Guide"},{"location":"iot-platform-sdk/development-guide/#rest-contracts-between-ocs-server-and-opsto0scheduler-client","text":"Following are the pre-defined REST API specifications for all the resource paths that must be implemented and exposed by an OCS implementation. Both, OPS and To0Scheduler makes requests to the OCS implementation, as clients, using this format. Operation Description Path/Query Parameters Request Body Response Body GET /v1/devices/{deviceId}/voucher Get the ownership voucher corresponding to the deviceId . Path: deviceId : Device identifier OwnerVoucher POST /v1/devices/voucher Store the ownership voucher. OwnerVoucher GET /v1/devices/{deviceId}/state Get the state information corresponding to the deviceId . Path: deviceId : Device identifier DeviceState POST /v1/devices/{deviceId}/state Store the state information corresponding to the deviceId . Path: deviceId : Device identifier DeviceState GET /v1/devices/{deviceId}/msgs Get service info array corresponding to the deviceId . Path: deviceId : Device identifier [SviMessage] POST /v1/devices/{deviceId}/msgs Store service info array corresponding to the deviceId . Path: deviceId : Device identifier [SviMessage] PUT /v1/devices/{deviceId}/msgs Store module message info corresponding to the deviceId . Path: deviceId : Device identifier ModuleMessage DELETE /v1/devices/{deviceId}/msgs Delete service info array corresponding to the deviceId . Path: deviceId : Device identifier GET /v1/devices/{deviceId}/psi Get module message array corresponding to the deviceId . Path: deviceId : Device identifier [ModuleMessage] GET /v1/ devices/{deviceId}/values/{valueId} Get the serviceinfo value corresponding to the valueId for the device identified by deviceId . Path: deviceId : Device identifier, valueId : Serviceinfo resource identifier Query start : start index, end : end index Byte Array PUT /v1/ devices/{deviceId}/values/{valueId} Store the serviceinfo value corresponding to the valueId for the device identified by deviceId . Path: deviceId : Device identifier, valueId : Serviceinfo resource identifier Byte Array DELETE /v1/ devices/{deviceId}/values/{valueId} Delete the serviceinfo value corresponding to the valueId for the device identified by deviceId . Path: deviceId : Device identifier, valueId : Serviceinfo resource identifier GET /v1/devices/{deviceId}/setupinfo Get new setup information corresponding to the deviceId . Path: deviceId : Device identifier SetupInfoResponse POST /v1/devices/{deviceId}/errors Store the error information corresponding to the deviceId . Path: deviceId : Device identifier DeviceState POST /v1/signatures/{deviceId} Generate signature of input data and return it along with associated info, corresponding to the deviceId . Path: deviceId : Device identifier String POST /v1/ciphers/{deviceId} Perform the operation and return data corresponding to the . Path: deviceId : Device identifier; Query: operation : encipher/decipher Byte Array Byte Array DELETE /devices/{deviceId}/blob Delete the deviceId along with all the associated data. Path: deviceId : Device identifier GET /v1/devices/{deviceId}/sessioninfo Get the TO2 session info corresponding to the deviceId . Path: deviceId : Device identifier To2DeviceSessionInfo POST /v1/devices/{deviceId}/sessioninfo Update the TO2 session info corresponding to the deviceId . Path: deviceId : Device identifier To2DeviceSessionInfo DELETE /v1/devices/{deviceId}/sessioninfo Delete the TO2 session info corresponding to the deviceId . Path: deviceId : Device identifier","title":"Rest Contracts between OCS (server) and OPS/To0Scheduler (client)"},{"location":"iot-platform-sdk/development-guide/#rest-contracts-between-to0scheduler-server-and-ocs-client","text":"An OCS implementation must, also, acta as a client to trigger TO0 for set of devices, by making the following request to To0Scheduler. To0Scheduler accepts the request from OCS to initiate TO0 for the list of devices. Operation Description Path/Query Parameters Request Body Response Body POST /v1/to0/devices Trigger TO0 for an array of devices. To0Request","title":"Rest Contracts between To0Scheduler (server) and OCS (client)"},{"location":"iot-platform-sdk/development-guide/#message-types","text":"Following is a list of message types that are sent in the message body of each request/response. Each message type follows the standard JSON* schema. Statements after '#' inside the JavaScript Object Notation (JSON), represents the purpose of the field.","title":"Message Types"},{"location":"iot-platform-sdk/development-guide/#devicestate","text":"This JSON* structure represents the state information of the device. Message Body: { \"to2Error\": ProtocolError Object, # TO2 failure information \"to2Timestamp\": String, # Successful TO2 completion time \"g3\": String, # Device Identifier/GUID \"to0Error\": String, # TO0 failure information \"to0Timestamp\": String, # Successful TO0 completion time \"to0Ws\": Integer, # Number of seconds for which last successul TO0 is valid. \"to2State\": String # TO2 state } Every field is optional.","title":"DeviceState"},{"location":"iot-platform-sdk/development-guide/#protocolerror","text":"This JSON* structure represents the device's error information that occurred during execution of the protocol. Message Body: { \"ec\": Integer, # Error code \"emsg\": Integer, # Message ID \"em\": String # Error message }","title":"ProtocolError"},{"location":"iot-platform-sdk/development-guide/#modulemessage","text":"This JSON* structure contains the key-value pairs for a particular module name. It is used to store, both, the device's serviceinfo, and the owner's pre-serviceinfo. Message Body: { \"module\": String, # module name \"msg\": String, # (pre-)serviceinfo key \"value\": String # (pre-)serviceinfo value }","title":"ModuleMessage"},{"location":"iot-platform-sdk/development-guide/#svimessage","text":"This JSON* structure represents information about the owner service info. Message Body: { \"module\": String, # Module name \"msg\": String, # Message to be sent \"valueLen\": Integer, # Length of the value of the message \"valueId\": String, # Key to use when retrieving the serviceinfo value \"enc\": String # Encoding expected to use when sending the value }","title":"SviMessage"},{"location":"iot-platform-sdk/development-guide/#setupinforesponse","text":"This JSON* structure represents the new Device identifier and the Rendezvous information. Message Body: { \"g3\": String, # New device identifier/GUID \"r3\": [ RendezvousInstruction Object # Array of RendezvousInstruction objects ] }","title":"SetupInfoResponse"},{"location":"iot-platform-sdk/development-guide/#rendezvousinstruction","text":"This JSON* structure represents the rendezvous information. Please refer to the RendezvousInfo to know about these values. Message Body: { \"only\": String, \"ip\": String, \"po\": Integer, \"pow\": Integer, \"dn\": String, \"sch\": String, \"cch\": String, \"ui\": Integer, \"ss\": String, \"pw\": String, \"wsp\": String, \"me\": String, \"pr\": String, \"delaysec\": Integer }","title":"RendezvousInstruction"},{"location":"iot-platform-sdk/development-guide/#signatureresponse","text":"This JSON* structure represents the response to the signature operation. Message Body: { \"sg\": String, # Base-64 encoded signature information \"pk\": String, # Base-64 encode public key information that can verify the signature \"alg\": String # Algorithm of the public key }","title":"SignatureResponse"},{"location":"iot-platform-sdk/development-guide/#ownervoucher","text":"This JSON* structure represents the Ownership voucher of the device. Please refer to the Ownership Voucher about the structure.","title":"OwnerVoucher"},{"location":"iot-platform-sdk/development-guide/#message41store","text":"This JSON* structure represents the information from Secure Device Onboard protocol's request TO2.HelloDevice, Type 40 and its subsequent response TO2.ProveOPHdr, Type 41 . This information is stored as a part of TO2 session information per device. Message Body: { \"n6\": String, # Nonce n6 \"kx\": String, # Key exchange information \"ownershipVoucher\": String, # ownership voucher \"cs\": String, # cipher suite \"kxEcdhPublicKey\": String, # Public key being used for ECDH key exchange \"kxEcdhPrivateKey\": String, # Private key being used for ECDH key exchange \"kxEcdhRandom\": String, # Random being used for ECDH key exchange \"kxDhPublicKey\": String, # Public key being used for DH key exchange \"kxDhPrivateKey\": String, # Public key being used for DH key exchange \"asymRandom\": String # Random being used for Asymmetric key exchange }","title":"Message41Store"},{"location":"iot-platform-sdk/development-guide/#message45store","text":"This JSON* structure represents the information from Secure Device Onboard protocol's request TO2.ProveDevice, Type 44 and its subsequent response TO2.GetNextDeviceServiceInfo, Type 45 . This information is stored as a part of TO2 session information per device. Message Body: { \"n7\": String, # Nonce n7 \"nn\": Integer, # Total number of serviceinfo \"xb\": String # Second part of key-exchange }","title":"Message45Store"},{"location":"iot-platform-sdk/development-guide/#message47store","text":"This JSON* structure contains the new ownership voucher information, temporarily, until till the end of TO2 protocol, created during response generation of TO2.SetupDevice, Type 47 . This information is stored as a part of TO2 session information per device. Message Body: { \"newOwnershipVoucher\": String # the new ownership voucher structure without hmac }","title":"Message47Store"},{"location":"iot-platform-sdk/development-guide/#devicecryptoinfo","text":"This JSON* structure contains the nonce and counter of the Initialization Vector for the Secure Device Onboard TO2 cipher mode of operation. Message Body: { \"ctrNonce\": String, # Nonce used for CTR mode \"ctrCounter\": Long # Counter value used for CTR mode }","title":"DeviceCryptoInfo"},{"location":"iot-platform-sdk/development-guide/#to2devicesessioninfo","text":"This JSON* structure represents the complete TO2 session information. It's a combination of multiple structures, where each structure is either null or contains values. If any of the structure is null, OCS treats the structure as non-updatable in its store, while OPS considers the same to be an erroneous case. If any of the structure contains appropriate information, OCS overrides the current content with the new content, while OPS processes the content during TO2 protocol execution. Message Body: { \"messsage41Store\": Message41Store Object, \"messsage45Store\": Message45Store Object, \"messsage47Store\": Message47Store Object, \"deviceCryptoInfo\": DeviceCryptoInfo Object }","title":"To2DeviceSessionInfo"},{"location":"iot-platform-sdk/development-guide/#to0request","text":"This JSON* structure represents the request message that is sent from the OCS to schedule an array of devices for TO0. Message Body: { \"guids\": [ String # Array of Device Identifiers/GUID ], \"waitSeconds\": String # Suggested number of seconds for which TO0 will be valid }","title":"To0Request"},{"location":"iot-platform-sdk/introduction/","text":"IOT Platform SDK \u00b6 Security Considerations \u00b6 The Secure Device Onboard IoT Platform SDK uses several property files for configuration. It is vital that these files are protected from malicious usage. This should include setting appropriate permissions and general system security practices. Failure to do so can severely compromise the security of this software. Introduction \u00b6 The Secure Device Onboard IoT Platform SDK provides components that enable the integration of an owners IOT Platform (also known as a Device Management Service) into a Secure Device Onboard service. The SDK is comprised of three components: Owner Protocol Service (OPS), Owner Companion Service (OCS), and To0Scheduler. The To0Scheduler is responsible for executing TO0, while Owner Protocol Service (OPS) is responsible for executing TO2 for any Secure Device Onboard-enabled device. The Owner Companion Service (OCS) provides the device information and functions to the other two components, and abstracts the actual owner(s) of the devices from the said components. Components \u00b6 The IOT Platform SDK is comprised of the following components: common: This component holds the common packages that are shared and used by all the other components in the IOT Platform SDK package. This component is composed of two modules: rest: Contains the bean classes that represent the message objects for REST APIs, and is used during request and response messages. Also contains some utility classes to perform some specific functions. protocol: Contains the Secure Device Onboard protocol-specific beans and utility classes used across the TO0 and TO2 protocol implementations. It contains the security specific implementations, encoders and decoders for Secure Device Onboard protocol messages among others. to0scheduler : This component is responsible for the scheduling and completion of TO0 for multiple ownership proxies. It makes use of the CRIs libto0client to perform TO0 for any device. This component is comprised of three modules: libto0 : This module implements a REST endpoint that takes an array of device IDs (GUIDs) and the corresponding TO0 wait seconds as inputs. OCS calls this endpoint to trigger TO0 for an array of devices. This package also provides interfaces, whose implementation must provide ways to fetch the Ownership vouchers and set the TO0 status for every GUID. to0serviceimpl : This module contains the spring boot application and its configuration classes. It imports the 'libto0' component as a dependency, configures it, and provides implementations of its interfaces that are used as inputs to the T00 operation. The interface implementation interacts with OCS and does TO0 for a given set of ownership vouchers fetched from OCS. Once built, this package contains the actual runnable war with an embedded tomcat server, which the user can run to start to0scheduler as a service. ocs: This component is comprised of two modules: libocs : Defines the REST endpoints and the associated contract, where each endpoint is mapped to a specific method. Any vendor or BMS(building management service) that is implementing its own OCS needs to import this jar, and to provide their implementations for the same methods. fsimpl : A sample File-system implementation of OCS. It imports the 'libocs' as a dependency and implements the contracts defined in the OCS's Rest Contract. Being a file-based implementation, it uses the file-system as database to read from, in addition to store the device information as well as the owner credentials. ops: This component is responsible for the actual onboarding of a device by running T02 for a given GUID. It is comprised of five modules: libops: This module contains the TO2 REST endpoints and some basic configuration for these endpoint implementations. This module provides interfaces whose implementations must provide the required data for the protocol to work. restimpl: This module makes use of 'libops' module to execute TO2 for multiple SDO clients. It re-configures the 'libops' and provides implementations of a few interfaces that define the way data is provided to TO2 protocol endpoints. It sends REST calls toOCS to get and store device-specific information, such as ownership voucher, service-info files, TO2 session information among others, then provides these as inputs to the TO2 protocol endpoints. epid: This module contains the Intel \u00ae Enhanced Privacy ID(Intel \u00ae EPID)-specific implementations that is used by the 'libops' module to handle Intel \u00ae EPID-based Secure Device Onboard clients. It contacts the Intel \u00ae EPID online services to validate Secure Device Onboard clients. serviceinfo: This module contains the service info interfaces and implementations to marshal these data. The interfaces must be implemented by the application that wishes to be able to transfer service info configuration data to the Secure Device Onboard clients. Docker Scripts \u00b6 The 'demo' directory contains the Docker* scripts, the runnable binaries, and the configuration needed to run these binaries. A single docker-compose.yml file is used to bring up the three components. ocs: Contains OCS-specific information. Config The configuration properties and files needed to run the ocs.war resides in this directory DockerFile The Docker* file that contains the container information where the OCS can be run. run-ocs The runnable script that starts OCS as a service by running ocs.war ops: Contains OPS-specific information. Config The configuration properties and files needed to run the ops.war resides in this directory. DockerFile The Docker* file that contains the container information where the OPS can be run. run-ops The runnable script that starts OPS as a service by running ops.war. To0scheduler: Contains To0Scheduler specific information. Config The configuration properties and files needed to run the to0scheduler.war resides in this directory. DockerFile The Docker* file that contains the container information where the to0scheduler can be run. run-to0scheduler The runnable script that starts to0scheduler as a service by running to0scheduler.war Terminology \u00b6 Refer to the Secure Device Onboard Reference page . Development Environment Specifications \u00b6 Table 1. Development Environment Specifications Environment Variable Requirement Operating System Ubuntu* 18.04 (64-bit) or Windows* 10 64-bit) Disk space A minimum of 300 MB after installation RAM (Minimum) Owner: 1 GB Build: 4GB Java* Java* Development Kit 11 Apache* Apache Maven* 3.5.4 or later (needed to build the SDK from source) OpenSSL* Optional; for creating owner RSA/ECDSA keys and Keystore Docker container Version 18.09. Optional; for running the demo as Docker* containers. Refer to https://docs.docker.com/ for information on setting up Docker. Docker Compose tool Version 1.21.2. Optional; for running the demo as Docker* containers. Entropy Tool Tools to generate additional entropy in the system. Examples: 'rngd', 'haveged' Reference Documents \u00b6 Refer to the Secure Device Onboard Reference page . Limitations of This Release \u00b6 The number of concurrent TO0 sessions are limited by a configuration property. TO0 requests for any numbers of devices may be dropped if this limit is reached. The keystore and truststore passwords are present in the configuration files as plain text. Special care must be taken to secure the configuration files.","title":"Introduction"},{"location":"iot-platform-sdk/introduction/#iot-platform-sdk","text":"","title":"IOT Platform SDK"},{"location":"iot-platform-sdk/introduction/#security-considerations","text":"The Secure Device Onboard IoT Platform SDK uses several property files for configuration. It is vital that these files are protected from malicious usage. This should include setting appropriate permissions and general system security practices. Failure to do so can severely compromise the security of this software.","title":"Security Considerations"},{"location":"iot-platform-sdk/introduction/#introduction","text":"The Secure Device Onboard IoT Platform SDK provides components that enable the integration of an owners IOT Platform (also known as a Device Management Service) into a Secure Device Onboard service. The SDK is comprised of three components: Owner Protocol Service (OPS), Owner Companion Service (OCS), and To0Scheduler. The To0Scheduler is responsible for executing TO0, while Owner Protocol Service (OPS) is responsible for executing TO2 for any Secure Device Onboard-enabled device. The Owner Companion Service (OCS) provides the device information and functions to the other two components, and abstracts the actual owner(s) of the devices from the said components.","title":"Introduction"},{"location":"iot-platform-sdk/introduction/#components","text":"The IOT Platform SDK is comprised of the following components: common: This component holds the common packages that are shared and used by all the other components in the IOT Platform SDK package. This component is composed of two modules: rest: Contains the bean classes that represent the message objects for REST APIs, and is used during request and response messages. Also contains some utility classes to perform some specific functions. protocol: Contains the Secure Device Onboard protocol-specific beans and utility classes used across the TO0 and TO2 protocol implementations. It contains the security specific implementations, encoders and decoders for Secure Device Onboard protocol messages among others. to0scheduler : This component is responsible for the scheduling and completion of TO0 for multiple ownership proxies. It makes use of the CRIs libto0client to perform TO0 for any device. This component is comprised of three modules: libto0 : This module implements a REST endpoint that takes an array of device IDs (GUIDs) and the corresponding TO0 wait seconds as inputs. OCS calls this endpoint to trigger TO0 for an array of devices. This package also provides interfaces, whose implementation must provide ways to fetch the Ownership vouchers and set the TO0 status for every GUID. to0serviceimpl : This module contains the spring boot application and its configuration classes. It imports the 'libto0' component as a dependency, configures it, and provides implementations of its interfaces that are used as inputs to the T00 operation. The interface implementation interacts with OCS and does TO0 for a given set of ownership vouchers fetched from OCS. Once built, this package contains the actual runnable war with an embedded tomcat server, which the user can run to start to0scheduler as a service. ocs: This component is comprised of two modules: libocs : Defines the REST endpoints and the associated contract, where each endpoint is mapped to a specific method. Any vendor or BMS(building management service) that is implementing its own OCS needs to import this jar, and to provide their implementations for the same methods. fsimpl : A sample File-system implementation of OCS. It imports the 'libocs' as a dependency and implements the contracts defined in the OCS's Rest Contract. Being a file-based implementation, it uses the file-system as database to read from, in addition to store the device information as well as the owner credentials. ops: This component is responsible for the actual onboarding of a device by running T02 for a given GUID. It is comprised of five modules: libops: This module contains the TO2 REST endpoints and some basic configuration for these endpoint implementations. This module provides interfaces whose implementations must provide the required data for the protocol to work. restimpl: This module makes use of 'libops' module to execute TO2 for multiple SDO clients. It re-configures the 'libops' and provides implementations of a few interfaces that define the way data is provided to TO2 protocol endpoints. It sends REST calls toOCS to get and store device-specific information, such as ownership voucher, service-info files, TO2 session information among others, then provides these as inputs to the TO2 protocol endpoints. epid: This module contains the Intel \u00ae Enhanced Privacy ID(Intel \u00ae EPID)-specific implementations that is used by the 'libops' module to handle Intel \u00ae EPID-based Secure Device Onboard clients. It contacts the Intel \u00ae EPID online services to validate Secure Device Onboard clients. serviceinfo: This module contains the service info interfaces and implementations to marshal these data. The interfaces must be implemented by the application that wishes to be able to transfer service info configuration data to the Secure Device Onboard clients.","title":"Components"},{"location":"iot-platform-sdk/introduction/#docker-scripts","text":"The 'demo' directory contains the Docker* scripts, the runnable binaries, and the configuration needed to run these binaries. A single docker-compose.yml file is used to bring up the three components. ocs: Contains OCS-specific information. Config The configuration properties and files needed to run the ocs.war resides in this directory DockerFile The Docker* file that contains the container information where the OCS can be run. run-ocs The runnable script that starts OCS as a service by running ocs.war ops: Contains OPS-specific information. Config The configuration properties and files needed to run the ops.war resides in this directory. DockerFile The Docker* file that contains the container information where the OPS can be run. run-ops The runnable script that starts OPS as a service by running ops.war. To0scheduler: Contains To0Scheduler specific information. Config The configuration properties and files needed to run the to0scheduler.war resides in this directory. DockerFile The Docker* file that contains the container information where the to0scheduler can be run. run-to0scheduler The runnable script that starts to0scheduler as a service by running to0scheduler.war","title":"Docker Scripts"},{"location":"iot-platform-sdk/introduction/#terminology","text":"Refer to the Secure Device Onboard Reference page .","title":"Terminology"},{"location":"iot-platform-sdk/introduction/#development-environment-specifications","text":"Table 1. Development Environment Specifications Environment Variable Requirement Operating System Ubuntu* 18.04 (64-bit) or Windows* 10 64-bit) Disk space A minimum of 300 MB after installation RAM (Minimum) Owner: 1 GB Build: 4GB Java* Java* Development Kit 11 Apache* Apache Maven* 3.5.4 or later (needed to build the SDK from source) OpenSSL* Optional; for creating owner RSA/ECDSA keys and Keystore Docker container Version 18.09. Optional; for running the demo as Docker* containers. Refer to https://docs.docker.com/ for information on setting up Docker. Docker Compose tool Version 1.21.2. Optional; for running the demo as Docker* containers. Entropy Tool Tools to generate additional entropy in the system. Examples: 'rngd', 'haveged'","title":"Development Environment Specifications"},{"location":"iot-platform-sdk/introduction/#reference-documents","text":"Refer to the Secure Device Onboard Reference page .","title":"Reference Documents"},{"location":"iot-platform-sdk/introduction/#limitations-of-this-release","text":"The number of concurrent TO0 sessions are limited by a configuration property. TO0 requests for any numbers of devices may be dropped if this limit is reached. The keystore and truststore passwords are present in the configuration files as plain text. Special care must be taken to secure the configuration files.","title":"Limitations of This Release"},{"location":"iot-platform-sdk/running-the-demo/","text":"Running Demos with the IOT Platform SDK \u00b6 Running the IoT Platform SDK with the PRI \u00b6 Secure Device Onboard provides a Protocol Reference Implementation (PRI) for the following Secure Device Onboard components: Rendezvous and Device. Both of these components are required to perform an end-to-end execution of the Secure Device Onboard protocol. To test integration of Secure Device Onboard with the IOT Platform SDK solution, the simulated Device and Rendezvous components of the PRI can be used. Pre-requisites for Running the Demo \u00b6 Clone the source repository of the Protocol Reference Implementation (PRI). In the rest of this section, the absolute path of this folder is referred to as <sdo-pri-root>. Build the PRI by following the steps mentioned in its README . Alternatively, run the command mvn package The build creates and copies the Rendezvous and Device WAR/JAR files into their respective \\<sdo-pri-root>/demo directory. <sdo-pri-root> has the following directories, which are used during the IOT Platform SDK execution. <sdo-pri-root>/demo: Sample scripts and configuration to run the demonstration of an onboarding process are located in the following directories: README.md rendezvous/ ./rendezvous (Sample script to start rendezvous) device/ ./device (Sample script to start device) Clone the source repository of the IoT Platform SDK . In the rest of this section, the absolute path of this folder is referred to as <sdo-iot-platform-sdk-root>. Build IOT Platform SDK by following the steps mentioned in the README . Alternatively, run the following command: mvn clean install The build creates and copies the OCS, OPS and To0Scheduler WAR/JAR files into their respective <sdo-iot-platform-sdk-root>/demo directory. <sdo-iot-platform-sdk-root> has the following directories, which are used during the IOT Platform SDK execution. <sdo-iot-platform-sdk-root>/demo: The IOT Platform SDK root directory containing Docker* files, configurations, and execution binaries: docker-compose.yml ocs/config/ ./run-ocs (Sample script and configuration to run the OCS) ops/config/ ./run-ops (Sample scripts and configuration to run the OPS) to0scheduler/config/ ./run-to0scheduler (Sample scripts and configuration to run the to0scheduler) The example instructions are executed under the Ubuntu* OS version 18.04. The device must have already completed the DeviceInitialization (DI) protocol, and an Owner must have been assigned to it using Supply Chain Toolkit. The resulting Ownership voucher(OV) must be moved from SCT into the OCS. Running the Demo Manually \u00b6 The demo can be run with the default properties for both the PRI and IOT Platform SDK components. Any configurations to be done, such as configuring proxies, properties or logs, should be done before starting the services. However, resources such as the Ownership Voucher, owner certificate and private keys, and others, can be pushed into the OCS after the services are started. Start the Simulated Rendezvous Service \u00b6 Open a new terminal window and start a virtual instance of the Rendezvous service shown as follows: $ cd <sdo-pri-root>/demo/rendezvous $ sh rendezvous This starts the following server to listen to incoming messages from the IOT Platform SDK and the simulated device. http://localhost:8040 (for To0Scheduler and Simulated Device messages). Start the To0scheduler Service \u00b6 Open a new terminal window and follow these steps to start the To0scheduler service: $ cd <sdo-iot-platform-sdk-root>/demo/to0scheduler/config $ sh run-to0scheduler Start the OCS Service \u00b6 Open a new terminal window and follow these steps to start the OCS service: $ cd <sdo-iot-platform-sdk-root>/demo/ocs/config $ sh run-ocs Start the OPS Service \u00b6 Open a new terminal window and follow these steps to start the OPS service: $ cd <sdo-iot-platform-sdk-root>/demo/ops/config $ sh run-ops Start the Device Simulation \u00b6 Open a new terminal window and follow these steps to start the device: $ cd <sdo-pri-root>/demo/device $ sh device After the device script completes successfully, there will be three new files created inside <sdo-pri-root>/demo/device: linux64.sh payload.bin result.txt During the onboarding process payload.bin and linux64.sh are downloaded from the Owner over an encrypted channel. This demonstrates that files can be downloaded from the OPS (Owner) and executed on the local device during the onboarding process. Once downloaded, linux64.sh is executed which in turn operates on the binary program payload.bin and creates the file result.txt: $ cat result.txt should output: Device onboarded successfully. To clean up onboarded files to rerun the demo: $ rm linux64.sh $ rm payload.bin $ rm result.txt Running the Simulation Using Docker* Compose Tool \u00b6 The demo can be run using the Docker* Compose tool for the IOT Platform SDK components. Any configuration, such as configuring proxies, properties or logs, should be done before starting the services. Start the Simulated Rendezvous Service \u00b6 Open a new terminal window and start a virtual instance of the Rendezvous service as per the steps described here : Start the IOT Platform SDK Services \u00b6 Open a new terminal window and start the IOT Platform SDK services: $ cd <sdo-iot-platform-sdk-root>/demo/ $ sudo docker-compose up This brings up the OCS, OPS, and To0Scheduler instances inside an Ubuntu-based Docker container. During this operation, everything under the Docker directory, including the configurations and binaries are copied into the built Docker containers. Only the directory 'ocs/config/db' and the file 'to0scheduler/config/redirect.properties', are configurable once the Docker container starts, to externalize the device information and values, and the TO1 OPS (owner) redirect information. If any changes are made to any of the files, other than the directory 'ocs/config/db' and the file 'to0scheduler/config/redirect.properties', both, the container and its image needs to be deleted and re-created again. Note When running the demo in a single machine, the ownership voucher must be created such that the IP address of the Rendezvous service is present, instead of 'localhost' in the Rendezvous information. Start the Device Simulation \u00b6 Open a new terminal window and start the device as per the steps described here . Once onboarded, the device will have the same files and behavior as mentioned above. Generating Ownership Voucher/Credential Pair \u00b6 Refer to the Supply Chain Tools Manufacturer Enablement Guide on steps to create Ownership Voucher/Credential pair. Working with Multiple Owner Key-Pair(s) \u00b6 The OCS instance handles multiple owner key-pair(s) using a Java* Keystore. Multiple owner key-pairs can be inserted into the keystore with different aliases. The listed key tool commands require a password to be entered. Enter the password whenever prompted. Note A sample keystore is provided in /demo/ocs/config/db/v1/creds/owner-keystore.p12. This is an example implementation for demo purposes and should be updated in production deployment. Generating Key-Pair for Owner Attestation \u00b6 Generating ECDSA Key-Pair for Owner Attestation \u00b6 Secure Device Onboard specification supports the National Institute of Standards and Technology (NIST) P-256 curve and P-384 types. Step 1: Generate the private key. Generate the NIST-256 key by running the following command: $ openssl ecparam -genkey -name secp256r1 -out eckey.pem Alternatively, generate the NIST-384 key by running the following command: $ openssl ecparam -genkey -name secp384r1 -out eckey.pem Step 2: Generate a self-signed certificate. Generate the self-signed certificate for the previously generated NIST-256 key as: $ openssl req -x509 -sha256 -nodes -days 3650 -key eckey.pem -out eccert.crt Alternatively, generate the self-signed certificate for the previously generated NIST-384 key as: $ openssl req -x509 -sha384 -nodes -days 3650 -key eckey.pem -out eccert.crt Step 3: Convert the key to public key cryptography standards (PKCS#8) format (optional): $ openssl pkcs8 -topk8 -nocrypt -in eckey.pem -out eckey.key Step 4: Create a certificate signing request to send for generating a certificate chain (optional): $ openssl x509 -x509toreq -in eccert.crt -out CSR.csr -signkey eckey.key Generating RSA Key-Pair for Owner Attestation \u00b6 Secure Device Onboard specification supports the RSA2048 Step 1: Generate the private key. Generate the NIST-256 key by running the following command: $ openssl genrsa -out rsakey.pem 2048 Step 2: Generate a self-signed certificate. Generate the self-signed certificate for the previously generated NIST-256 key as: $ openssl req -x509 -key rsakey.pem -days 365 -out rsacert.pem Inserting an Existing Owner's Certificate and Private Key into a Keystore \u00b6 Assuming that there is already an existing owner certificate named 'owner-certificate-1.pem' and the corresponding private key 'owner-private-key.pem', follow these steps to insert them as 'PrivateKeyEntry' into the keystore 'owner-keystore.p12': Step 1: Convert the certificate and private key into 'PKCS12' format: $ openssl pkcs12 -export -in owner-certificate-1.pem -inkey owner-private-key.pem -name owner_123 -out owner_pkcs.p12 Step 2: Import the above generated PKCS12 file into the existing owner keystore file 'owner-keystore.p12' located under /demo/ocs/config/db/v1/creds under the alias 'owner_123'. If the keystore file 'owner-keystore.p12' is not present, the keystore file is created afresh with the same name: $ keytool -importkeystore -destkeystore path/to/owner-keystore.p12 -srckeystore owner_pkcs.p12 -srcstoretype PKCS12 -alias owner_123 Note The password entered in Step 1 to generate the owner_pkcs.p12 must be the same as that of owner-keystore.p12, that is, the password of the newly created keystore must match the existing keystore where it will be imported to. This is because, in the current OCS implementation, the password of the owner-keystore.p12 is used to access the imported keys from the Step-1. As a result, every keystore being imported will have the same password as that of the destination keystore. Exporting an Existing Owner's Certificate from Keystore \u00b6 Assuming that there is an existing owner's certificate and private key stored in the keystore as a PrivateKeyEntry under the alias 'owner_123', run the following command to extract the owner's certificate into \\<owner_certificate.pem>: Step 1: Get the list of key-pairs, along with their respective aliases, from the keystore: $ keytool -list -v -keystore path/to/owner-keystore.p12 Step 2: Export the certificate from the keystore using any of the aliases present in the keystore : $ keytool -exportcert -alias owner_123 -file <owner_certificate.pem> -rfc -keystore /path/to/owner-keystore.p12 Removing an Existing Owner's Key-Pair from Keystore \u00b6 Assuming that there is an existing owner's certificate and private key stored in the keystore as a PrivateKeyEntry under the alias 'owner_123', run the following command to remove the key-pair corresponding to the alias: $ keytool -delete -alias owner_123 -keystore owner-keystore.p12 IOT Platform SDK and PRI Component Configuration \u00b6 When the IOT Platform SDK Demo is running, log messages are displayed on the terminal window. Some log messages may be truncated for better readability, but sufficient information is provided to compare against the logs generated during a simulation. Configuring Proxies \u00b6 Update the proxy information specified by the properties mentioned below: http_proxy_host: Represents the http proxy hostname. Typically, it is an IP address or domain name in the proxy URL. http_proxy_port: Represents the http proxy port. Typically, it is the port number in the proxy URL. https_proxy_host: Represents the https proxy hostname. Typically,it is an IP address or domain name in the proxy URL. https_proxy_port: Represents the https proxy port. Typically, it is the port number in the proxy URL. Specify combination the hostname and port information together for either http, https, or both. For example, if the http proxy is 'http://myproxy.com:900', then the following updates will be made to the properties: http_proxy_host: myproxy.com http_proxy_port: 900 If no proxy needs to be specified, leave the fields blank. These properties are present in the following script files: <sdo-iot-platform-sdk-root>/demo/ops/config/run-ops <sdo-iot-platform-sdk-root>/demo/ocs/config/run-ocs <sdo-iot-platform-sdk-root>/demo/to0scheduler/config/run-to0scheduler Configuring Logs \u00b6 Both the PRI and IOT Platform SDK utilizes Spring logback for logging. Each demo service has logback-spring.xml in its directory that configures the logging to be appended to the console by default. Log configuration is located in the following directories: <sdo-pri-root>/demo/rendezvous/logback-spring.xml <sdo-iot-platform-sdk-root>/demo/to0scheduler/config/logback-spring.xml <sdo-iot-platform-sdk-root>/demo/ocs/config/logback-spring.xml <sdo-iot-platform-sdk-root>/demo/ops/config/logback-spring.xml <sdo-pri-root>/demo/device/logback-spring.xml The logback-spring.xml can be modified to disable logging or use file only logging as shown below: Sample logback-spring.xml for logging to a file as well as on a console: <?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?\\> <configuration\\> <appender name=\\\"FILE\\\" class=\\\"ch.qos.logback.core.FileAppender\\\"\\> <file\\>log-owner.txt\\</file\\> <append\\>false\\</append\\> <encoder\\> <pattern\\>%d{dd-MM-yyyy HH:mm:ss.SSS} %highlight(%-5level) %magenta(\\[%thread\\]) %logger{36}.%M - %msg%n\\</pattern\\> </encoder\\> </appender\\> <appender name=\\\"STDOUT\\\" class=\\\"ch.qos.logback.core.ConsoleAppender\\\"\\> <encoder\\> <pattern\\>%d{dd-MM-yyyy HH:mm:ss.SSS} %highlight(%-5level) %magenta(\\[%thread\\]) %logger{36}.%M - %msg%n\\</pattern\\> </encoder\\> </appender\\> <root level=\\\"info\\\"\\> <appender-ref ref=\\\"STDOUT\\\" /\\> <appender-ref ref=\\\"FILE\\\" /\\> </root\\> </configuration\\> The following message is logged if the logback-spring.xml configuration file is used. For Rendezvous Service: org.sdo.cri.rendezvous.RendezvousApp.logStarting - Starting RendezvousApp For Owner Companion Service: o.s.i.ocs.fsimpl.fs.FsApplication.logStarting - Starting FsApplication For Owner Protocol Service: o.s.i.ops.opsimpl.OpsApplication.logStarting - Starting OpsApplication For To0Scheduler Service: o.s.i.t.t.To0ServiceApplication.logStarting - Starting To0ServiceApplication For Device Simulation: org.sdo.cri.device.DeviceApp.logStarting - Starting DeviceApp Configuring the Properties File \u00b6 Each service has its own configuration file called application.properties. When each service starts, it will read the properties file in its current directory. For this simulation and during development, the properties file is writable. However, in a production environment, change the permissions of the properties file to read-only for added security. The description for the configuration settings can be found in the properties associated with each service. PRI Rendezvous Service Properties: <sdo-pri-root>/demo/rendezvous/application.properties PRI Device Service Properties: <sdo-pri-root>/demo/device/application.properties to0scheduler Service Properties: <sdo-iot-platform-sdk-root>/demo/to0scheduler/config/application.properties OPS Service Properties: <sdo-iot-platform-sdk-root>/demo/ops/config/application.properties OCS Service Properties: <sdo-iot-platform-sdk-root>/demo/ocs/config/application.properties For information on all the properties for PRI components, refer to the comments in the specific properties files, or the README. For information on all the properties for IOT Platform SDK components, refer to the comments in the specific properties files. Setting up Resources for OCS \u00b6 The resources used in the OCS implementation can be found in: <sdo-iot-platform-sdk-root>/demo/ocs/config/db/v1 The current OCS implementation supports multiple owner key-pairs with the use of PKCS12 keystore that contains each owner's certificate and private key as a PrivateKeyEntry. The owner keystore file named 'owner-keystore.p12' is located under: <sdo-iot-platform-sdk-root>/demo/ocs/config/db/v1/creds Before the onboarding of the device, the certificate and private key of the corresponding owner's public key that the OV is assigned to, must be imported into the owner keystore. The device-specific information for every device can be found in: <sdo-iot-platform-sdk-root>/demo/ocs/config/db/v1/devices The above directory contains several subdirectories, each representing a device, and named with the device's GUID. Each subdirectory is structured as: voucher.json : Contains the contents of the device's ownership voucher file. state.json : Contains the device state in the following form: { \"to2Error\": \"TO2 error message of the form {\"ec\":\"\",\"em\":\"\",\"emsg\":\"\"}\", \"to2Timestamp\": Timestamp at which TO2 was completed, \"to0Error\": \"TO0 error message of the form {\"ec\":\"\",\"em\":\"\",\"emsg\":\"\"}\", \"to0Timestamp\": \"Timestamp at which last TO0 was successful\", \"to2State\": \"State at which TO2 is. Can be one of to2begin/to2end/to2error\", \"to0Ws\": \"Integer value representing the number of seconds after which the last TO0 expires \", \"g3\" : \"New GUID of the device\" } Note To re-trigger TO0 scheduling for a device, delete the device's state.json file. svi.json : An array of objects, where each object provides information about the resource (in our case, a file) that will be read/fetched to get service-info. Depending on the implementation of the OCS, the resource can be anything. For example, a database implementation of OCS may have one or more rows representing a resource. The 'valueId' represents a resource on the OCS, which is used by the OPS to fetch resources one-by-one in subsequent requests. Depending on the message field (msg), the 'valueId' in each object is representative of: write -- The ID of the resource (script, binaries, and others) that is sent to the device. In this implementation, the name of the service-info file. filedesc -- The ID of the resource that contains the name to be given to the file once it is transferred. In this implementation, the name of the file whose value is the name of the file by which it is saved at the device. exec -- The ID of the resource that contains the command that will be executed at the device. In this implementation, the name of the file whose value is the command to be executed at the device. The array must be ordered such that the 'filedesc' and 'write' objects are one after the other pair-wise, followed by the 'exec' commands. { \"module\": \"Module name\", \"msg\": \"Service-info type. One of filedesc, exec, write\", \"valueLen\": Length of the file to be transferred, \"valueId\": \"An opaque-id representing a resource (in this case, file) that contains the actual service-info value\", \"enc\": \"Encoding to be used. One of either base64, or, ascii\" } psi.json : Represents the pre-service info as key-value pairs that get pushed to the device. It is of the form: { \"module\": \"Module name\", \"msg\": \"Any key\", \"value\": \"Any value\" } dvi.json : Represents the device service-info. It is of the same form as psi.json. The service-info values as listed by svi.json that gets sent to device during onboarding, are found in <sdo-iot-platform-sdk-root>/demo/ocs/config/db/v1/values The demo onboarding process demonstrates download of a script file and a binary file. Once the files are downloaded, the script validates the checksum of the binary file and creates result.txt to store the result. These files can be replaced to customize the downloading process. For example, the following JavaScript* Object Notation (JSON) represents that a file 'package.sh' will be sent to the device, and will be renamed to the value stored in the file 'package_name', say 'linux64.sh'. Similarly, the file 'payload.bin' will be downloaded to the device and will be renamed to the value stored in the file 'payload_name', say 'payload.bin'. Finally, the value of the file 'sh-linux64', '/bin/sh linux64.sh', will be executed as command in the device. [ { \"module\": \"sdo_sys\", \"msg\": \"filedesc\", \"valueLen\": -1, \"valueId\": \"package_name\", \"enc\": \"base64\" }, { \"module\": \"sdo_sys\", \"msg\": \"write\", \"valueLen\": -1, \"valueId\": \"package.sh\", \"enc\": \"base64\" }, { \"module\": \"sdo_sys\", \"msg\": \"filedesc\", \"valueLen\": -1, \"valueId\": \"payload_name\", \"enc\": \"base64\" }, { \"module\": \"sdo_sys\", \"msg\": \"write\", \"valueLen\": -1, \"valueId\": \"payload.bin\", \"enc\": \"base64\" }, { \"module\": \"sdo_sys\", \"msg\": \"exec\", \"valueLen\": -1, \"valueId\": \"sh-linux64\", \"enc\": \"base64\" } ] Note When running the services as Docker*, only <sdo-iot-platform-sdk-root>/demo/ocs/config/db and <sdo-iot-platform-sdk-root>/demo/to0scheduler/config/redirect.properties, are configurable. Given an OwnershipVoucher file with a unique deviceId/GUID, the following needs to be done to add it as a device in the directory <sdo-iot-platform-sdk-root>/demo/ocs/config/db/v1/devices: Create a folder named deviceId/GUID. Rename the Owner voucher file to 'voucher.json'. Move this file to the newly created directory. Create the psi.json and svi.json files under the same directory. A sample of both files are present at the sample device directory '1fae14fb-deca-405a-abdd-b25391b9d932'. The following is a sample Python* script that, given an Owner voucher file as an argument, extracts the GUID and creates the previously mentioned device directory structure. This sample script operates under the assumption that both the script and voucher files are placed at \\ /demo/ocs/config/db/v1/devices, and that this is the current working directory: The svi.json and psi.json files are copied from the sample device \\ /demo/ocs/config/db/v1/devices/1fae14fb-deca-405a-abdd-b25391b9d932, to the new device directory. The input voucher file is moved to the new device directory and is renamed as voucher.json. import sys import os import os.path import json import base64 import codecs import uuid import shutil # read the Owner Voucher (Ownership Voucher) from the /devices directory voucherFile=open(sys.argv[1], 'r') voucher=json.load(voucherFile) voucherFile.close() # read 'g' field encodedGuid=voucher['oh']['g'] # base64 decode and convert to hex to generate the guid guid = codecs.encode(base64.b64decode(encodedGuid), 'hex') # format as per UUID standards guid = uuid.UUID(guid) print \"The GUID of the input owner voucher is - \" + str(guid) # create directory with the 'guid' as its name try: os.mkdir(str(guid)) except OSError: print (\"Failed to create directory %s\" % guid) else: print (\"Successfully created the device directory for GUID %s \" % guid) # source directory copyFromPath = os.path.basename(\"1fae14fb-deca-405a-abdd-b25391b9d932\") # destination directory copyToPath = os.path.basename(str(guid)) if os.path.isdir(copyToPath): # move the owner voucher represented by sys.argv[1] and rename it to voucher.json shutil.move(sys.argv[1], os.path.join(copyToPath, 'voucher.json')) print \"Generated voucher.json at \" + copyToPath + \" with contents of input voucher \" + sys.argv[1] # copy svi.json shutil.copyfile(os.path.join(copyFromPath, 'svi.json'), os.path.join(copyToPath, 'svi.json')) print \"Copied default svi.json from device directory \" + copyFromPath + \" to directory \" + copyToPath # copy psi.json shutil.copyfile(os.path.join(copyFromPath, 'psi.json'), os.path.join(copyToPath, 'psi.json')) print \"Copied default psi.json from device directory \" + copyFromPath + \" to directory \" + copyToPath For example, suppose the name of the script is add-device.py and the name of the owner voucher file to be added as a device is device.json having GUID fad58be5-c7ba-417c-b1bd-eb9703ea8016. Then, the script execution would look like below. At the end of the script execution, a device directory named fad58be5-c7ba-417c-b1bd-eb9703ea8016 will be created at \\ /demo/ocs/config/db/v1/devices with files voucher.json, svi.json, and psi.json as its contents. $ cd <sdo-iot-platform-sdk-root>/demo/ocs/config/db/v1/devices $ cp path/to/device.json . $ python add-device.py device.json $ The GUID of the input owner voucher is - fad58be5-c7ba-417c-b1bd-eb9703ea8016 Successfully created the device directory for GUID fad58be5-c7ba-417c-b1bd-eb9703ea8016 Generated voucher.json at fad58be5-c7ba-417c-b1bd-eb9703ea8016 with contents of input voucher device.json Copied default svi.json from device directory 1fae14fb-deca-405a-abdd-b25391b9d932 to directory fad58be5-c7ba-417c-b1bd-eb9703ea8016 Copied default psi.json from device directory 1fae14fb-deca-405a-abdd-b25391b9d932 to directory fad58be5-c7ba-417c-b1bd-eb9703ea8016 Running the Owner Companion Service with HTTPS \u00b6 The provided reference implementation of Owner Companion Service, uses file-system as database. It sends REST call to To0Scheduler repeatedly at an interval (in seconds) specified by the property to0.scheduler.interval, at the URL defined by the property to0.rest.api. By default, the server is started using HTTPS. The keystore and truststore information can be configured, but the Mutual Transport Layer Security (TLS) authentication settings must be left untouched: server.ssl.key-store-type=PKCS12 (Key-store type, Configurable) server.ssl.trust-store-type=PKCS12 (Trust-store type, Configurable) server.ssl.key-store=keystore.p12 (Path to keystore file, Configurable, Must be replaced for production deployment) server.ssl.key-store-password=<password> (Keystore password, Configurable, Must be replaced for production deployment) server.ssl.trust-store=truststore (Path to truststore file, Configurable, Must be replaced for production deployment) server.ssl.trust-store-password=<password> (Truststore password, Configurable, Must be replaced for production deployment) server.ssl.client-auth=need (Force Mutual TLS. Do not change) server.ssl.ciphers=TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256 (Cipher suites to be used during TLS. Do not change) server.ssl.enabled-protocols=TLSv1.3 (TLS version. Do not change.) When starting the OCS, you can see the port(s) that the HTTPS server is listening to in the logs. o.s.b.w.e.tomcat.TomcatWebServer.start - Tomcat started on port(s): 9009 (https) with context path '' o.s.i.ocs.fsimpl.fs.FsApplication.logStarted - Started FsApplication in 7.792 seconds (JVM running for 9.125) Running the To0Scheduler with HTTPS for T00 \u00b6 The To0Scheduler service schedules the list of received device GUIDs from OCS, for TO0. During TO0 process, the To0Scheduler will provide the DNS, IP address, and port that the Secure Device Onboard-enabled devices must use for TO2. The To0Scheduler sends the Rendezvous server, the redirect URI that will be used by the device to send TO2 messages. This URI information is passed to the device during the TO1 process. When the device completes TO1, it uses the TO2 redirect URI to communicate with the Owner. The TO2 redirect information, namely, DNS, IP address, and port information of the Owner Protocol Service, is stored separately in the URI specified by the property inside application.properties: org.sdo.to0.ownersign.to1d.bo=./redirect.properties (Path to file containing redirect information, Configurable) By default, the redirect information is stored in the file in the file redirect.properties, that contains the following properties: dns=localhost ip=127.0.0.1 port=8042 Please see the file /demo/to0scheduler/config/redirect.properties for more information on these properties and their default values. As the TO0 scheduler runs, it will log the TO0 request and responses. On successful TO0, you see a Wait Second response, such as, ws:7200. This refers to the number of seconds the TO0 registration will be known to the Rendezvous Server. o.s.i.t.to0library.To0Scheduler.setDeviceForTo0 - Register OP: 1fae14fb-deca-405a-abdd-b25391b9d932 o.s.i.t.to0library.To0ClientSession.run - <200,{\"ws\":7200} o.s.i.t.t.To0SchedulerEventsImpl.onSuccess - TO0 done for the device having uuid 1fae14fb-deca-405a-abdd-b25391b9d932 The To0Scheduler communicates with the OCS at the URL defined by the property rest.api.server, defined in application.properties. Similar to OCS, the server is started using HTTPS, by default. The keystore and truststore information can be configured, but the Mutual TLS authentication settings must be left untouched. The properties are the same as that of OCS. When starting the to0scheduler service, you can see the port(s) that the HTTPS server is listening to in the logs. o.s.i.t.t.To0ServiceApplication.logStarting - Starting To0ServiceApplication o.s.b.w.e.tomcat.TomcatWebServer.start - Tomcat started on port(s): 8049 (https) with context path '' o.s.i.t.t.To0ServiceApplication.logStarted - Started To0ServiceApplication in 9.159 seconds (JVM running for 10.693) Starting the Owner Protocol Service with HTTP(S) for TO2 Process \u00b6 The Owner Protocol server starts a HTTP server by default to listen to incoming messages from the device for TO2, by using the configuration provided in the application.properties file. To start the service using HTTPS, refer to Enabling Transport Layer Security (TLS) during TO2 . It communicates with the OCS at the URL defined by the rest.api.server property, using the keystore, and trustore as specified in application.properties. client.ssl.key-store-type=PKCS12 (Key-store type, Configurable) client.ssl.trust-store-type=PKCS12 (Trust-store type, Configurable) client.ssl.key-store=keystore.p12 (Path to keystore file, Configurable, Must be replaced for production deployment) client.ssl.key-store-password=<password> (Keystore password, Configurable, Must be replaced for production deployment) client.ssl.trust-store=truststore (Path to truststore file, Configurable, Must be replaced for production deployment) client.ssl.trust-store-password=<password> (Truststore password, Configurable, Must be replaced for production deployment) The server.port property specifies the port at which the OPS listens to for TO2 protocol connections coming from devices enabled as a Secure Device Onboard client. When starting the owner, you can see the port(s) that the HTTP server is listening to in the logs. The Owner Protocol Service logs the following messages when the TO2 communication starts. o.s.i.o.to2library.Message40Handler.onPost - When the device sends Device Service-Info message, it is logged as shown below: o.s.i.o.to2library.Message46Handler.onPost - Once the TO2 is completed, the following messages are logged: o.s.i.o.to2library.Message50Handler.onPost - o.s.i.o.opsimpl.OpsOwnerEventHandler.call - TO2 complete for device with guid In addition, the file result.txt is created on the device containing following text: Device onboarded successfully. Enabling Transport Layer Security (TLS) during TO2 \u00b6 To run TO2 in TLS mode, follow the steps listed below. Step 1: Add the following properties to <sdo-iot-platform-sdk-root>/demo/ops/config/application.properties security.require-ssl=true server.ssl.key-store-type=PKCS12 server.ssl.key-store=ops-keystore.p12 server.ssl.key-store-password=123456 server.ssl.ciphers=TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256 server.ssl.enabled-protocols=TLSv1.3 The following properties pertaining to the keystore must always match with each other in the properties file. server.ssl.key-store-type matches client.ssl.key-store-type server.ssl.key-store matches client.ssl.key-store server.ssl.key-store-password matches client.ssl.key-store-password Step 2 (Optional): A new self-signed certificate and private key can be generated by generating keystore. Create the keystore by specifying the DNS and IP address of the host machine as the subject alternative name (SAN) entries. For example, if the owner is running on a machine with DNS as owner-protocol-service.com and IP address as 10.20.30.40, then the keystore can be created by running following command. $ keytool -genkeypair -keystore ops-keystore.p12 -storetype PKCS12 -storepass 123456 -alias tomcat -keyalg RSA -keysize 2048 -validity 99999 -dname \"CN=localhost, OU=Development, O=Company, L=Hillsboro, ST=Oregon, C=US\" -ext \"san=dns:www.owner-protocol-service.com,ip:10.20.30.40\" Step 3 (Optional, dependent on Step 2): Copy the generated keystore, keystore.p12 to <sdo-iot-platform-sdk-root>/demo/ops/config . Step 4: Export the certificate from any keystore file, say ops-keystore.p12, using following command. $ openssl pkcs12 -in ops-keystore.p12 -clcerts -nokeys -out tlscert.pem Step 5: Navigate to the \\$JAVA_HOME/jre/lib/security/ folder and import the generated certificate into the Java* device's truststore, so that the device can trust the Owner Protocol Service. $ keytool -import -alias tomcat -keystore cacerts -file <PATH_TO_CERT>/tlscert.pem Alternatively, to import the existing certificate into a separate truststore, run the following: $ keytool -import -file <PATH_TO_CERT>/tlscert.pem -alias <ALIAS_NAME> -keystore <PATH_TO_TRUSTSTORE_FILE> With these configurations in place, the OPS will enable TLS during TO2 communication. Note Sample keystore and truststore files are provided in <sdo-iot-platform-sdk-root>/demo/ocs/config/, <sdo-iot-platform-sdk-root>/demo/ops/config/, and /demo/to0scheduler/config/. This is an example implementation for demo purposes and should be updated in production deployment. Running the IOT Platform SDK Components on Separate Machines \u00b6 To run each IOT Platform SDK component in its own separate machine, the following updates must be made: Create OV/OC pair such that the DNS/IP of the rendezvous server is mentioned in these files as part of the rendezvous information. Refer to Generating Ownership Voucher/Credential Pair for steps to create such OV/OC pairs. Update the following properties at each component: At OCS <sdo-iot-platform-sdk-root>/demo/ocs/config/application.properties: to0.rest.api=https://<To0Scheduler-machine-IP-or-DNS>:<port>/v1/to0/devices At OPS <sdo-iot-platform-sdk-root>/demo/ops/config/application.properties : rest.api.server=https://<OCS-machine-IP-or-DNS>:<port>/ At To0Scheduler <sdo-iot-platform-sdk-root>/demo/to0scheduler/config/application.properties : rest.api.server=https://<OCS-machine-IP-or-DNS>:<port>/ <sdo-iot-platform-sdk-root>/demo/to0scheduler/config/redirect.properties : dns=<OPS-DNS-name> ip=<OPS-machine-IP> port=<OPS-port> The keystore and truststore files of each of the components: OCS, OPS and To0Scheduler needs to be updated. Both the keystore and truststore files must contain the certificates whose Common Name (CN) or the Subject Alternative Names (SAN) properties have the IP address and the DNS of the machine where the component is running. This is needed for hostname verification to succeed in the Mutual TLS handshake process. Refer to Enabling Transport Layer Security (TLS) during TO2 for steps to create such keystore files. Create a truststore file as follows: $ keytool \u2013import \u2013file path/to/certificate \u2013alias sampleCA \u2013keystore path/to/truststore Based on the component interactions, the truststore for each component must contains the following certificate entries: OCS truststore contains entries to accept certificates of OPS and To0Scheduler. OPS truststore contains entries to accept certifcates of OCS. To0Scheduler truststore contains entries to accept certifcates of OCS. For information on the properties that needs to be updated for using the newly created files, refer to the following sections: - Setting up Resources for OCS - Running the Owner Companion Service with HTTPS - Running the To0Scheduler with HTTPS for T00 Common Issues While Running the Demo \u00b6 Signature is Invalid during TO0 : This error occurs when the owner's certificate (and its public key) residing at the OCS in the owner keystore, does not match the public key present in the Ownership Voucher. To rectify this error, insert the owner key-pair at <sdo-iot-platform-sdk-root>/demo/ocs/config/db/v1/creds/owner-keystore.p12 per the steps outlined here . Refer to the properties file for details on properties to be updated. The following is a sample error log at To0Scheduler: o.s.i.t.t.To0SignatureServiceFactoryImpl.lambda$sign$0 - Obtaining signature from OCS o.s.i.t.t.RestClient.signatureOperation - Error occurred while getting the signature for 59ec2905-e715-4bec-ad8f-ad5610d64895. 500 o.s.i.t.t.To0SignatureServiceFactoryImpl.lambda$sign$0 - Unable to get signature for 59ec2905-e715-4bec-ad8f-ad5610d64895 o.s.i.t.t.To0ClientSession.run - <POST http://10.0.0.1:8001/mp/113/msg/22,{\"to0d\":\u2026\u2026\u2026 o.s.i.t.t.To0ScheduledClientSession.call - {\"ec\":3,\"emsg\":255,\"em\":\"Signature of owner message is invalid.\"} c.i.s.o.t.To0SchedulerEventsImpl.onFailure - TO0 failed for the device having uuid 59ec2905-e715-4bec-ad8f-ad5610d64895.","title":"Running The Demo"},{"location":"iot-platform-sdk/running-the-demo/#running-demos-with-the-iot-platform-sdk","text":"","title":"Running Demos with the IOT Platform SDK"},{"location":"iot-platform-sdk/running-the-demo/#running-the-iot-platform-sdk-with-the-pri","text":"Secure Device Onboard provides a Protocol Reference Implementation (PRI) for the following Secure Device Onboard components: Rendezvous and Device. Both of these components are required to perform an end-to-end execution of the Secure Device Onboard protocol. To test integration of Secure Device Onboard with the IOT Platform SDK solution, the simulated Device and Rendezvous components of the PRI can be used.","title":"Running the IoT Platform SDK with the PRI"},{"location":"iot-platform-sdk/running-the-demo/#pre-requisites-for-running-the-demo","text":"Clone the source repository of the Protocol Reference Implementation (PRI). In the rest of this section, the absolute path of this folder is referred to as <sdo-pri-root>. Build the PRI by following the steps mentioned in its README . Alternatively, run the command mvn package The build creates and copies the Rendezvous and Device WAR/JAR files into their respective \\<sdo-pri-root>/demo directory. <sdo-pri-root> has the following directories, which are used during the IOT Platform SDK execution. <sdo-pri-root>/demo: Sample scripts and configuration to run the demonstration of an onboarding process are located in the following directories: README.md rendezvous/ ./rendezvous (Sample script to start rendezvous) device/ ./device (Sample script to start device) Clone the source repository of the IoT Platform SDK . In the rest of this section, the absolute path of this folder is referred to as <sdo-iot-platform-sdk-root>. Build IOT Platform SDK by following the steps mentioned in the README . Alternatively, run the following command: mvn clean install The build creates and copies the OCS, OPS and To0Scheduler WAR/JAR files into their respective <sdo-iot-platform-sdk-root>/demo directory. <sdo-iot-platform-sdk-root> has the following directories, which are used during the IOT Platform SDK execution. <sdo-iot-platform-sdk-root>/demo: The IOT Platform SDK root directory containing Docker* files, configurations, and execution binaries: docker-compose.yml ocs/config/ ./run-ocs (Sample script and configuration to run the OCS) ops/config/ ./run-ops (Sample scripts and configuration to run the OPS) to0scheduler/config/ ./run-to0scheduler (Sample scripts and configuration to run the to0scheduler) The example instructions are executed under the Ubuntu* OS version 18.04. The device must have already completed the DeviceInitialization (DI) protocol, and an Owner must have been assigned to it using Supply Chain Toolkit. The resulting Ownership voucher(OV) must be moved from SCT into the OCS.","title":"Pre-requisites for Running the Demo"},{"location":"iot-platform-sdk/running-the-demo/#running-the-demo-manually","text":"The demo can be run with the default properties for both the PRI and IOT Platform SDK components. Any configurations to be done, such as configuring proxies, properties or logs, should be done before starting the services. However, resources such as the Ownership Voucher, owner certificate and private keys, and others, can be pushed into the OCS after the services are started.","title":"Running the Demo Manually"},{"location":"iot-platform-sdk/running-the-demo/#start-the-simulated-rendezvous-service","text":"Open a new terminal window and start a virtual instance of the Rendezvous service shown as follows: $ cd <sdo-pri-root>/demo/rendezvous $ sh rendezvous This starts the following server to listen to incoming messages from the IOT Platform SDK and the simulated device. http://localhost:8040 (for To0Scheduler and Simulated Device messages).","title":"Start the Simulated Rendezvous Service"},{"location":"iot-platform-sdk/running-the-demo/#start-the-to0scheduler-service","text":"Open a new terminal window and follow these steps to start the To0scheduler service: $ cd <sdo-iot-platform-sdk-root>/demo/to0scheduler/config $ sh run-to0scheduler","title":"Start the To0scheduler Service"},{"location":"iot-platform-sdk/running-the-demo/#start-the-ocs-service","text":"Open a new terminal window and follow these steps to start the OCS service: $ cd <sdo-iot-platform-sdk-root>/demo/ocs/config $ sh run-ocs","title":"Start the OCS Service"},{"location":"iot-platform-sdk/running-the-demo/#start-the-ops-service","text":"Open a new terminal window and follow these steps to start the OPS service: $ cd <sdo-iot-platform-sdk-root>/demo/ops/config $ sh run-ops","title":"Start the OPS Service"},{"location":"iot-platform-sdk/running-the-demo/#start-the-device-simulation","text":"Open a new terminal window and follow these steps to start the device: $ cd <sdo-pri-root>/demo/device $ sh device After the device script completes successfully, there will be three new files created inside <sdo-pri-root>/demo/device: linux64.sh payload.bin result.txt During the onboarding process payload.bin and linux64.sh are downloaded from the Owner over an encrypted channel. This demonstrates that files can be downloaded from the OPS (Owner) and executed on the local device during the onboarding process. Once downloaded, linux64.sh is executed which in turn operates on the binary program payload.bin and creates the file result.txt: $ cat result.txt should output: Device onboarded successfully. To clean up onboarded files to rerun the demo: $ rm linux64.sh $ rm payload.bin $ rm result.txt","title":"Start the Device Simulation"},{"location":"iot-platform-sdk/running-the-demo/#running-the-simulation-using-docker-compose-tool","text":"The demo can be run using the Docker* Compose tool for the IOT Platform SDK components. Any configuration, such as configuring proxies, properties or logs, should be done before starting the services.","title":"Running the Simulation Using Docker* Compose Tool"},{"location":"iot-platform-sdk/running-the-demo/#start-the-simulated-rendezvous-service_1","text":"Open a new terminal window and start a virtual instance of the Rendezvous service as per the steps described here :","title":"Start the Simulated Rendezvous Service"},{"location":"iot-platform-sdk/running-the-demo/#start-the-iot-platform-sdk-services","text":"Open a new terminal window and start the IOT Platform SDK services: $ cd <sdo-iot-platform-sdk-root>/demo/ $ sudo docker-compose up This brings up the OCS, OPS, and To0Scheduler instances inside an Ubuntu-based Docker container. During this operation, everything under the Docker directory, including the configurations and binaries are copied into the built Docker containers. Only the directory 'ocs/config/db' and the file 'to0scheduler/config/redirect.properties', are configurable once the Docker container starts, to externalize the device information and values, and the TO1 OPS (owner) redirect information. If any changes are made to any of the files, other than the directory 'ocs/config/db' and the file 'to0scheduler/config/redirect.properties', both, the container and its image needs to be deleted and re-created again. Note When running the demo in a single machine, the ownership voucher must be created such that the IP address of the Rendezvous service is present, instead of 'localhost' in the Rendezvous information.","title":"Start the IOT Platform SDK Services"},{"location":"iot-platform-sdk/running-the-demo/#start-the-device-simulation_1","text":"Open a new terminal window and start the device as per the steps described here . Once onboarded, the device will have the same files and behavior as mentioned above.","title":"Start the Device Simulation"},{"location":"iot-platform-sdk/running-the-demo/#generating-ownership-vouchercredential-pair","text":"Refer to the Supply Chain Tools Manufacturer Enablement Guide on steps to create Ownership Voucher/Credential pair.","title":"Generating Ownership Voucher/Credential Pair"},{"location":"iot-platform-sdk/running-the-demo/#working-with-multiple-owner-key-pairs","text":"The OCS instance handles multiple owner key-pair(s) using a Java* Keystore. Multiple owner key-pairs can be inserted into the keystore with different aliases. The listed key tool commands require a password to be entered. Enter the password whenever prompted. Note A sample keystore is provided in /demo/ocs/config/db/v1/creds/owner-keystore.p12. This is an example implementation for demo purposes and should be updated in production deployment.","title":"Working with Multiple Owner Key-Pair(s)"},{"location":"iot-platform-sdk/running-the-demo/#generating-key-pair-for-owner-attestation","text":"","title":"Generating Key-Pair for Owner Attestation"},{"location":"iot-platform-sdk/running-the-demo/#generating-ecdsa-key-pair-for-owner-attestation","text":"Secure Device Onboard specification supports the National Institute of Standards and Technology (NIST) P-256 curve and P-384 types. Step 1: Generate the private key. Generate the NIST-256 key by running the following command: $ openssl ecparam -genkey -name secp256r1 -out eckey.pem Alternatively, generate the NIST-384 key by running the following command: $ openssl ecparam -genkey -name secp384r1 -out eckey.pem Step 2: Generate a self-signed certificate. Generate the self-signed certificate for the previously generated NIST-256 key as: $ openssl req -x509 -sha256 -nodes -days 3650 -key eckey.pem -out eccert.crt Alternatively, generate the self-signed certificate for the previously generated NIST-384 key as: $ openssl req -x509 -sha384 -nodes -days 3650 -key eckey.pem -out eccert.crt Step 3: Convert the key to public key cryptography standards (PKCS#8) format (optional): $ openssl pkcs8 -topk8 -nocrypt -in eckey.pem -out eckey.key Step 4: Create a certificate signing request to send for generating a certificate chain (optional): $ openssl x509 -x509toreq -in eccert.crt -out CSR.csr -signkey eckey.key","title":"Generating ECDSA Key-Pair for Owner Attestation"},{"location":"iot-platform-sdk/running-the-demo/#generating-rsa-key-pair-for-owner-attestation","text":"Secure Device Onboard specification supports the RSA2048 Step 1: Generate the private key. Generate the NIST-256 key by running the following command: $ openssl genrsa -out rsakey.pem 2048 Step 2: Generate a self-signed certificate. Generate the self-signed certificate for the previously generated NIST-256 key as: $ openssl req -x509 -key rsakey.pem -days 365 -out rsacert.pem","title":"Generating RSA Key-Pair for Owner Attestation"},{"location":"iot-platform-sdk/running-the-demo/#inserting-an-existing-owners-certificate-and-private-key-into-a-keystore","text":"Assuming that there is already an existing owner certificate named 'owner-certificate-1.pem' and the corresponding private key 'owner-private-key.pem', follow these steps to insert them as 'PrivateKeyEntry' into the keystore 'owner-keystore.p12': Step 1: Convert the certificate and private key into 'PKCS12' format: $ openssl pkcs12 -export -in owner-certificate-1.pem -inkey owner-private-key.pem -name owner_123 -out owner_pkcs.p12 Step 2: Import the above generated PKCS12 file into the existing owner keystore file 'owner-keystore.p12' located under /demo/ocs/config/db/v1/creds under the alias 'owner_123'. If the keystore file 'owner-keystore.p12' is not present, the keystore file is created afresh with the same name: $ keytool -importkeystore -destkeystore path/to/owner-keystore.p12 -srckeystore owner_pkcs.p12 -srcstoretype PKCS12 -alias owner_123 Note The password entered in Step 1 to generate the owner_pkcs.p12 must be the same as that of owner-keystore.p12, that is, the password of the newly created keystore must match the existing keystore where it will be imported to. This is because, in the current OCS implementation, the password of the owner-keystore.p12 is used to access the imported keys from the Step-1. As a result, every keystore being imported will have the same password as that of the destination keystore.","title":"Inserting an Existing Owner's Certificate and Private Key into a Keystore"},{"location":"iot-platform-sdk/running-the-demo/#exporting-an-existing-owners-certificate-from-keystore","text":"Assuming that there is an existing owner's certificate and private key stored in the keystore as a PrivateKeyEntry under the alias 'owner_123', run the following command to extract the owner's certificate into \\<owner_certificate.pem>: Step 1: Get the list of key-pairs, along with their respective aliases, from the keystore: $ keytool -list -v -keystore path/to/owner-keystore.p12 Step 2: Export the certificate from the keystore using any of the aliases present in the keystore : $ keytool -exportcert -alias owner_123 -file <owner_certificate.pem> -rfc -keystore /path/to/owner-keystore.p12","title":"Exporting an Existing Owner's Certificate from Keystore"},{"location":"iot-platform-sdk/running-the-demo/#removing-an-existing-owners-key-pair-from-keystore","text":"Assuming that there is an existing owner's certificate and private key stored in the keystore as a PrivateKeyEntry under the alias 'owner_123', run the following command to remove the key-pair corresponding to the alias: $ keytool -delete -alias owner_123 -keystore owner-keystore.p12","title":"Removing an Existing Owner's Key-Pair from Keystore"},{"location":"iot-platform-sdk/running-the-demo/#iot-platform-sdk-and-pri-component-configuration","text":"When the IOT Platform SDK Demo is running, log messages are displayed on the terminal window. Some log messages may be truncated for better readability, but sufficient information is provided to compare against the logs generated during a simulation.","title":"IOT Platform SDK and PRI Component Configuration"},{"location":"iot-platform-sdk/running-the-demo/#configuring-proxies","text":"Update the proxy information specified by the properties mentioned below: http_proxy_host: Represents the http proxy hostname. Typically, it is an IP address or domain name in the proxy URL. http_proxy_port: Represents the http proxy port. Typically, it is the port number in the proxy URL. https_proxy_host: Represents the https proxy hostname. Typically,it is an IP address or domain name in the proxy URL. https_proxy_port: Represents the https proxy port. Typically, it is the port number in the proxy URL. Specify combination the hostname and port information together for either http, https, or both. For example, if the http proxy is 'http://myproxy.com:900', then the following updates will be made to the properties: http_proxy_host: myproxy.com http_proxy_port: 900 If no proxy needs to be specified, leave the fields blank. These properties are present in the following script files: <sdo-iot-platform-sdk-root>/demo/ops/config/run-ops <sdo-iot-platform-sdk-root>/demo/ocs/config/run-ocs <sdo-iot-platform-sdk-root>/demo/to0scheduler/config/run-to0scheduler","title":"Configuring Proxies"},{"location":"iot-platform-sdk/running-the-demo/#configuring-logs","text":"Both the PRI and IOT Platform SDK utilizes Spring logback for logging. Each demo service has logback-spring.xml in its directory that configures the logging to be appended to the console by default. Log configuration is located in the following directories: <sdo-pri-root>/demo/rendezvous/logback-spring.xml <sdo-iot-platform-sdk-root>/demo/to0scheduler/config/logback-spring.xml <sdo-iot-platform-sdk-root>/demo/ocs/config/logback-spring.xml <sdo-iot-platform-sdk-root>/demo/ops/config/logback-spring.xml <sdo-pri-root>/demo/device/logback-spring.xml The logback-spring.xml can be modified to disable logging or use file only logging as shown below: Sample logback-spring.xml for logging to a file as well as on a console: <?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?\\> <configuration\\> <appender name=\\\"FILE\\\" class=\\\"ch.qos.logback.core.FileAppender\\\"\\> <file\\>log-owner.txt\\</file\\> <append\\>false\\</append\\> <encoder\\> <pattern\\>%d{dd-MM-yyyy HH:mm:ss.SSS} %highlight(%-5level) %magenta(\\[%thread\\]) %logger{36}.%M - %msg%n\\</pattern\\> </encoder\\> </appender\\> <appender name=\\\"STDOUT\\\" class=\\\"ch.qos.logback.core.ConsoleAppender\\\"\\> <encoder\\> <pattern\\>%d{dd-MM-yyyy HH:mm:ss.SSS} %highlight(%-5level) %magenta(\\[%thread\\]) %logger{36}.%M - %msg%n\\</pattern\\> </encoder\\> </appender\\> <root level=\\\"info\\\"\\> <appender-ref ref=\\\"STDOUT\\\" /\\> <appender-ref ref=\\\"FILE\\\" /\\> </root\\> </configuration\\> The following message is logged if the logback-spring.xml configuration file is used. For Rendezvous Service: org.sdo.cri.rendezvous.RendezvousApp.logStarting - Starting RendezvousApp For Owner Companion Service: o.s.i.ocs.fsimpl.fs.FsApplication.logStarting - Starting FsApplication For Owner Protocol Service: o.s.i.ops.opsimpl.OpsApplication.logStarting - Starting OpsApplication For To0Scheduler Service: o.s.i.t.t.To0ServiceApplication.logStarting - Starting To0ServiceApplication For Device Simulation: org.sdo.cri.device.DeviceApp.logStarting - Starting DeviceApp","title":"Configuring Logs"},{"location":"iot-platform-sdk/running-the-demo/#configuring-the-properties-file","text":"Each service has its own configuration file called application.properties. When each service starts, it will read the properties file in its current directory. For this simulation and during development, the properties file is writable. However, in a production environment, change the permissions of the properties file to read-only for added security. The description for the configuration settings can be found in the properties associated with each service. PRI Rendezvous Service Properties: <sdo-pri-root>/demo/rendezvous/application.properties PRI Device Service Properties: <sdo-pri-root>/demo/device/application.properties to0scheduler Service Properties: <sdo-iot-platform-sdk-root>/demo/to0scheduler/config/application.properties OPS Service Properties: <sdo-iot-platform-sdk-root>/demo/ops/config/application.properties OCS Service Properties: <sdo-iot-platform-sdk-root>/demo/ocs/config/application.properties For information on all the properties for PRI components, refer to the comments in the specific properties files, or the README. For information on all the properties for IOT Platform SDK components, refer to the comments in the specific properties files.","title":"Configuring the Properties File"},{"location":"iot-platform-sdk/running-the-demo/#setting-up-resources-for-ocs","text":"The resources used in the OCS implementation can be found in: <sdo-iot-platform-sdk-root>/demo/ocs/config/db/v1 The current OCS implementation supports multiple owner key-pairs with the use of PKCS12 keystore that contains each owner's certificate and private key as a PrivateKeyEntry. The owner keystore file named 'owner-keystore.p12' is located under: <sdo-iot-platform-sdk-root>/demo/ocs/config/db/v1/creds Before the onboarding of the device, the certificate and private key of the corresponding owner's public key that the OV is assigned to, must be imported into the owner keystore. The device-specific information for every device can be found in: <sdo-iot-platform-sdk-root>/demo/ocs/config/db/v1/devices The above directory contains several subdirectories, each representing a device, and named with the device's GUID. Each subdirectory is structured as: voucher.json : Contains the contents of the device's ownership voucher file. state.json : Contains the device state in the following form: { \"to2Error\": \"TO2 error message of the form {\"ec\":\"\",\"em\":\"\",\"emsg\":\"\"}\", \"to2Timestamp\": Timestamp at which TO2 was completed, \"to0Error\": \"TO0 error message of the form {\"ec\":\"\",\"em\":\"\",\"emsg\":\"\"}\", \"to0Timestamp\": \"Timestamp at which last TO0 was successful\", \"to2State\": \"State at which TO2 is. Can be one of to2begin/to2end/to2error\", \"to0Ws\": \"Integer value representing the number of seconds after which the last TO0 expires \", \"g3\" : \"New GUID of the device\" } Note To re-trigger TO0 scheduling for a device, delete the device's state.json file. svi.json : An array of objects, where each object provides information about the resource (in our case, a file) that will be read/fetched to get service-info. Depending on the implementation of the OCS, the resource can be anything. For example, a database implementation of OCS may have one or more rows representing a resource. The 'valueId' represents a resource on the OCS, which is used by the OPS to fetch resources one-by-one in subsequent requests. Depending on the message field (msg), the 'valueId' in each object is representative of: write -- The ID of the resource (script, binaries, and others) that is sent to the device. In this implementation, the name of the service-info file. filedesc -- The ID of the resource that contains the name to be given to the file once it is transferred. In this implementation, the name of the file whose value is the name of the file by which it is saved at the device. exec -- The ID of the resource that contains the command that will be executed at the device. In this implementation, the name of the file whose value is the command to be executed at the device. The array must be ordered such that the 'filedesc' and 'write' objects are one after the other pair-wise, followed by the 'exec' commands. { \"module\": \"Module name\", \"msg\": \"Service-info type. One of filedesc, exec, write\", \"valueLen\": Length of the file to be transferred, \"valueId\": \"An opaque-id representing a resource (in this case, file) that contains the actual service-info value\", \"enc\": \"Encoding to be used. One of either base64, or, ascii\" } psi.json : Represents the pre-service info as key-value pairs that get pushed to the device. It is of the form: { \"module\": \"Module name\", \"msg\": \"Any key\", \"value\": \"Any value\" } dvi.json : Represents the device service-info. It is of the same form as psi.json. The service-info values as listed by svi.json that gets sent to device during onboarding, are found in <sdo-iot-platform-sdk-root>/demo/ocs/config/db/v1/values The demo onboarding process demonstrates download of a script file and a binary file. Once the files are downloaded, the script validates the checksum of the binary file and creates result.txt to store the result. These files can be replaced to customize the downloading process. For example, the following JavaScript* Object Notation (JSON) represents that a file 'package.sh' will be sent to the device, and will be renamed to the value stored in the file 'package_name', say 'linux64.sh'. Similarly, the file 'payload.bin' will be downloaded to the device and will be renamed to the value stored in the file 'payload_name', say 'payload.bin'. Finally, the value of the file 'sh-linux64', '/bin/sh linux64.sh', will be executed as command in the device. [ { \"module\": \"sdo_sys\", \"msg\": \"filedesc\", \"valueLen\": -1, \"valueId\": \"package_name\", \"enc\": \"base64\" }, { \"module\": \"sdo_sys\", \"msg\": \"write\", \"valueLen\": -1, \"valueId\": \"package.sh\", \"enc\": \"base64\" }, { \"module\": \"sdo_sys\", \"msg\": \"filedesc\", \"valueLen\": -1, \"valueId\": \"payload_name\", \"enc\": \"base64\" }, { \"module\": \"sdo_sys\", \"msg\": \"write\", \"valueLen\": -1, \"valueId\": \"payload.bin\", \"enc\": \"base64\" }, { \"module\": \"sdo_sys\", \"msg\": \"exec\", \"valueLen\": -1, \"valueId\": \"sh-linux64\", \"enc\": \"base64\" } ] Note When running the services as Docker*, only <sdo-iot-platform-sdk-root>/demo/ocs/config/db and <sdo-iot-platform-sdk-root>/demo/to0scheduler/config/redirect.properties, are configurable. Given an OwnershipVoucher file with a unique deviceId/GUID, the following needs to be done to add it as a device in the directory <sdo-iot-platform-sdk-root>/demo/ocs/config/db/v1/devices: Create a folder named deviceId/GUID. Rename the Owner voucher file to 'voucher.json'. Move this file to the newly created directory. Create the psi.json and svi.json files under the same directory. A sample of both files are present at the sample device directory '1fae14fb-deca-405a-abdd-b25391b9d932'. The following is a sample Python* script that, given an Owner voucher file as an argument, extracts the GUID and creates the previously mentioned device directory structure. This sample script operates under the assumption that both the script and voucher files are placed at \\ /demo/ocs/config/db/v1/devices, and that this is the current working directory: The svi.json and psi.json files are copied from the sample device \\ /demo/ocs/config/db/v1/devices/1fae14fb-deca-405a-abdd-b25391b9d932, to the new device directory. The input voucher file is moved to the new device directory and is renamed as voucher.json. import sys import os import os.path import json import base64 import codecs import uuid import shutil # read the Owner Voucher (Ownership Voucher) from the /devices directory voucherFile=open(sys.argv[1], 'r') voucher=json.load(voucherFile) voucherFile.close() # read 'g' field encodedGuid=voucher['oh']['g'] # base64 decode and convert to hex to generate the guid guid = codecs.encode(base64.b64decode(encodedGuid), 'hex') # format as per UUID standards guid = uuid.UUID(guid) print \"The GUID of the input owner voucher is - \" + str(guid) # create directory with the 'guid' as its name try: os.mkdir(str(guid)) except OSError: print (\"Failed to create directory %s\" % guid) else: print (\"Successfully created the device directory for GUID %s \" % guid) # source directory copyFromPath = os.path.basename(\"1fae14fb-deca-405a-abdd-b25391b9d932\") # destination directory copyToPath = os.path.basename(str(guid)) if os.path.isdir(copyToPath): # move the owner voucher represented by sys.argv[1] and rename it to voucher.json shutil.move(sys.argv[1], os.path.join(copyToPath, 'voucher.json')) print \"Generated voucher.json at \" + copyToPath + \" with contents of input voucher \" + sys.argv[1] # copy svi.json shutil.copyfile(os.path.join(copyFromPath, 'svi.json'), os.path.join(copyToPath, 'svi.json')) print \"Copied default svi.json from device directory \" + copyFromPath + \" to directory \" + copyToPath # copy psi.json shutil.copyfile(os.path.join(copyFromPath, 'psi.json'), os.path.join(copyToPath, 'psi.json')) print \"Copied default psi.json from device directory \" + copyFromPath + \" to directory \" + copyToPath For example, suppose the name of the script is add-device.py and the name of the owner voucher file to be added as a device is device.json having GUID fad58be5-c7ba-417c-b1bd-eb9703ea8016. Then, the script execution would look like below. At the end of the script execution, a device directory named fad58be5-c7ba-417c-b1bd-eb9703ea8016 will be created at \\ /demo/ocs/config/db/v1/devices with files voucher.json, svi.json, and psi.json as its contents. $ cd <sdo-iot-platform-sdk-root>/demo/ocs/config/db/v1/devices $ cp path/to/device.json . $ python add-device.py device.json $ The GUID of the input owner voucher is - fad58be5-c7ba-417c-b1bd-eb9703ea8016 Successfully created the device directory for GUID fad58be5-c7ba-417c-b1bd-eb9703ea8016 Generated voucher.json at fad58be5-c7ba-417c-b1bd-eb9703ea8016 with contents of input voucher device.json Copied default svi.json from device directory 1fae14fb-deca-405a-abdd-b25391b9d932 to directory fad58be5-c7ba-417c-b1bd-eb9703ea8016 Copied default psi.json from device directory 1fae14fb-deca-405a-abdd-b25391b9d932 to directory fad58be5-c7ba-417c-b1bd-eb9703ea8016","title":"Setting up Resources for OCS"},{"location":"iot-platform-sdk/running-the-demo/#running-the-owner-companion-service-with-https","text":"The provided reference implementation of Owner Companion Service, uses file-system as database. It sends REST call to To0Scheduler repeatedly at an interval (in seconds) specified by the property to0.scheduler.interval, at the URL defined by the property to0.rest.api. By default, the server is started using HTTPS. The keystore and truststore information can be configured, but the Mutual Transport Layer Security (TLS) authentication settings must be left untouched: server.ssl.key-store-type=PKCS12 (Key-store type, Configurable) server.ssl.trust-store-type=PKCS12 (Trust-store type, Configurable) server.ssl.key-store=keystore.p12 (Path to keystore file, Configurable, Must be replaced for production deployment) server.ssl.key-store-password=<password> (Keystore password, Configurable, Must be replaced for production deployment) server.ssl.trust-store=truststore (Path to truststore file, Configurable, Must be replaced for production deployment) server.ssl.trust-store-password=<password> (Truststore password, Configurable, Must be replaced for production deployment) server.ssl.client-auth=need (Force Mutual TLS. Do not change) server.ssl.ciphers=TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256 (Cipher suites to be used during TLS. Do not change) server.ssl.enabled-protocols=TLSv1.3 (TLS version. Do not change.) When starting the OCS, you can see the port(s) that the HTTPS server is listening to in the logs. o.s.b.w.e.tomcat.TomcatWebServer.start - Tomcat started on port(s): 9009 (https) with context path '' o.s.i.ocs.fsimpl.fs.FsApplication.logStarted - Started FsApplication in 7.792 seconds (JVM running for 9.125)","title":"Running the Owner Companion Service with HTTPS"},{"location":"iot-platform-sdk/running-the-demo/#running-the-to0scheduler-with-https-for-t00","text":"The To0Scheduler service schedules the list of received device GUIDs from OCS, for TO0. During TO0 process, the To0Scheduler will provide the DNS, IP address, and port that the Secure Device Onboard-enabled devices must use for TO2. The To0Scheduler sends the Rendezvous server, the redirect URI that will be used by the device to send TO2 messages. This URI information is passed to the device during the TO1 process. When the device completes TO1, it uses the TO2 redirect URI to communicate with the Owner. The TO2 redirect information, namely, DNS, IP address, and port information of the Owner Protocol Service, is stored separately in the URI specified by the property inside application.properties: org.sdo.to0.ownersign.to1d.bo=./redirect.properties (Path to file containing redirect information, Configurable) By default, the redirect information is stored in the file in the file redirect.properties, that contains the following properties: dns=localhost ip=127.0.0.1 port=8042 Please see the file /demo/to0scheduler/config/redirect.properties for more information on these properties and their default values. As the TO0 scheduler runs, it will log the TO0 request and responses. On successful TO0, you see a Wait Second response, such as, ws:7200. This refers to the number of seconds the TO0 registration will be known to the Rendezvous Server. o.s.i.t.to0library.To0Scheduler.setDeviceForTo0 - Register OP: 1fae14fb-deca-405a-abdd-b25391b9d932 o.s.i.t.to0library.To0ClientSession.run - <200,{\"ws\":7200} o.s.i.t.t.To0SchedulerEventsImpl.onSuccess - TO0 done for the device having uuid 1fae14fb-deca-405a-abdd-b25391b9d932 The To0Scheduler communicates with the OCS at the URL defined by the property rest.api.server, defined in application.properties. Similar to OCS, the server is started using HTTPS, by default. The keystore and truststore information can be configured, but the Mutual TLS authentication settings must be left untouched. The properties are the same as that of OCS. When starting the to0scheduler service, you can see the port(s) that the HTTPS server is listening to in the logs. o.s.i.t.t.To0ServiceApplication.logStarting - Starting To0ServiceApplication o.s.b.w.e.tomcat.TomcatWebServer.start - Tomcat started on port(s): 8049 (https) with context path '' o.s.i.t.t.To0ServiceApplication.logStarted - Started To0ServiceApplication in 9.159 seconds (JVM running for 10.693)","title":"Running the To0Scheduler with HTTPS for T00"},{"location":"iot-platform-sdk/running-the-demo/#starting-the-owner-protocol-service-with-https-for-to2-process","text":"The Owner Protocol server starts a HTTP server by default to listen to incoming messages from the device for TO2, by using the configuration provided in the application.properties file. To start the service using HTTPS, refer to Enabling Transport Layer Security (TLS) during TO2 . It communicates with the OCS at the URL defined by the rest.api.server property, using the keystore, and trustore as specified in application.properties. client.ssl.key-store-type=PKCS12 (Key-store type, Configurable) client.ssl.trust-store-type=PKCS12 (Trust-store type, Configurable) client.ssl.key-store=keystore.p12 (Path to keystore file, Configurable, Must be replaced for production deployment) client.ssl.key-store-password=<password> (Keystore password, Configurable, Must be replaced for production deployment) client.ssl.trust-store=truststore (Path to truststore file, Configurable, Must be replaced for production deployment) client.ssl.trust-store-password=<password> (Truststore password, Configurable, Must be replaced for production deployment) The server.port property specifies the port at which the OPS listens to for TO2 protocol connections coming from devices enabled as a Secure Device Onboard client. When starting the owner, you can see the port(s) that the HTTP server is listening to in the logs. The Owner Protocol Service logs the following messages when the TO2 communication starts. o.s.i.o.to2library.Message40Handler.onPost - When the device sends Device Service-Info message, it is logged as shown below: o.s.i.o.to2library.Message46Handler.onPost - Once the TO2 is completed, the following messages are logged: o.s.i.o.to2library.Message50Handler.onPost - o.s.i.o.opsimpl.OpsOwnerEventHandler.call - TO2 complete for device with guid In addition, the file result.txt is created on the device containing following text: Device onboarded successfully.","title":"Starting the Owner Protocol Service with HTTP(S) for TO2 Process"},{"location":"iot-platform-sdk/running-the-demo/#enabling-transport-layer-security-tls-during-to2","text":"To run TO2 in TLS mode, follow the steps listed below. Step 1: Add the following properties to <sdo-iot-platform-sdk-root>/demo/ops/config/application.properties security.require-ssl=true server.ssl.key-store-type=PKCS12 server.ssl.key-store=ops-keystore.p12 server.ssl.key-store-password=123456 server.ssl.ciphers=TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256 server.ssl.enabled-protocols=TLSv1.3 The following properties pertaining to the keystore must always match with each other in the properties file. server.ssl.key-store-type matches client.ssl.key-store-type server.ssl.key-store matches client.ssl.key-store server.ssl.key-store-password matches client.ssl.key-store-password Step 2 (Optional): A new self-signed certificate and private key can be generated by generating keystore. Create the keystore by specifying the DNS and IP address of the host machine as the subject alternative name (SAN) entries. For example, if the owner is running on a machine with DNS as owner-protocol-service.com and IP address as 10.20.30.40, then the keystore can be created by running following command. $ keytool -genkeypair -keystore ops-keystore.p12 -storetype PKCS12 -storepass 123456 -alias tomcat -keyalg RSA -keysize 2048 -validity 99999 -dname \"CN=localhost, OU=Development, O=Company, L=Hillsboro, ST=Oregon, C=US\" -ext \"san=dns:www.owner-protocol-service.com,ip:10.20.30.40\" Step 3 (Optional, dependent on Step 2): Copy the generated keystore, keystore.p12 to <sdo-iot-platform-sdk-root>/demo/ops/config . Step 4: Export the certificate from any keystore file, say ops-keystore.p12, using following command. $ openssl pkcs12 -in ops-keystore.p12 -clcerts -nokeys -out tlscert.pem Step 5: Navigate to the \\$JAVA_HOME/jre/lib/security/ folder and import the generated certificate into the Java* device's truststore, so that the device can trust the Owner Protocol Service. $ keytool -import -alias tomcat -keystore cacerts -file <PATH_TO_CERT>/tlscert.pem Alternatively, to import the existing certificate into a separate truststore, run the following: $ keytool -import -file <PATH_TO_CERT>/tlscert.pem -alias <ALIAS_NAME> -keystore <PATH_TO_TRUSTSTORE_FILE> With these configurations in place, the OPS will enable TLS during TO2 communication. Note Sample keystore and truststore files are provided in <sdo-iot-platform-sdk-root>/demo/ocs/config/, <sdo-iot-platform-sdk-root>/demo/ops/config/, and /demo/to0scheduler/config/. This is an example implementation for demo purposes and should be updated in production deployment.","title":"Enabling Transport Layer Security (TLS) during TO2"},{"location":"iot-platform-sdk/running-the-demo/#running-the-iot-platform-sdk-components-on-separate-machines","text":"To run each IOT Platform SDK component in its own separate machine, the following updates must be made: Create OV/OC pair such that the DNS/IP of the rendezvous server is mentioned in these files as part of the rendezvous information. Refer to Generating Ownership Voucher/Credential Pair for steps to create such OV/OC pairs. Update the following properties at each component: At OCS <sdo-iot-platform-sdk-root>/demo/ocs/config/application.properties: to0.rest.api=https://<To0Scheduler-machine-IP-or-DNS>:<port>/v1/to0/devices At OPS <sdo-iot-platform-sdk-root>/demo/ops/config/application.properties : rest.api.server=https://<OCS-machine-IP-or-DNS>:<port>/ At To0Scheduler <sdo-iot-platform-sdk-root>/demo/to0scheduler/config/application.properties : rest.api.server=https://<OCS-machine-IP-or-DNS>:<port>/ <sdo-iot-platform-sdk-root>/demo/to0scheduler/config/redirect.properties : dns=<OPS-DNS-name> ip=<OPS-machine-IP> port=<OPS-port> The keystore and truststore files of each of the components: OCS, OPS and To0Scheduler needs to be updated. Both the keystore and truststore files must contain the certificates whose Common Name (CN) or the Subject Alternative Names (SAN) properties have the IP address and the DNS of the machine where the component is running. This is needed for hostname verification to succeed in the Mutual TLS handshake process. Refer to Enabling Transport Layer Security (TLS) during TO2 for steps to create such keystore files. Create a truststore file as follows: $ keytool \u2013import \u2013file path/to/certificate \u2013alias sampleCA \u2013keystore path/to/truststore Based on the component interactions, the truststore for each component must contains the following certificate entries: OCS truststore contains entries to accept certificates of OPS and To0Scheduler. OPS truststore contains entries to accept certifcates of OCS. To0Scheduler truststore contains entries to accept certifcates of OCS. For information on the properties that needs to be updated for using the newly created files, refer to the following sections: - Setting up Resources for OCS - Running the Owner Companion Service with HTTPS - Running the To0Scheduler with HTTPS for T00","title":"Running the IOT Platform SDK Components on Separate Machines"},{"location":"iot-platform-sdk/running-the-demo/#common-issues-while-running-the-demo","text":"Signature is Invalid during TO0 : This error occurs when the owner's certificate (and its public key) residing at the OCS in the owner keystore, does not match the public key present in the Ownership Voucher. To rectify this error, insert the owner key-pair at <sdo-iot-platform-sdk-root>/demo/ocs/config/db/v1/creds/owner-keystore.p12 per the steps outlined here . Refer to the properties file for details on properties to be updated. The following is a sample error log at To0Scheduler: o.s.i.t.t.To0SignatureServiceFactoryImpl.lambda$sign$0 - Obtaining signature from OCS o.s.i.t.t.RestClient.signatureOperation - Error occurred while getting the signature for 59ec2905-e715-4bec-ad8f-ad5610d64895. 500 o.s.i.t.t.To0SignatureServiceFactoryImpl.lambda$sign$0 - Unable to get signature for 59ec2905-e715-4bec-ad8f-ad5610d64895 o.s.i.t.t.To0ClientSession.run - <POST http://10.0.0.1:8001/mp/113/msg/22,{\"to0d\":\u2026\u2026\u2026 o.s.i.t.t.To0ScheduledClientSession.call - {\"ec\":3,\"emsg\":255,\"em\":\"Signature of owner message is invalid.\"} c.i.s.o.t.To0SchedulerEventsImpl.onFailure - TO0 failed for the device having uuid 59ec2905-e715-4bec-ad8f-ad5610d64895.","title":"Common Issues While Running the Demo"},{"location":"protocol-reference-implementation/introduction/","text":"Protocol Reference Implementation Introduction \u00b6 The Protocol Reference Implementation README provides a quick start guide for building and running the Secure Device Onboard Protocol Reference Implementation.","title":"Introduction"},{"location":"protocol-reference-implementation/introduction/#protocol-reference-implementation-introduction","text":"The Protocol Reference Implementation README provides a quick start guide for building and running the Secure Device Onboard Protocol Reference Implementation.","title":"Protocol Reference Implementation Introduction"},{"location":"protocol-specification/appendix-b-device-provisioning-with-ecdsa/","text":"Appendix B: Device Provisioning with ECDSA \u00b6 The following procedure is used to initialize the Secure Device Onboard Device key and certificate, before the Secure Device Onboard Device Initialize (DI) protocol is run: An ECDSA key pair is generated, and a Certificate Signing Request (CSR) is signed with the new private key. The recommended way to do this is to generate the ECDSA key pair and the signed CSR inside the Secure Device Onboard device. If an appropriate security level is possible in device manufacture, it is acceptable for an ODM to generate the key pair outside the Secure Device Onboard Device, generate its own CSR, program the Secure Device Onboard Device with the private key, then discard its copy of the ECDSA private key. The CSR is submitted to a Certificate Authority trusted by the ODM to create a Device certificate and certificate chain. The device certificate should not expire unless the ODM has a reason for Secure Device Onboard to be performed before a certain date. The Device private key shall be stored with CAI (Confidentiality, Availability, Integrity) protection in the Device TEE that is performing Secure Device Onboard. The certificate chain is attached to the Ownership Voucher, as described in section \u200e5.2.3 (5.2.3 PM.OwnershipProxy, Type 3 91) The Ownership Voucher HMAC, passed in the DI protocol, references the initial Device Certificate. This means that the ECDSA key and certificate must be programmed before the Device Initialize protocol is run. The Manufacturer is trusted to match the Device certificate information to the required DI protocol fields. Subsequent to this, the Ownership Voucher HMAC (OwnershipProxy.hmac) is used to detect if the Device Certificate is changed in the supply chain.","title":"Appendix B - Device Provisioning with ECDSA"},{"location":"protocol-specification/appendix-b-device-provisioning-with-ecdsa/#appendix-b-device-provisioning-with-ecdsa","text":"The following procedure is used to initialize the Secure Device Onboard Device key and certificate, before the Secure Device Onboard Device Initialize (DI) protocol is run: An ECDSA key pair is generated, and a Certificate Signing Request (CSR) is signed with the new private key. The recommended way to do this is to generate the ECDSA key pair and the signed CSR inside the Secure Device Onboard device. If an appropriate security level is possible in device manufacture, it is acceptable for an ODM to generate the key pair outside the Secure Device Onboard Device, generate its own CSR, program the Secure Device Onboard Device with the private key, then discard its copy of the ECDSA private key. The CSR is submitted to a Certificate Authority trusted by the ODM to create a Device certificate and certificate chain. The device certificate should not expire unless the ODM has a reason for Secure Device Onboard to be performed before a certain date. The Device private key shall be stored with CAI (Confidentiality, Availability, Integrity) protection in the Device TEE that is performing Secure Device Onboard. The certificate chain is attached to the Ownership Voucher, as described in section \u200e5.2.3 (5.2.3 PM.OwnershipProxy, Type 3 91) The Ownership Voucher HMAC, passed in the DI protocol, references the initial Device Certificate. This means that the ECDSA key and certificate must be programmed before the Device Initialize protocol is run. The Manufacturer is trusted to match the Device certificate information to the required DI protocol fields. Subsequent to this, the Ownership Voucher HMAC (OwnershipProxy.hmac) is used to detect if the Device Certificate is changed in the supply chain.","title":"Appendix B: Device Provisioning with ECDSA"},{"location":"protocol-specification/appendix-c-secure-device-onboard-1-1-crypto-upgrade/","text":"Appendix C: Secure Device Onboard 1.1 Crypto Upgrade \u00b6 In October of 2017, the Security Architecture Forum (Intel Internal forum) (SAFE) Crypto Guidelines were upgraded, based on the potential threat of quantum cryptography. This table indicates crypto levels to apply. Secure Device Onboard 1.0 and Secure Device Onboard 1.1 protocol spec use the left column, and the new crypto strength is given in the \u201cFuture Crypto\u201d column; it will be assigned a Secure Device Onboard release in the future . The length of a release is generally outside the scope of this document; however, implementers of Secure Device Onboard Service and Owner components must take care to ensure that Devices using Secure Device Onboard 1.1 crypto must be supported by all Secure Device Onboard components for the life of the Secure Device Onboard 1.1 release. Category Secure Device Onboard 1.0 & Secure Device Onboard 1.1 Future Crypto (Enhanced Strength for Quantum Crypto) Comments Device HMAC HMAC-SHA-256 with HMAC secret of 128 bits HMAC-SHA-384 with HMAC secret of 512 bits Bay Trail grandfathered for SHA-256 See \u00a7 Hash of Owner Key SHA-256 SHA-384 (inside Device DI protocol) It is also permissible to store the entire Owner key. See \u00a7 Ownership Voucher (Owner attestation) RSA2048 Use RSA2048RESTR as public key type. RSA3072, except Bay Trail Use RSA_UR as public key type. Bay Trail grandfathered for RSA2048RESTR option. See \u00a7 Ownership Voucher (Owner attestation) ECDSA NIST P-256 ECDSA NIST P-384 P-384 not supported by some crypto chips; it may be possible to grandfather them in. See \u00a7 Ownership Voucher SHA-256 SHA-384 Bay Trail grandfathered for SHA-256. See \u00a7 Device attestation EPID1.0, 1.1, 2.0 Per platform No change Intel \u00ae EPID is under evaluation by SAFE; Later versions of Intel \u00ae EPID are being developed by labs. See \u00a7 Ownership Voucher SHA-256 SHA-384 Bay Trail grandfathered for SHA-256. See \u00a7 Device attestation ECDSA ECDSA NIST P-256 (with SHA-256 hash) & ECDSA NIST P-384 (with SHA-384 hash) ECDSA NIST P-384 (with SHA-384 hash) This is the device attestation key built into the device. See \u00a7 Key Exchange, DH Id14 (2048-bit modulus) a, b are 256 bits each Id15 (3072 bit modulus) a, b are 768 bits each New modulus available from same RFC as old, see refs. Increased entropy needed for SVK, SEK. See \u00a7 Key Exchange, Asymmetric RSA2048RESTR RSA-OAEP-MGF-SHA256 Device, Owner Random of 256 bits RSA_UR, 3072 bits RSA-OAEP-MGF-SHA256 Device, Owner Random of 768 bits *SHA256* may be used here as mask generation function for RSA-OAEP. Larger D&O Randoms required for SVK, SEK. See \u00a7 Key Exchange, ECDH ECC NIST P-256 or NIST P-384, keys used once only Device, Owner random of 128 bits ECC NIST P-384, keys used once only Device, Owner random of 384 bits Larger D&O Randoms required for SVK, SEK. See \u00a7 Key Exchange, ECDH, LEGACY ECC NIST P-256, keys used once only Device, Owner random of 128 bits ECC NIST P-256, keys used once only Device, Owner random of 512 bits Note that this mode can only be used for legacy hardware, with approval from PSE. See \u00a7 Key Derivation Function (*\u200e2.5.5.4*) SHA-256 based SEK, SVK entropy is 128 bits (SVK 256 bits, but with lower entropy) SHA-384 based SEK is 256 bits SVK is 512 bits Note changes to Device and Owner Randoms in key exchange algorithms to support this change. See \u00a7 SEK (Session Encryption Key) 128 bits 256 bits Matches TO2 Session Encryption modes. See Table in \u00a7 ; also see \u00a7 SVK (Session Verification Key) 256 bits, with 128 bits entropy 512 bits Based on 512 bit state of SHA-384. See Table in \u00a7 ; also see \u00a7 TO2 Session HMAC HMAC-SHA-256 HMAC-SHA-384 HMAC key is 512 bits. See Table in \u00a7 ; also see \u00a7 . TO2 Session Encryption, counter mode AES-128/CTR IV 12 bytes, Counter is 4 bytes. AES-256/CTR IV is 12 bytes, Counter is 4 bytes Note session limits on TO2 protocol ( See \u00a7 ). TO2 Session Encryption, CBC mode AES-128/CBC IV is 16 bytes AES-256/CBC IV is 16 bytes Note session limits on TO2 protocol ( See \u00a7 ). TO2 Protocol Roundtrip Limit 1M (1e6) rounds 1M (1e6) rounds Required limit for AES/CTR mode. Increased limit is to permit small files to be transmitted in ServiceInfo, esp for MCUs. See \u00a7","title":"Appendix C - Secure Device Onboard 1.1 Crypto Upgrade"},{"location":"protocol-specification/appendix-c-secure-device-onboard-1-1-crypto-upgrade/#appendix-c-secure-device-onboard-11-crypto-upgrade","text":"In October of 2017, the Security Architecture Forum (Intel Internal forum) (SAFE) Crypto Guidelines were upgraded, based on the potential threat of quantum cryptography. This table indicates crypto levels to apply. Secure Device Onboard 1.0 and Secure Device Onboard 1.1 protocol spec use the left column, and the new crypto strength is given in the \u201cFuture Crypto\u201d column; it will be assigned a Secure Device Onboard release in the future . The length of a release is generally outside the scope of this document; however, implementers of Secure Device Onboard Service and Owner components must take care to ensure that Devices using Secure Device Onboard 1.1 crypto must be supported by all Secure Device Onboard components for the life of the Secure Device Onboard 1.1 release. Category Secure Device Onboard 1.0 & Secure Device Onboard 1.1 Future Crypto (Enhanced Strength for Quantum Crypto) Comments Device HMAC HMAC-SHA-256 with HMAC secret of 128 bits HMAC-SHA-384 with HMAC secret of 512 bits Bay Trail grandfathered for SHA-256 See \u00a7 Hash of Owner Key SHA-256 SHA-384 (inside Device DI protocol) It is also permissible to store the entire Owner key. See \u00a7 Ownership Voucher (Owner attestation) RSA2048 Use RSA2048RESTR as public key type. RSA3072, except Bay Trail Use RSA_UR as public key type. Bay Trail grandfathered for RSA2048RESTR option. See \u00a7 Ownership Voucher (Owner attestation) ECDSA NIST P-256 ECDSA NIST P-384 P-384 not supported by some crypto chips; it may be possible to grandfather them in. See \u00a7 Ownership Voucher SHA-256 SHA-384 Bay Trail grandfathered for SHA-256. See \u00a7 Device attestation EPID1.0, 1.1, 2.0 Per platform No change Intel \u00ae EPID is under evaluation by SAFE; Later versions of Intel \u00ae EPID are being developed by labs. See \u00a7 Ownership Voucher SHA-256 SHA-384 Bay Trail grandfathered for SHA-256. See \u00a7 Device attestation ECDSA ECDSA NIST P-256 (with SHA-256 hash) & ECDSA NIST P-384 (with SHA-384 hash) ECDSA NIST P-384 (with SHA-384 hash) This is the device attestation key built into the device. See \u00a7 Key Exchange, DH Id14 (2048-bit modulus) a, b are 256 bits each Id15 (3072 bit modulus) a, b are 768 bits each New modulus available from same RFC as old, see refs. Increased entropy needed for SVK, SEK. See \u00a7 Key Exchange, Asymmetric RSA2048RESTR RSA-OAEP-MGF-SHA256 Device, Owner Random of 256 bits RSA_UR, 3072 bits RSA-OAEP-MGF-SHA256 Device, Owner Random of 768 bits *SHA256* may be used here as mask generation function for RSA-OAEP. Larger D&O Randoms required for SVK, SEK. See \u00a7 Key Exchange, ECDH ECC NIST P-256 or NIST P-384, keys used once only Device, Owner random of 128 bits ECC NIST P-384, keys used once only Device, Owner random of 384 bits Larger D&O Randoms required for SVK, SEK. See \u00a7 Key Exchange, ECDH, LEGACY ECC NIST P-256, keys used once only Device, Owner random of 128 bits ECC NIST P-256, keys used once only Device, Owner random of 512 bits Note that this mode can only be used for legacy hardware, with approval from PSE. See \u00a7 Key Derivation Function (*\u200e2.5.5.4*) SHA-256 based SEK, SVK entropy is 128 bits (SVK 256 bits, but with lower entropy) SHA-384 based SEK is 256 bits SVK is 512 bits Note changes to Device and Owner Randoms in key exchange algorithms to support this change. See \u00a7 SEK (Session Encryption Key) 128 bits 256 bits Matches TO2 Session Encryption modes. See Table in \u00a7 ; also see \u00a7 SVK (Session Verification Key) 256 bits, with 128 bits entropy 512 bits Based on 512 bit state of SHA-384. See Table in \u00a7 ; also see \u00a7 TO2 Session HMAC HMAC-SHA-256 HMAC-SHA-384 HMAC key is 512 bits. See Table in \u00a7 ; also see \u00a7 . TO2 Session Encryption, counter mode AES-128/CTR IV 12 bytes, Counter is 4 bytes. AES-256/CTR IV is 12 bytes, Counter is 4 bytes Note session limits on TO2 protocol ( See \u00a7 ). TO2 Session Encryption, CBC mode AES-128/CBC IV is 16 bytes AES-256/CBC IV is 16 bytes Note session limits on TO2 protocol ( See \u00a7 ). TO2 Protocol Roundtrip Limit 1M (1e6) rounds 1M (1e6) rounds Required limit for AES/CTR mode. Increased limit is to permit small files to be transmitted in ServiceInfo, esp for MCUs. See \u00a7","title":"Appendix C: Secure Device Onboard 1.1 Crypto Upgrade"},{"location":"protocol-specification/credential-reuse-protocol/","text":"Credential Reuse Protocol \u00b6 Credential Reuse protocol allows devices to reuse the Ownership Credential across multiple onboardings. The intended use case for this protocol is to support demos and testing scenarios where the onboarding can be run repeatedly and quickly without having to change the Ownership Voucher or resetting the system after each onboarding. Since credential reuse can permit the previous Owner unlimited access to the device, it is NOT recommended for use in the normal device supply chain. Credential reuse is selected by the Owner, and accepted or rejected by the device. We anticipate that new devices will always allow credential reuse, but some legacy devices do not support it. However, we can envision devices for high security applications which might reject credential reuse. In normal credential use, the Owner changes the Ownership Credential in TO2.SetupDevice, which also creates a new Ownership Voucher. At the end of a successful TO2 protocol, the device deactivates Secure Device Onboard and its state needs to be changed to ReadyN using the Resale protocol in order to reactivate onboarding process on next boot. The next onboarding uses the new Ownership Voucher. For credential reuse, the TO2 protocol supports a special case which indicates to the device not to change the Ownership Credential in TO2.SetupDevice. The device still runs the complete TO2 protocol to the end but does not deactivate Secure Device Onboard at the end of the protocol. The Credential Reuse protocol is as follows: In TO2.SetupDevice: If TO2.SetupDevice.noh.bo.g3 == TO2.ProveOPHdr.bo.oh.g # GUID same as previous, and TO2.SetupDevice.noh.bo.r3[0] == TO2.ProveOPHdr.bo.oh.r # RendezvousInfo same as previous, and TO2.SetupDevice.pk == Owner\u2019s current public key # public key in the last entry of Ownership Voucher, and TO2.SetupDevice.sig is a valid signature Then Device does not update the Ownership Credential, and Device does not internally change the HMAC, and in TO2.Done message, devices responds with TO2.Done.hmac equal to the ASCII string \u201c=\u201d (i.e., hmac.length = 1 and value = 0x3d; hmac.hashtype = 0). Note that an HMAC with one byte (hmac.length=1) is not a legal HMAC. The special value for TO2.Done.hmac is used to indicate to the Owner that device supports Credential Reuse protocol, and that the HMAC is not changed. Devices which do not support credential reuse generate a new HMAC and return its value, a valid HMAC, in TO2.Done.hmac. The Owner can differentiate whether the device supports Credential Reuse based on the HMAC value.","title":"Credential Reuse Protocol"},{"location":"protocol-specification/credential-reuse-protocol/#credential-reuse-protocol","text":"Credential Reuse protocol allows devices to reuse the Ownership Credential across multiple onboardings. The intended use case for this protocol is to support demos and testing scenarios where the onboarding can be run repeatedly and quickly without having to change the Ownership Voucher or resetting the system after each onboarding. Since credential reuse can permit the previous Owner unlimited access to the device, it is NOT recommended for use in the normal device supply chain. Credential reuse is selected by the Owner, and accepted or rejected by the device. We anticipate that new devices will always allow credential reuse, but some legacy devices do not support it. However, we can envision devices for high security applications which might reject credential reuse. In normal credential use, the Owner changes the Ownership Credential in TO2.SetupDevice, which also creates a new Ownership Voucher. At the end of a successful TO2 protocol, the device deactivates Secure Device Onboard and its state needs to be changed to ReadyN using the Resale protocol in order to reactivate onboarding process on next boot. The next onboarding uses the new Ownership Voucher. For credential reuse, the TO2 protocol supports a special case which indicates to the device not to change the Ownership Credential in TO2.SetupDevice. The device still runs the complete TO2 protocol to the end but does not deactivate Secure Device Onboard at the end of the protocol. The Credential Reuse protocol is as follows: In TO2.SetupDevice: If TO2.SetupDevice.noh.bo.g3 == TO2.ProveOPHdr.bo.oh.g # GUID same as previous, and TO2.SetupDevice.noh.bo.r3[0] == TO2.ProveOPHdr.bo.oh.r # RendezvousInfo same as previous, and TO2.SetupDevice.pk == Owner\u2019s current public key # public key in the last entry of Ownership Voucher, and TO2.SetupDevice.sig is a valid signature Then Device does not update the Ownership Credential, and Device does not internally change the HMAC, and in TO2.Done message, devices responds with TO2.Done.hmac equal to the ASCII string \u201c=\u201d (i.e., hmac.length = 1 and value = 0x3d; hmac.hashtype = 0). Note that an HMAC with one byte (hmac.length=1) is not a legal HMAC. The special value for TO2.Done.hmac is used to indicate to the Owner that device supports Credential Reuse protocol, and that the HMAC is not changed. Devices which do not support credential reuse generate a new HMAC and return its value, a valid HMAC, in TO2.Done.hmac. The Owner can differentiate whether the device supports Credential Reuse based on the HMAC value.","title":"Credential Reuse Protocol"},{"location":"protocol-specification/data-transmission-persistence/","text":"Data Transmission & Persistence \u00b6 Message Format \u00b6 All data is transmitted using Messages. Data may also be persisted or interchanged using messages, although a more compact form of the message might be used for long-term storage; for example, a persisted message might be compressed or re-encoded in a system-dependent binary format. A message has 3 or 4 elements: A length A numeric type, see section \u00a7 Protocol version: the version of this protocol, expressed as a single integer being the major version * 100 + the minor version. For example, version 3.25 is represented as: 325. When present, a body. The body is a JavaScript* Object Notation (JSON) object, transmitted using the encoding of section \u00a7 : JSON* Distinguished Encoding. The format of the body is determined by the message type. The other message elements are transmitted differently, depending on the protocol in use: When Secure Device Onboard protocols are transmitted using a reliable stream protocol when Secure Device Onboard objects are persisted offline or using TCP, TLS, Bluetooth \u00ae technology, or the message is formatted as a specially-encoded JSON* sequence, containing all the message elements within it. When Secure Device Onboard protocols are transmitted using RESTful protocols, length, numeric type, and protocol version are encoded into the REST headers. The body is transmitted as a REST payload. See section \u00a7 : Transmission of Messages over a RESTful Protocol. Transmission of Messages over a Stream Protocol and Persisted Messages \u00b6 In some cases, messages are transmitted over a stream or datagram protocol. This is a protocol that reliably transmits a stream of data with no external or out-of-band information. In this case, all message data must be encapsulated in a single JSON* encoding. Persisted Messages also use this encapsulation, please see section \u00a7 : Persistence of Messages* for more information. In the stream encapsulation of Secure Device Onboard, messages contain their own header, which is formed by encapsulating the message in a JSON* array with 3 or 4 elements: [length, messageType, protocolVersion] or [length, messageType, protocolVersion, body] Where: Length appears in hex with exactly 6 hex digits , this is an exception to the normal encoding rules. The length includes all the characters in the message, including the length field itself. For example: [\"000d\",15,4] shows a message with 13 characters (including square brackets, with no body), and has a length of 0xd = 13. Note that the stream reader can determine the length of the message by reading the first 8 bytes, verifying that: bytes 0-1 are open-square bracket and double-quote ([\") bytes 2-5 are hexadecimal values in the set: [0-9a-fA-F] bytes 6-7 are double-quote and comma (,) Then the message length in bytes is the hexadecimal number formed by bytes 2-5. The rest of the message can be read as the next message-length-8 bytes (the first 8 bytes have already been read, above). Type: appears as a UInt8. ProtocolVersion: appears as a UInt16. Body: when present, the body is a JSON* object (including the brace brackets). The format and presence of the body is determined by the messagetype field. When a stream protocol is used as the transport for the JSON* messages, the protocol proceeds as follows: The Device always calls out as the stream client. The Rendezvous Server always acts as the stream server. The Owner Client acts as stream client for Transfer Ownership Protocol 0 TO0\u2014interacting with the Rendezvous Server) and as stream server for Transfer Ownership Protocol 2 (TO2\u2014interacting with the device). Server port assignment is currently defined as: TO0: 8040; TO1: 8041; TO2: 8042 Note that this does NOT affect port assignment when using RESTful protocols. Messages are sent in the stream verbatim, without a separate messaging layer. Note that the message format is specifically designed with a fixed length field at the start ([\"000d\",\u2026) to allow the reader to read the length prefix of the message as a exactly 8 bytes and use this value to read the rest of the message exactly ( length \u2013 8 bytes). The stream is kept open until the last message has been transmitted, then dropped using the normal stream close (For example, TCP FIN). Maintenance of Stream Connection \u00b6 When the client uses a stream connection, the entire connection proceeds across a single stream connection. In the case of a TCP stream, the client and server must configure their TCP implementation to send \u201ckeep-alives\u201d frequently enough to keep the connection alive for the entire protocol transaction, including all stateful routers and firewalls that might be in the connection path. This is particularly an issue if either the client or the server takes a long delay to send some messages. Transmission of Messages over a RESTful Protocol \u00b6 When a REST protocol is used as transport for JSON* messages, the protocol proceeds as follows: The REST client always uses an HTTP POST. The content type is application/json. The REST server listens on a standard port 1 for the transport protocol. (HTTP: TCP/80, TLS: TCP/443) A Device which supports both TLS- and TCP-based REST will choose TLS for port 443 and TCP for all other ports. If the port is not specified in RendezvousInfo, then for each IP address, TLS is tried first on port 443, then TCP is tried on port 80 It is possible for an Secure Device Onboard Device to support only TCP; an Secure Device Onboard Owner must support both TLS and TCP to support all possible Secure Device Onboard Devices. However it is recommended that Secure Device Onboard Devices support TLS where feasible. Each REST transaction corresponds to a pair of JSON* messages. The first message body is delivered in the POST body. The second message is delivered as the entire POST response. The length of the message is derived from the Content-Length field. The URL for the message is of the form: /mp/protocolversion/msg/msgnum Where \u201c/mp/\u201d is verbatim; protocolversion is the protocol version number, expressed as a 3 digit decimal number; \u201c/msg/\u201d is verbatim, and msgnum is the message type (For example, from the table in section \u00a7 ). On first message, the REST server allocates a token, which must be maintained by the REST client for the duration of the connection. The token is transmitted in the REST \u201cAuthorization\u201d header. The form of the token is implementation-specific. The simplest token is just a random number chosen to be unique from other tokens. A JSON* Web Token (JWT) might also be used. The purpose of the token is to link REST calls to their protocol context within the JSON* message stream defined by the Secure Device Onboard Protocols. For example, a Java* implementation of Secure Device Onboard protocols might use a Java* object to store connection state. A new REST call can find this stored state by looking it up using the token as a key. The Secure Device Onboard implementation has some latitude in both the form of the authorization token and how this token gets allocated for Secure Device Onboard protocols. In the typical (recommended) case, there is no initial authorization: The initial REST request from the Device has an empty Authorization header or no such header. Secure Device Onboard protocols perform their own authorization within the message layer. The Rendezvous Server detects such a header as a request for a new connection, and allocates a new token and associates it with the protocol context. The Device saves the token and uses it on subsequent requests within the protocol, but not across protocols. An example is when TO1 uses one token, and TO2 uses a different token. The Rendezvous Server uses the token to look up the protocol context so that each subsequent message is processed correctly. If the Rendezvous Server wishes to obtain a token using specific REST credentials, these must be programmed into the device, then transmitted with or before the first Secure Device Onboard REST request. How this might be done is outside the scope of this document. Maintenance of REST Connections \u00b6 When transmitting messages across REST transactions, the client and server must take into account the possibility that the underlying network connection may time out between REST transactions. This is a problem if the time between a REST message and its response (that is, a POST and the POST response) is long or if the time between messages is long. In general, each Secure Device Onboard protocol may send RESTful transactions across a single TCP stream (or SSL stream for HTTPS). We require that the TCP server side (the Owner or the Rendezvous Service) either respond to messages within one or two seconds, or generate TCP keep-alives sufficient to keep the connection open. In the case of the TO1 and TO2 Protocols, the client is the Device, which might be running on a limited processor. In this case, some of cryptographic operations may take long enough for the underlying TCP connection to timeout between messages. The client must be robust in its ability to restore TCP / TLS connections for each RESTful transaction. It is legal for the client to open a new TCP connection for each RESTful transaction, although it is recommended that the connection be used for multiple transactions where possible. Persistence of Messages \u00b6 A message may be persisted by storing it in a permanent medium. If necessary, multiple messages may be persisted in the same medium, one after the other. Since a message is a JSON* statement, it is legal JSON* to store messages in a JSON* object or JSON* sequence. As the name \u201cmessage\u201d suggests, most messages are intended for ephemeral transmission only. Messages intended for persistence are defined to help in building tools for the following situations: Defining, storing, and extending the Ownership Voucher. Defining, signing, and storing the Ownership and Manufacturing Credentials. Storing and exchange of public keys during extension of the Ownership Voucher. Encrypted Message Body \u00b6 Transfer Ownership 2 Protocol (TO2) includes a key exchange (for more information, see section \u00a7 ), which generates a session encryption key (SEK) and a session verification key (SVK). Subsequent message bodies in this protocol are protected by HMAC[SVK] and subsequently encrypted using the session key (Cipher[SEK]). An encrypted message has the following format: A message header, as per section \u00a7 . A message body: Table 1 - Encrypted Message Body Format Code Sample { \"ct\": [ IVData, # cipher initialization vector UInt16, # number of bytes in crypttext ByteArray # crypttext (encrypted bytes) ], \"hmac\": [ # HMAC of message, see below. UInt8, # number of bytes of HMAC ByteArray # HMAC bytes ] } For example: {\"ct\":[[16, \u201cMTIzNDU2Nzg5MGFiY2RlZg==\u201d],6,\"QTA1Njc4\"],\"hmac\":[32,\"bbddee \u202644-b64-chars\u2026 45=\"]} The HMAC in tag \u201chmac\u201d should be type HMAC-SHA256 (Secure Device Onboard 1.0 and Secure Device Onboard 1.1 protocol spec) or HMAC-SHA384 (future crypto). The HMAC algorithm must be the same as specified in the Cipher Suite field of the TO2.HelloDevice message (TO2.HelloDevice.cs). The HMAC uses SVK (from the key exchange) as the key. The HMAC covers: the encrypted message body, which is JSON* ASCII data excluding the \u201cct\u201d tag but includes the enclosing brackets of the \u201cct\u201d field The \u201cct\u201d tag contains a base64 representation an encryption of the entire JSON* message being transmitted. The encryption is one of the ciphers described in the table below. Table 2 - Cipher Suite Names and Meanings Cipher Suite Name (see TO2.HelloDevice) Secure Device Onboard 1.0/1.1 Initialization Vector (IVData.iv in \"ct\" message header) Meaning AES128/CTR/HMAC-SHA256 (Secure Device Onboard 1.0 and Secure Device Onboard 1.1) The IV for AES CTR Mode is 16 bytes long in big-endian byte order, where: - The first 12 bytes of IV (nonce) are randomly generated at the beginning of a session, independently by both sides. - The last 4 bytes of IV (counter) is initialized to 0 at the beginning of the session. - The IV value must be maintained with the current session key. \u201cMaintain\u201d means that the IV will be changed by the underlying encryption mechanism and must be copied back to the current session state for future encryption. - For decryption, the IV will come in the header of the received message. The random data source must be a cryptographically strong pseudo random number generator (CSPRNG) or a true random number generator (TNRG). This is the preferred cipher suite for Secure Device Onboard for 128-bit keys. Other suites are provided for situations where Device implementations cannot use this suite. AES in Counter Mode [6] with 128 bit key using the SEK from key exchange (\u200esee section \u00a7 ). AES128/CBC/HMAC-SHA256 (Secure Device Onboard 1.0 and Secure Device Onboard 1.1) IV is 16 bytes containing random data, to use as initialization vector for CBC mode. The random data must be freshly generated for every encrypted message. The random data source must be a cryptographically strong pseudo random number generator (CSPRNG) or a true random number generator (TNRG). AES in Cipher Block Chaining (CBC) Mode [3] with PKCS7 [17] padding. The key is the SEK from key exchange (see section \u00a7 ). Implementation notes: - Implementation may not return an error that indicates a padding failure. - The implementation must only return the decryption error after the \"expected\" processing time for this message. It is recognized that the first item is hard to achieve in general, but Secure Device Onboard risk is low in this area, because any decryption error will cause the connection to be torn down. AES256/CTR/HMAC-SHA384 The IV for AES CTR Mode is 16 bytes long in big-endian byte order, where: - The first 12 bytes of IV (nonce) are randomly generated at the beginning of a session, independently by both sides. - The last 4 bytes of IV (counter) is initialized to 0 at the beginning of the session. - The IV value must be maintained with the current session key. \u201cMaintain\u201d means that the IV will be changed by the underlying encryption mechanism and must be copied back to the current session state for future encryption. - For decryption, the IV will come in the header of the received message. The random data source must be a cryptographically strong pseudo random number generator (CSPRNG) or a true random number generator (TNRG). This is the preferred cipher suite for Secure Device Onboard for 256-bit keys. Other suites are provided for situations where Device implementations cannot use this suite. AES in Counter Mode [6] with 256 bit key using the SEK from key exchange (see section \u00a7 ). AES256/CBC/HMAC-SHA384 (Future crypto) IV is 16 bytes containing random data, to use as initialization vector for CBC mode. The random data must be freshly generated for every encrypted message. The random data source must be cryptographically strong pseudo random number generator (CSPRNG) or a true random number generator (TNRG) AES-256 in Cipher Block Chaining (CBC) Mode [15] with PKCS7[16] padding. The key is the SEK from key exchange (see section \u00a7 ). Implementation notes: - Implementation may not return an error that indicates a padding failure. - The implementation must only return the decryption error after the \"expected\" processing time for this message. It is recognized that the item is hard to achieve in general, but Secure Device Onboard risk is low in this area, because any decryption error causes the connection to be torn down. Message Types \u00b6 This section defines all persisted and transmitted message types. Each message is described in greater detail in a later section, but the table here can provide an overview of the flow of each protocol. JSON* object tag names are kept small to help constrained implementations. Within the limits of their brevity, they are chosen for mnemonic value. For example, the error message \u201cec\u201d standard for \u201cerror code.\u201d Some values appear in successive versions within the protocol. For example, a nonce is often used to verify the \u201cfreshness\u201d of a signature (that is, that the signature was performed on demand). Similarly, device GUIDs change, and several different public keys are used. When this happens, the convention is that the object tag is a letter describing the object, and a numeral describing the version. The versions are numbered from 1, based on the Device Initialize Protocol (DI). Persisted types typically use no numeral. The following table describes all the messages in the protocol with their message types and names. The message contents are indicated in column 3, but the reader is referenced to the detailed section for each message to get a full description. For example, message comments have been removed. The REST column of the table indicates the URL to use for this message type, when the transport is a RESTful protocol (HTTP, HTTPS, and others). Note Messages are not allowed to include whitespace and comments. Error Message \u00b6 The \u201ccatch-all\u201d error message is sent whenever processing cannot continue. This includes protocol errors and any trust or security violations, including: Failure to verify a signature (section \u200e \u00a7 ) Revoked EPID Group or signature (SIGRL) (section \u200e \u00a7 ) Rejection of Application ID or EPID Group Attributes (section \u00a7 ) Failure to verify the Ownership Voucher against the Device HMAC (section \u00a7 ) Failure to verify the internal consistency of the Ownership Voucher, or failure to verify any of the signatures in the Ownership Voucher against the Device Credentials and the Owner key challenge (section \u00a7 ) Failure to verify the challenge for the Owner key (sections \u00a7 & \u00a7 ) or the TO0D signature (section \u00a7 ) Failure to verify a HMAC or to decrypt a message (section \u00a7 ) Failure to interpret the ServiceInfo, or failures internal to the ServiceInfo modules (section \u00a7 ) Failure to verify any nonce with the previously transmitted value (section \u00a7 for example) Any resource or communications failure that makes successful onboarding fail The Secure Device Onboard protocol is always terminated after an error message, and all Secure Device Onboard error conditions send an error message. However, security errors might not indicate the exact cause of the problem, if this would cause a security issue. The contents of the error message are intended to help diagnose the error. The \u201cec\u201d tag is an error code, please see following section, Error Code Values, for detailed information. The \u201cemsg\u201d tag gives the message ID of the previous message, making it easier to put the error into context. The \u201cem\u201d tag gives a string suitable for logging about the error. The string in the \u201cem\u201d tag must not include security details that are inappropriate for logging, such as a specific security condition, or any key or password information. Table 3 - Error Message Content and Meanings Type\\# Message Type Name Message Contents From To REST Transmission 255 Error { #Error message body \"ec\": Uint16, \"emsg\": UInt8, \"em\": String } Any Any HTTP response with message type 255 when transmitted as HTTP response POST /mp/VVV/msg/255, when transmitted as HTTP request If the problem is found in a HTTP request, the ERROR message is sent as HTTP response. The body of the response is a Secure Device Onboard/JSON* message with message type 255, and the \u201cemsg\u201d tag indicates the message type of the HTTP request message. The flow is as follows: HTTP request: POST /mp/VVV/msg/X, msg type = X HTTP response: msg type = ERROR(255), emsg = X Secure Device Onboard terminates in error on both sides If the problem is found in a HTTP response, the ERROR message is sent as a new HTTP request, POST /mp/VVV/msg/255, and the \u201cemsg\u201d tag indicates the message type of the previous HTTP response message. The authentication token from the previous HTTP request appears in the HTTP request containing the ERROR message. Since the ERROR message terminates the Secure Device Onboard protocol, the HTTP response to an ERROR message is an HTTP empty message (zero length). The flow is as follows: HTTP request: POST /mp/VVV/msg/Y, msg type = Y (for any message type Y) HTTP response: msg type = X HTTP request, POST /mp/VVV/msg/255: msg type = 255, emsg = X HTTP response: <zero length> Secure Device Onboard terminates in error on both sides ERROR messages are never retransmitted, and an ERROR message must never generate an ERROR message in response. Error Code Values \u00b6 Table 4 - Error Codes Error Code (EC) Internal Name Generated by Message Description 001 INVALID_JWT_TOKEN DI.SetHMAC TO0.OwnerSign TO1.ProveToSDO TO2.HelloDevice TO2.GetOPNextEntry TO2.ProveDevice TO2.NextDeviceServiceInfo TO2.Done JWT token is missing or authorization header value does not start with 'Bearer'. Each token has its own validity period, server rejects expired tokens. Server failed to parse JWT token or JWT signature did not verify correctly. The JWT token refers to the token mentioned in section \u00a7 (which is not required by protocol to be a JWT token). The error message applies to non-JWT tokens, as well. 002 INVALID_OWNERSHIP_PROXY TO0.OwnerSign Ownership Voucher is invalid: One of Ownership Voucher verification checks has failed. Precise information is not returned to the client but saved only in service logs. 003 INVALID_OWNER_SIGN_BODY TO0.OwnerSign Verification of signature of owner message failed. TO0.OwnerSign message is signed by the final owner (using key signed by the last Ownership Voucher entry). This error is returned in case that signature is invalid. 004 INVALID_IP_ADDRESS TO0.OwnerSign IP address is invalid. Bytes that are provided in the request do not represent a valid IPv4/IPv6 address. 005 INVALID_GUID TO0.OwnerSign GUID is invalid. Bytes that are provided in the request do not represent a proper GUID. 006 RESOURCE_NOT_FOUND TO1.HelloSDO TO2.HelloDevice The owner connection info for GUID is not found. TO0 Protocol wasn't properly executed for the specified GUID or information that was stored in database has expired and/or has been removed. 100 MESSAGE_BODY_ERROR DI.AppStart DI.SetHMAC TO0.Hello TO0.OwnerSign TO1.HelloSDO TO1.ProveToSDO TO2.HelloDevice TO2.GetOPNextEntry TO2.ProveDevice TO2.NextDeviceServiceInfo TO2.GetNextOwnerServiceInfo TO2.Done Message Body is structurally unsound: JSON* parse error, or valid JSON*, but is not mapping to the expected Secure Device Onboard type (see section \u00a7 ) 101 INVALID_MESSAGE_ERROR TO0.OwnerSign TO1.HelloSDO TO1.ProveToSDO TO2.HelloDevice TO2.GetOPNextEntry TO2.ProveDevice TO2.NextDeviceServiceInfo TO2.GetNextOwnerServiceInfo Message structurally sound, but failed validation tests. The nonce didn\u2019t match, signature didn\u2019t verify, hash, or mac didn\u2019t verify, index out of bounds, and others... 500 INTERNAL_SERVER_ERROR DI.AppStart DI.SetHMAC TO0.Hello TO0.OwnerSign TO1.HelloSDO TO1.ProveToSDO TO2.HelloDevice TO2.GetOPNextEntry TO2.ProveDevice TO2.NextDeviceServiceInfo TO2.GetNextOwnerServiceInfo TO2.Done Something went wrong which couldn\u2019t be classified otherwise. (This was chosen to match the HTTP 500 error code.) Persisted Messages \u00b6 Table 5 - Persisted Messages Information Type# Message Type Name Description 1 PM.CredOwner This is the Ownership Credential that is stored in the device TEE during the Device Initialize Protocol (DI), and updated in Transfer Ownership 2 Protocol (TO2). 2 PM.CredMfg This is the Manufacturing Credential that is stored in the device TEE during the Device Initialize Protocol (DI). It is never changed afterwards. 3 PM.OwnershipProxy The [Ownership Voucher] is used to convey the trust of the device in the factory to the new owner. 4 PM.PublicKey This message is used by each successive owner in the supply chain to identify his public key to the previous owner. The previous owner signs the public key (and other information) to extend the ownership voucher. 5 PM.ServiceInfo This message is used to save the key-value pairs that are sent as part of the TO2.ReceiveDeviceInfo and TO2.SendSetupInfo messages. 6 PM.DeviceCredentials This message is used to store the device state for implementations that use a filesystem instead of a TEE. It may also be signed or encrypted (sealed) in these implementations, to improve security. Device Initialize Protocol (DI) \u00b6 Table 6 - Device Initialize Protocol - Message Information Type\\# Message Type Name Message Contents From To REST Transmission 10 [DI.AppStart] { \"m\": String } Dev TEE Mfg station POST /mp/VVV/msg/10 2 11 [DI.SetCredentials] { \"oh\": { \"pv\": UInt16, \"pe\": UInt8, \"r\": Rendezvous, \"g\": GUID, \"d\": String \"pk\": PublicKey \"hdc\": Hash #Absent if using Intel EPID } } Mfg station Dev TEE (post response, includes authorization token) 12 [DI.SetHMAC] { \"hmac\": Hash } Dev TEE Mfg station POST /mp/VVV/msg/12 13 [DI.Done] \\-no body- Mfg station Dev TEE (post response with token) Transfer Ownership Protocol 0 (TO0) \u00b6 Table 7 - Transfer Ownership Protocol 0 \u2013 Message Information Type# Message Type Name Message Contents From To REST Transmission 20 [TO0.Hello] -no body- New Owner Client Rendezvous Server POST /mp/VVV/msg/20 21 [TO0.HelloAck] { \"n3\": Nonce } Rendezvous Server New Owner Client (post response, includes authorization token) 22 [TO0.OwnerSign] { \"to0d\": { \"op\": OwnershipProxy, \"ws\": UInt32, \"n3\": Nonce }, \"to1d\": { # Sign with Owner key \"bo\": { \"i1\": IPAddress, \"dns1\": String, \"port1\": UInt16, \"to0dh\": Hash }, \"pk\": PKNull, \"sg\": Signature #Owner key } } New Owner Client Rendezvous Server POST /mp/VVV/msg/22 25 TO0.AcceptOwner { \"ws\": Uint32 } Rendezvous Server New Owner Client (post response with token) Transfer Ownership Protocol 1 (TO1) \u00b6 Table 8 - Transfer Ownership Protocol 1 \u2013 Message Information Type\\# Message Type Name Message Contents From To REST Transmission 30 [TO1.HelloSDO] { \"g2\": GUID, # device GUID. \"eA\": SigInfo } Device TEE Rendezvous Server POST /mp/VVV/msg/30 *GUID added to help token creation* 31 [TO1.HelloSDOAck] { \"n4\": Nonce, \"eB\": SigInfo } Rendezvous Server Device TEE (post response, includes authorization token) (please see section \u00a7 ) 32 [TO1.ProveToSDO] { \"bo\": { \"ai\": AppId, \"n4\": Nonce, \"g2\": GUID }, \"pk\": PublicKey, #PKNull if ECDSA \"sg\": Signature } Device TEE Rendezvous Server POST /mp/VVV/msg/32 33 [TO1.SDORedirect] { \"bo\": { \"i1\": IPAddress, \"dns1\": String, \"port1\": UInt16, \"to0dh\": Hash }, \"pk\": PKNull, \"sg\": Signature } Rendezvous Server Device TEE (post response with token) Transfer Ownership Protocol 2 (TO2) \u00b6 Table 9 - Transfer Ownership Protocol 2 \u2013 Message Information Type# Message Type Name Message Contents From To REST Transmission 40 [TO2.HelloDevice] { \"g2\": GUID, \"n5\": Nonce, \"pe\": UInt8, \"kx\": String, \"cs\": String, \"eA\": SigInfo } Device TEE New Owner Client POST /mp/VVV/msg/40 41 [TO2.ProveOpHdr] {# Signature of OP Owner Key bo: { \"sz\": UInt8, \"oh\": OwnershipProxyHdr, \"hmac\":Hash, \"n5\": Nonce, \"n6\": Nonce, \"eB\": SigInfo, \"xA\": KeyExchange }, \"pk\": PublicKey, \"sg\": Signature } New Owner Client Device TEE (post response, includes authorization token) Note: In this message, the pk tag must have the actual Owner key (not PKNull) to allow Device to verify signature immediately. 42 [TO2.GetOpNextEntry] { \"enn\": UInt8 } Device TEE New Owner Client POST /mp/VVV/msg/42 43 [TO2.OpNextEntry] { \"enn\":UInt8, \"eni\":OwnershipProxyEntry } New Owner Client Device TEE (post response with token) 44 [TO2.ProveDevice] { \"bo\": { \"ai\": AppId, \"n6\": Nonce, \"n7\": Nonce, \"g2\": GUID, \"nn\": UInt8, \"xB\": DHKeyExchange }, \"pk\": PublicKey, \"sg\": Signature } Device TEE New Owner Client POST /mp/VVV/msg/44 Note: For EPID, \"pk\" contains EPID group number. Otherwise, it is PKNull. 45 [TO2.GetNext DeviceServiceInfo] { \"nn\": UInt8, \"psi\": String } New Owner Client Device TEE (post response with token) 46 [TO2.Next DeviceServiceInfo] { \"nn\u201d: UInt8, \"dsi\":ServiceInfo } Device TEE New Owner Client POST /mp/VVV/msg/46 47 [TO2.SetupDevice] { \"osinn\":UInt8, \"noh\":{ \"bo\":{ \"r3\": Rendezvous, \"g3\": GUID, GUID \"n7\": Nonce }, \"pk\": PublicKey, #Owner2 \"sg\": Signature } } New Owner Client Device TEE (post response with token) Note: This is the \u201cowner2\u201d key, the replacement for the manufacturer\u2019s key in the DI Protocol. It must not be PKNull. 48 [TO2.GetNext OwnerServiceInfo] { \"nn\":Uint8 } Device TEE New Owner Client POST /mp/VVV/msg/48 49 [TO2.Next OwnerServiceInfo] { \"nn\": UInt8, \"sv\": ServiceInfo } New Owner Client Device TEE (post response with token) 50 [TO2.Done] { \"hmac:\": Hash, \"n6\": Nonce } Device TEE New Owner Client POST /mp/VVV/msg/50 51 [TO2.Done2] { \"n7\": Nonce } New Owner Client Device TEE (post response with token) When testing on a single machine, it is useful to use non-standard ports, such as the TCP stream ports (8040, 8041, 8042). However, in service and by default, standard ports should be used. \u21a9 /mp/VVV means \u2018/mp/\u2019 followed by the protocol version. For example, version 1.13 would use /mp/113. \u21a9","title":"Data Transmission & Persistence"},{"location":"protocol-specification/data-transmission-persistence/#data-transmission-persistence","text":"","title":"Data Transmission &amp; Persistence"},{"location":"protocol-specification/data-transmission-persistence/#message-format","text":"All data is transmitted using Messages. Data may also be persisted or interchanged using messages, although a more compact form of the message might be used for long-term storage; for example, a persisted message might be compressed or re-encoded in a system-dependent binary format. A message has 3 or 4 elements: A length A numeric type, see section \u00a7 Protocol version: the version of this protocol, expressed as a single integer being the major version * 100 + the minor version. For example, version 3.25 is represented as: 325. When present, a body. The body is a JavaScript* Object Notation (JSON) object, transmitted using the encoding of section \u00a7 : JSON* Distinguished Encoding. The format of the body is determined by the message type. The other message elements are transmitted differently, depending on the protocol in use: When Secure Device Onboard protocols are transmitted using a reliable stream protocol when Secure Device Onboard objects are persisted offline or using TCP, TLS, Bluetooth \u00ae technology, or the message is formatted as a specially-encoded JSON* sequence, containing all the message elements within it. When Secure Device Onboard protocols are transmitted using RESTful protocols, length, numeric type, and protocol version are encoded into the REST headers. The body is transmitted as a REST payload. See section \u00a7 : Transmission of Messages over a RESTful Protocol.","title":"Message Format"},{"location":"protocol-specification/data-transmission-persistence/#transmission-of-messages-over-a-stream-protocol-and-persisted-messages","text":"In some cases, messages are transmitted over a stream or datagram protocol. This is a protocol that reliably transmits a stream of data with no external or out-of-band information. In this case, all message data must be encapsulated in a single JSON* encoding. Persisted Messages also use this encapsulation, please see section \u00a7 : Persistence of Messages* for more information. In the stream encapsulation of Secure Device Onboard, messages contain their own header, which is formed by encapsulating the message in a JSON* array with 3 or 4 elements: [length, messageType, protocolVersion] or [length, messageType, protocolVersion, body] Where: Length appears in hex with exactly 6 hex digits , this is an exception to the normal encoding rules. The length includes all the characters in the message, including the length field itself. For example: [\"000d\",15,4] shows a message with 13 characters (including square brackets, with no body), and has a length of 0xd = 13. Note that the stream reader can determine the length of the message by reading the first 8 bytes, verifying that: bytes 0-1 are open-square bracket and double-quote ([\") bytes 2-5 are hexadecimal values in the set: [0-9a-fA-F] bytes 6-7 are double-quote and comma (,) Then the message length in bytes is the hexadecimal number formed by bytes 2-5. The rest of the message can be read as the next message-length-8 bytes (the first 8 bytes have already been read, above). Type: appears as a UInt8. ProtocolVersion: appears as a UInt16. Body: when present, the body is a JSON* object (including the brace brackets). The format and presence of the body is determined by the messagetype field. When a stream protocol is used as the transport for the JSON* messages, the protocol proceeds as follows: The Device always calls out as the stream client. The Rendezvous Server always acts as the stream server. The Owner Client acts as stream client for Transfer Ownership Protocol 0 TO0\u2014interacting with the Rendezvous Server) and as stream server for Transfer Ownership Protocol 2 (TO2\u2014interacting with the device). Server port assignment is currently defined as: TO0: 8040; TO1: 8041; TO2: 8042 Note that this does NOT affect port assignment when using RESTful protocols. Messages are sent in the stream verbatim, without a separate messaging layer. Note that the message format is specifically designed with a fixed length field at the start ([\"000d\",\u2026) to allow the reader to read the length prefix of the message as a exactly 8 bytes and use this value to read the rest of the message exactly ( length \u2013 8 bytes). The stream is kept open until the last message has been transmitted, then dropped using the normal stream close (For example, TCP FIN).","title":"Transmission of Messages over a Stream Protocol and Persisted Messages"},{"location":"protocol-specification/data-transmission-persistence/#maintenance-of-stream-connection","text":"When the client uses a stream connection, the entire connection proceeds across a single stream connection. In the case of a TCP stream, the client and server must configure their TCP implementation to send \u201ckeep-alives\u201d frequently enough to keep the connection alive for the entire protocol transaction, including all stateful routers and firewalls that might be in the connection path. This is particularly an issue if either the client or the server takes a long delay to send some messages.","title":"Maintenance of Stream Connection"},{"location":"protocol-specification/data-transmission-persistence/#transmission-of-messages-over-a-restful-protocol","text":"When a REST protocol is used as transport for JSON* messages, the protocol proceeds as follows: The REST client always uses an HTTP POST. The content type is application/json. The REST server listens on a standard port 1 for the transport protocol. (HTTP: TCP/80, TLS: TCP/443) A Device which supports both TLS- and TCP-based REST will choose TLS for port 443 and TCP for all other ports. If the port is not specified in RendezvousInfo, then for each IP address, TLS is tried first on port 443, then TCP is tried on port 80 It is possible for an Secure Device Onboard Device to support only TCP; an Secure Device Onboard Owner must support both TLS and TCP to support all possible Secure Device Onboard Devices. However it is recommended that Secure Device Onboard Devices support TLS where feasible. Each REST transaction corresponds to a pair of JSON* messages. The first message body is delivered in the POST body. The second message is delivered as the entire POST response. The length of the message is derived from the Content-Length field. The URL for the message is of the form: /mp/protocolversion/msg/msgnum Where \u201c/mp/\u201d is verbatim; protocolversion is the protocol version number, expressed as a 3 digit decimal number; \u201c/msg/\u201d is verbatim, and msgnum is the message type (For example, from the table in section \u00a7 ). On first message, the REST server allocates a token, which must be maintained by the REST client for the duration of the connection. The token is transmitted in the REST \u201cAuthorization\u201d header. The form of the token is implementation-specific. The simplest token is just a random number chosen to be unique from other tokens. A JSON* Web Token (JWT) might also be used. The purpose of the token is to link REST calls to their protocol context within the JSON* message stream defined by the Secure Device Onboard Protocols. For example, a Java* implementation of Secure Device Onboard protocols might use a Java* object to store connection state. A new REST call can find this stored state by looking it up using the token as a key. The Secure Device Onboard implementation has some latitude in both the form of the authorization token and how this token gets allocated for Secure Device Onboard protocols. In the typical (recommended) case, there is no initial authorization: The initial REST request from the Device has an empty Authorization header or no such header. Secure Device Onboard protocols perform their own authorization within the message layer. The Rendezvous Server detects such a header as a request for a new connection, and allocates a new token and associates it with the protocol context. The Device saves the token and uses it on subsequent requests within the protocol, but not across protocols. An example is when TO1 uses one token, and TO2 uses a different token. The Rendezvous Server uses the token to look up the protocol context so that each subsequent message is processed correctly. If the Rendezvous Server wishes to obtain a token using specific REST credentials, these must be programmed into the device, then transmitted with or before the first Secure Device Onboard REST request. How this might be done is outside the scope of this document.","title":"Transmission of Messages over a RESTful Protocol"},{"location":"protocol-specification/data-transmission-persistence/#maintenance-of-rest-connections","text":"When transmitting messages across REST transactions, the client and server must take into account the possibility that the underlying network connection may time out between REST transactions. This is a problem if the time between a REST message and its response (that is, a POST and the POST response) is long or if the time between messages is long. In general, each Secure Device Onboard protocol may send RESTful transactions across a single TCP stream (or SSL stream for HTTPS). We require that the TCP server side (the Owner or the Rendezvous Service) either respond to messages within one or two seconds, or generate TCP keep-alives sufficient to keep the connection open. In the case of the TO1 and TO2 Protocols, the client is the Device, which might be running on a limited processor. In this case, some of cryptographic operations may take long enough for the underlying TCP connection to timeout between messages. The client must be robust in its ability to restore TCP / TLS connections for each RESTful transaction. It is legal for the client to open a new TCP connection for each RESTful transaction, although it is recommended that the connection be used for multiple transactions where possible.","title":"Maintenance of REST Connections"},{"location":"protocol-specification/data-transmission-persistence/#persistence-of-messages","text":"A message may be persisted by storing it in a permanent medium. If necessary, multiple messages may be persisted in the same medium, one after the other. Since a message is a JSON* statement, it is legal JSON* to store messages in a JSON* object or JSON* sequence. As the name \u201cmessage\u201d suggests, most messages are intended for ephemeral transmission only. Messages intended for persistence are defined to help in building tools for the following situations: Defining, storing, and extending the Ownership Voucher. Defining, signing, and storing the Ownership and Manufacturing Credentials. Storing and exchange of public keys during extension of the Ownership Voucher.","title":"Persistence of Messages"},{"location":"protocol-specification/data-transmission-persistence/#encrypted-message-body","text":"Transfer Ownership 2 Protocol (TO2) includes a key exchange (for more information, see section \u00a7 ), which generates a session encryption key (SEK) and a session verification key (SVK). Subsequent message bodies in this protocol are protected by HMAC[SVK] and subsequently encrypted using the session key (Cipher[SEK]). An encrypted message has the following format: A message header, as per section \u00a7 . A message body: Table 1 - Encrypted Message Body Format Code Sample { \"ct\": [ IVData, # cipher initialization vector UInt16, # number of bytes in crypttext ByteArray # crypttext (encrypted bytes) ], \"hmac\": [ # HMAC of message, see below. UInt8, # number of bytes of HMAC ByteArray # HMAC bytes ] } For example: {\"ct\":[[16, \u201cMTIzNDU2Nzg5MGFiY2RlZg==\u201d],6,\"QTA1Njc4\"],\"hmac\":[32,\"bbddee \u202644-b64-chars\u2026 45=\"]} The HMAC in tag \u201chmac\u201d should be type HMAC-SHA256 (Secure Device Onboard 1.0 and Secure Device Onboard 1.1 protocol spec) or HMAC-SHA384 (future crypto). The HMAC algorithm must be the same as specified in the Cipher Suite field of the TO2.HelloDevice message (TO2.HelloDevice.cs). The HMAC uses SVK (from the key exchange) as the key. The HMAC covers: the encrypted message body, which is JSON* ASCII data excluding the \u201cct\u201d tag but includes the enclosing brackets of the \u201cct\u201d field The \u201cct\u201d tag contains a base64 representation an encryption of the entire JSON* message being transmitted. The encryption is one of the ciphers described in the table below. Table 2 - Cipher Suite Names and Meanings Cipher Suite Name (see TO2.HelloDevice) Secure Device Onboard 1.0/1.1 Initialization Vector (IVData.iv in \"ct\" message header) Meaning AES128/CTR/HMAC-SHA256 (Secure Device Onboard 1.0 and Secure Device Onboard 1.1) The IV for AES CTR Mode is 16 bytes long in big-endian byte order, where: - The first 12 bytes of IV (nonce) are randomly generated at the beginning of a session, independently by both sides. - The last 4 bytes of IV (counter) is initialized to 0 at the beginning of the session. - The IV value must be maintained with the current session key. \u201cMaintain\u201d means that the IV will be changed by the underlying encryption mechanism and must be copied back to the current session state for future encryption. - For decryption, the IV will come in the header of the received message. The random data source must be a cryptographically strong pseudo random number generator (CSPRNG) or a true random number generator (TNRG). This is the preferred cipher suite for Secure Device Onboard for 128-bit keys. Other suites are provided for situations where Device implementations cannot use this suite. AES in Counter Mode [6] with 128 bit key using the SEK from key exchange (\u200esee section \u00a7 ). AES128/CBC/HMAC-SHA256 (Secure Device Onboard 1.0 and Secure Device Onboard 1.1) IV is 16 bytes containing random data, to use as initialization vector for CBC mode. The random data must be freshly generated for every encrypted message. The random data source must be a cryptographically strong pseudo random number generator (CSPRNG) or a true random number generator (TNRG). AES in Cipher Block Chaining (CBC) Mode [3] with PKCS7 [17] padding. The key is the SEK from key exchange (see section \u00a7 ). Implementation notes: - Implementation may not return an error that indicates a padding failure. - The implementation must only return the decryption error after the \"expected\" processing time for this message. It is recognized that the first item is hard to achieve in general, but Secure Device Onboard risk is low in this area, because any decryption error will cause the connection to be torn down. AES256/CTR/HMAC-SHA384 The IV for AES CTR Mode is 16 bytes long in big-endian byte order, where: - The first 12 bytes of IV (nonce) are randomly generated at the beginning of a session, independently by both sides. - The last 4 bytes of IV (counter) is initialized to 0 at the beginning of the session. - The IV value must be maintained with the current session key. \u201cMaintain\u201d means that the IV will be changed by the underlying encryption mechanism and must be copied back to the current session state for future encryption. - For decryption, the IV will come in the header of the received message. The random data source must be a cryptographically strong pseudo random number generator (CSPRNG) or a true random number generator (TNRG). This is the preferred cipher suite for Secure Device Onboard for 256-bit keys. Other suites are provided for situations where Device implementations cannot use this suite. AES in Counter Mode [6] with 256 bit key using the SEK from key exchange (see section \u00a7 ). AES256/CBC/HMAC-SHA384 (Future crypto) IV is 16 bytes containing random data, to use as initialization vector for CBC mode. The random data must be freshly generated for every encrypted message. The random data source must be cryptographically strong pseudo random number generator (CSPRNG) or a true random number generator (TNRG) AES-256 in Cipher Block Chaining (CBC) Mode [15] with PKCS7[16] padding. The key is the SEK from key exchange (see section \u00a7 ). Implementation notes: - Implementation may not return an error that indicates a padding failure. - The implementation must only return the decryption error after the \"expected\" processing time for this message. It is recognized that the item is hard to achieve in general, but Secure Device Onboard risk is low in this area, because any decryption error causes the connection to be torn down.","title":"Encrypted Message Body"},{"location":"protocol-specification/data-transmission-persistence/#message-types","text":"This section defines all persisted and transmitted message types. Each message is described in greater detail in a later section, but the table here can provide an overview of the flow of each protocol. JSON* object tag names are kept small to help constrained implementations. Within the limits of their brevity, they are chosen for mnemonic value. For example, the error message \u201cec\u201d standard for \u201cerror code.\u201d Some values appear in successive versions within the protocol. For example, a nonce is often used to verify the \u201cfreshness\u201d of a signature (that is, that the signature was performed on demand). Similarly, device GUIDs change, and several different public keys are used. When this happens, the convention is that the object tag is a letter describing the object, and a numeral describing the version. The versions are numbered from 1, based on the Device Initialize Protocol (DI). Persisted types typically use no numeral. The following table describes all the messages in the protocol with their message types and names. The message contents are indicated in column 3, but the reader is referenced to the detailed section for each message to get a full description. For example, message comments have been removed. The REST column of the table indicates the URL to use for this message type, when the transport is a RESTful protocol (HTTP, HTTPS, and others). Note Messages are not allowed to include whitespace and comments.","title":"Message Types"},{"location":"protocol-specification/data-transmission-persistence/#error-message","text":"The \u201ccatch-all\u201d error message is sent whenever processing cannot continue. This includes protocol errors and any trust or security violations, including: Failure to verify a signature (section \u200e \u00a7 ) Revoked EPID Group or signature (SIGRL) (section \u200e \u00a7 ) Rejection of Application ID or EPID Group Attributes (section \u00a7 ) Failure to verify the Ownership Voucher against the Device HMAC (section \u00a7 ) Failure to verify the internal consistency of the Ownership Voucher, or failure to verify any of the signatures in the Ownership Voucher against the Device Credentials and the Owner key challenge (section \u00a7 ) Failure to verify the challenge for the Owner key (sections \u00a7 & \u00a7 ) or the TO0D signature (section \u00a7 ) Failure to verify a HMAC or to decrypt a message (section \u00a7 ) Failure to interpret the ServiceInfo, or failures internal to the ServiceInfo modules (section \u00a7 ) Failure to verify any nonce with the previously transmitted value (section \u00a7 for example) Any resource or communications failure that makes successful onboarding fail The Secure Device Onboard protocol is always terminated after an error message, and all Secure Device Onboard error conditions send an error message. However, security errors might not indicate the exact cause of the problem, if this would cause a security issue. The contents of the error message are intended to help diagnose the error. The \u201cec\u201d tag is an error code, please see following section, Error Code Values, for detailed information. The \u201cemsg\u201d tag gives the message ID of the previous message, making it easier to put the error into context. The \u201cem\u201d tag gives a string suitable for logging about the error. The string in the \u201cem\u201d tag must not include security details that are inappropriate for logging, such as a specific security condition, or any key or password information. Table 3 - Error Message Content and Meanings Type\\# Message Type Name Message Contents From To REST Transmission 255 Error { #Error message body \"ec\": Uint16, \"emsg\": UInt8, \"em\": String } Any Any HTTP response with message type 255 when transmitted as HTTP response POST /mp/VVV/msg/255, when transmitted as HTTP request If the problem is found in a HTTP request, the ERROR message is sent as HTTP response. The body of the response is a Secure Device Onboard/JSON* message with message type 255, and the \u201cemsg\u201d tag indicates the message type of the HTTP request message. The flow is as follows: HTTP request: POST /mp/VVV/msg/X, msg type = X HTTP response: msg type = ERROR(255), emsg = X Secure Device Onboard terminates in error on both sides If the problem is found in a HTTP response, the ERROR message is sent as a new HTTP request, POST /mp/VVV/msg/255, and the \u201cemsg\u201d tag indicates the message type of the previous HTTP response message. The authentication token from the previous HTTP request appears in the HTTP request containing the ERROR message. Since the ERROR message terminates the Secure Device Onboard protocol, the HTTP response to an ERROR message is an HTTP empty message (zero length). The flow is as follows: HTTP request: POST /mp/VVV/msg/Y, msg type = Y (for any message type Y) HTTP response: msg type = X HTTP request, POST /mp/VVV/msg/255: msg type = 255, emsg = X HTTP response: <zero length> Secure Device Onboard terminates in error on both sides ERROR messages are never retransmitted, and an ERROR message must never generate an ERROR message in response.","title":"Error Message"},{"location":"protocol-specification/data-transmission-persistence/#error-code-values","text":"Table 4 - Error Codes Error Code (EC) Internal Name Generated by Message Description 001 INVALID_JWT_TOKEN DI.SetHMAC TO0.OwnerSign TO1.ProveToSDO TO2.HelloDevice TO2.GetOPNextEntry TO2.ProveDevice TO2.NextDeviceServiceInfo TO2.Done JWT token is missing or authorization header value does not start with 'Bearer'. Each token has its own validity period, server rejects expired tokens. Server failed to parse JWT token or JWT signature did not verify correctly. The JWT token refers to the token mentioned in section \u00a7 (which is not required by protocol to be a JWT token). The error message applies to non-JWT tokens, as well. 002 INVALID_OWNERSHIP_PROXY TO0.OwnerSign Ownership Voucher is invalid: One of Ownership Voucher verification checks has failed. Precise information is not returned to the client but saved only in service logs. 003 INVALID_OWNER_SIGN_BODY TO0.OwnerSign Verification of signature of owner message failed. TO0.OwnerSign message is signed by the final owner (using key signed by the last Ownership Voucher entry). This error is returned in case that signature is invalid. 004 INVALID_IP_ADDRESS TO0.OwnerSign IP address is invalid. Bytes that are provided in the request do not represent a valid IPv4/IPv6 address. 005 INVALID_GUID TO0.OwnerSign GUID is invalid. Bytes that are provided in the request do not represent a proper GUID. 006 RESOURCE_NOT_FOUND TO1.HelloSDO TO2.HelloDevice The owner connection info for GUID is not found. TO0 Protocol wasn't properly executed for the specified GUID or information that was stored in database has expired and/or has been removed. 100 MESSAGE_BODY_ERROR DI.AppStart DI.SetHMAC TO0.Hello TO0.OwnerSign TO1.HelloSDO TO1.ProveToSDO TO2.HelloDevice TO2.GetOPNextEntry TO2.ProveDevice TO2.NextDeviceServiceInfo TO2.GetNextOwnerServiceInfo TO2.Done Message Body is structurally unsound: JSON* parse error, or valid JSON*, but is not mapping to the expected Secure Device Onboard type (see section \u00a7 ) 101 INVALID_MESSAGE_ERROR TO0.OwnerSign TO1.HelloSDO TO1.ProveToSDO TO2.HelloDevice TO2.GetOPNextEntry TO2.ProveDevice TO2.NextDeviceServiceInfo TO2.GetNextOwnerServiceInfo Message structurally sound, but failed validation tests. The nonce didn\u2019t match, signature didn\u2019t verify, hash, or mac didn\u2019t verify, index out of bounds, and others... 500 INTERNAL_SERVER_ERROR DI.AppStart DI.SetHMAC TO0.Hello TO0.OwnerSign TO1.HelloSDO TO1.ProveToSDO TO2.HelloDevice TO2.GetOPNextEntry TO2.ProveDevice TO2.NextDeviceServiceInfo TO2.GetNextOwnerServiceInfo TO2.Done Something went wrong which couldn\u2019t be classified otherwise. (This was chosen to match the HTTP 500 error code.)","title":"Error Code Values"},{"location":"protocol-specification/data-transmission-persistence/#persisted-messages","text":"Table 5 - Persisted Messages Information Type# Message Type Name Description 1 PM.CredOwner This is the Ownership Credential that is stored in the device TEE during the Device Initialize Protocol (DI), and updated in Transfer Ownership 2 Protocol (TO2). 2 PM.CredMfg This is the Manufacturing Credential that is stored in the device TEE during the Device Initialize Protocol (DI). It is never changed afterwards. 3 PM.OwnershipProxy The [Ownership Voucher] is used to convey the trust of the device in the factory to the new owner. 4 PM.PublicKey This message is used by each successive owner in the supply chain to identify his public key to the previous owner. The previous owner signs the public key (and other information) to extend the ownership voucher. 5 PM.ServiceInfo This message is used to save the key-value pairs that are sent as part of the TO2.ReceiveDeviceInfo and TO2.SendSetupInfo messages. 6 PM.DeviceCredentials This message is used to store the device state for implementations that use a filesystem instead of a TEE. It may also be signed or encrypted (sealed) in these implementations, to improve security.","title":"Persisted Messages"},{"location":"protocol-specification/data-transmission-persistence/#device-initialize-protocol-di","text":"Table 6 - Device Initialize Protocol - Message Information Type\\# Message Type Name Message Contents From To REST Transmission 10 [DI.AppStart] { \"m\": String } Dev TEE Mfg station POST /mp/VVV/msg/10 2 11 [DI.SetCredentials] { \"oh\": { \"pv\": UInt16, \"pe\": UInt8, \"r\": Rendezvous, \"g\": GUID, \"d\": String \"pk\": PublicKey \"hdc\": Hash #Absent if using Intel EPID } } Mfg station Dev TEE (post response, includes authorization token) 12 [DI.SetHMAC] { \"hmac\": Hash } Dev TEE Mfg station POST /mp/VVV/msg/12 13 [DI.Done] \\-no body- Mfg station Dev TEE (post response with token)","title":"Device Initialize Protocol (DI)"},{"location":"protocol-specification/data-transmission-persistence/#transfer-ownership-protocol-0-to0","text":"Table 7 - Transfer Ownership Protocol 0 \u2013 Message Information Type# Message Type Name Message Contents From To REST Transmission 20 [TO0.Hello] -no body- New Owner Client Rendezvous Server POST /mp/VVV/msg/20 21 [TO0.HelloAck] { \"n3\": Nonce } Rendezvous Server New Owner Client (post response, includes authorization token) 22 [TO0.OwnerSign] { \"to0d\": { \"op\": OwnershipProxy, \"ws\": UInt32, \"n3\": Nonce }, \"to1d\": { # Sign with Owner key \"bo\": { \"i1\": IPAddress, \"dns1\": String, \"port1\": UInt16, \"to0dh\": Hash }, \"pk\": PKNull, \"sg\": Signature #Owner key } } New Owner Client Rendezvous Server POST /mp/VVV/msg/22 25 TO0.AcceptOwner { \"ws\": Uint32 } Rendezvous Server New Owner Client (post response with token)","title":"Transfer Ownership Protocol 0 (TO0)"},{"location":"protocol-specification/data-transmission-persistence/#transfer-ownership-protocol-1-to1","text":"Table 8 - Transfer Ownership Protocol 1 \u2013 Message Information Type\\# Message Type Name Message Contents From To REST Transmission 30 [TO1.HelloSDO] { \"g2\": GUID, # device GUID. \"eA\": SigInfo } Device TEE Rendezvous Server POST /mp/VVV/msg/30 *GUID added to help token creation* 31 [TO1.HelloSDOAck] { \"n4\": Nonce, \"eB\": SigInfo } Rendezvous Server Device TEE (post response, includes authorization token) (please see section \u00a7 ) 32 [TO1.ProveToSDO] { \"bo\": { \"ai\": AppId, \"n4\": Nonce, \"g2\": GUID }, \"pk\": PublicKey, #PKNull if ECDSA \"sg\": Signature } Device TEE Rendezvous Server POST /mp/VVV/msg/32 33 [TO1.SDORedirect] { \"bo\": { \"i1\": IPAddress, \"dns1\": String, \"port1\": UInt16, \"to0dh\": Hash }, \"pk\": PKNull, \"sg\": Signature } Rendezvous Server Device TEE (post response with token)","title":"Transfer Ownership Protocol 1 (TO1)"},{"location":"protocol-specification/data-transmission-persistence/#transfer-ownership-protocol-2-to2","text":"Table 9 - Transfer Ownership Protocol 2 \u2013 Message Information Type# Message Type Name Message Contents From To REST Transmission 40 [TO2.HelloDevice] { \"g2\": GUID, \"n5\": Nonce, \"pe\": UInt8, \"kx\": String, \"cs\": String, \"eA\": SigInfo } Device TEE New Owner Client POST /mp/VVV/msg/40 41 [TO2.ProveOpHdr] {# Signature of OP Owner Key bo: { \"sz\": UInt8, \"oh\": OwnershipProxyHdr, \"hmac\":Hash, \"n5\": Nonce, \"n6\": Nonce, \"eB\": SigInfo, \"xA\": KeyExchange }, \"pk\": PublicKey, \"sg\": Signature } New Owner Client Device TEE (post response, includes authorization token) Note: In this message, the pk tag must have the actual Owner key (not PKNull) to allow Device to verify signature immediately. 42 [TO2.GetOpNextEntry] { \"enn\": UInt8 } Device TEE New Owner Client POST /mp/VVV/msg/42 43 [TO2.OpNextEntry] { \"enn\":UInt8, \"eni\":OwnershipProxyEntry } New Owner Client Device TEE (post response with token) 44 [TO2.ProveDevice] { \"bo\": { \"ai\": AppId, \"n6\": Nonce, \"n7\": Nonce, \"g2\": GUID, \"nn\": UInt8, \"xB\": DHKeyExchange }, \"pk\": PublicKey, \"sg\": Signature } Device TEE New Owner Client POST /mp/VVV/msg/44 Note: For EPID, \"pk\" contains EPID group number. Otherwise, it is PKNull. 45 [TO2.GetNext DeviceServiceInfo] { \"nn\": UInt8, \"psi\": String } New Owner Client Device TEE (post response with token) 46 [TO2.Next DeviceServiceInfo] { \"nn\u201d: UInt8, \"dsi\":ServiceInfo } Device TEE New Owner Client POST /mp/VVV/msg/46 47 [TO2.SetupDevice] { \"osinn\":UInt8, \"noh\":{ \"bo\":{ \"r3\": Rendezvous, \"g3\": GUID, GUID \"n7\": Nonce }, \"pk\": PublicKey, #Owner2 \"sg\": Signature } } New Owner Client Device TEE (post response with token) Note: This is the \u201cowner2\u201d key, the replacement for the manufacturer\u2019s key in the DI Protocol. It must not be PKNull. 48 [TO2.GetNext OwnerServiceInfo] { \"nn\":Uint8 } Device TEE New Owner Client POST /mp/VVV/msg/48 49 [TO2.Next OwnerServiceInfo] { \"nn\": UInt8, \"sv\": ServiceInfo } New Owner Client Device TEE (post response with token) 50 [TO2.Done] { \"hmac:\": Hash, \"n6\": Nonce } Device TEE New Owner Client POST /mp/VVV/msg/50 51 [TO2.Done2] { \"n7\": Nonce } New Owner Client Device TEE (post response with token) When testing on a single machine, it is useful to use non-standard ports, such as the TCP stream ports (8040, 8041, 8042). However, in service and by default, standard ports should be used. \u21a9 /mp/VVV means \u2018/mp/\u2019 followed by the protocol version. For example, version 1.13 would use /mp/113. \u21a9","title":"Transfer Ownership Protocol 2 (TO2)"},{"location":"protocol-specification/detailed-protocol-description/","text":"Detailed Protocol Description \u00b6 This section defines protocol messages and interactions. Protocol message names match the table, in section \u00a7 : Message Types*. The notation for each message is based on JavaScript* Object Notation (JSON). The message is presented as a message header and a JSON* object as body. The body uses comments to indicate the meaning of particular JSON* elements. Note that these comments and the whitespace are illegal to be transmitted within the JSON* encoding described in section \u00a7 , and are provided for explanation only. Composite types described in the tables in section \u00a7 are used freely. These are also expanded out in some cases, to allow comments on the internal members. In this case, the opening bracket should contain a comment to indicate the composite type. General Messages \u00b6 Error - Type 255 \u00b6 Message Body: { #Error message body \"ec\": Uint16, # Error code \"emsg\": UInt8, # Message ID of the previous message \"em\": String # Error string } Message Meaning: The error message indicates that the previous protocol message could not be processed. The error message is described in detail in section \u200e \u00a7 . Persisted Messages \u00b6 Persisted messages are messages that are stored on non-volatile media and retrieved later. They may also be transmitted outside of the Secure Device Onboard protocols, such as in e-mail messages, and act as an interchange format. Since all Secure Device Onboard messages are printable ASCII, persisted messages may be generated and parsed in exactly the same way as transmitted messages, with only their message type to distinguish them as persisted. Persisted messages always contain the JSON* 4-element sequence encapsulation, as described in section \u00a7 . The 4-element JSON* encapsulation always appears for these messages when they are stored. For example, if the PM.PublicKey type\u2019s body is the 16 characters: {\"pk\":[0,0,[0]]} (This is a null public key, not very useful.) Then the persisted message will actually be: [\"001d\",4,7,{\"pk\":[0,0,[0]]}] Where the \u201c001d\u201d in the 4-character length field indicates that the entire message is 29 bytes (=0x1d) long. PM.CredOwner, Type 1 \u00b6 Stored in Device TEE This is the Ownership Credential that is stored in the device TEE during the Device Initialize Protocol (DI), and updated in Transfer Ownership 2 Protocol (TO2). Message Body: { # OwnerBlock \"pv\": UInt16, \"pe\": UInt8, \"g\": Guid, \"r\": RendezvousInfo, \"pkh\": Hash } Message Meaning: The \u201cpv\u201d parameter specifies the protocol version as a UInt16, in the same format as the message header. The protocol version must be persisted whether the message header information is available or not (For example, in the Device TEE). The \u201cpe\u201d parameter specifies the key encoding used in this credential, and in ownership proxies based on this credential. The GUID parameter \u201cg\u201d is the current device GUID, to be used for the next ownership transfer. The RendezvousInfo parameter \u201cr\u201d contains instructions on how to find the Secure Device Onboard Rendezvous Server. The Public Key Hash \u201cpkh\u201d is a hash of the Owner\u2019s public key, which must match the first entry of the Ownership Voucher used to transfer ownership for this device. The recommended default hash to use is SHA-256 (Secure Device Onboard 1.0 & Secure Device Onboard 1.1 protocol spec; SHA-384 for future crypto). PM.CredMfg, Type 2 \u00b6 Stored in Device TEE: This is the Manufacturing Credential that is stored in the device TEE during the Device Initialize Protocol (DI). It is never changed afterwards. Message Body: { # ManufacturerBlock \"d\": String } Message Meaning: The DeviceInfo parameter \u201cd\u201d is the manufacturer\u2019s DeviceInfo field. This may be used to identify the device model. PM.OwnershipProxy, Type 3 \u00b6 The [Ownership Voucher] (previously called as Ownership Proxy) is used to convey the trust of the device in the factory to the new owner. The OwnershipProxy structure is shown in Table \u200e1: Table 1 - OwnershipProxy Structure OwnershipProxy { \"sz\": UInt8, # number of entries \"oh\": { \"pv\": UInt16, # protocol version \"pe\": UInt8, # public key encoding \"r\": Rendezvous, # rendezvous \"g\": GUID, # guid \"d\": String, # DeviceInfo \"pk\": PublicKey, # mfg public key \"hdc\": Hash # hmac[secret, \u201coh\u201d] # Hash of device certificate chain, absent if using Intel<sup>\u00ae</sup> EPID }, \"hmac\": HMac, \u201cdc\u201d: CertChain, # Device certificate chain, absent if EPID \"en\": [# entries. OwnershipProxyEntry[0], \u2026 OwnershipProxyEntry\\[SZ-1] ]#(Actually, zero entries are permitted, and looks like \"en\":[],) } Note: When \"sz\" is zero, \"en\" is []. CertChain [ type(Uint8), # format of certificate entries (1==x509) numEntries(Uint8), # number of certificate entries [ # Array of certs from Device to CA, each signed by next Cert[0], \u2026 Cert[numEntries-1] ] ] Cert [ length(Uint16), # number of bytes in certificate certBytes(ByteArray) # certificate data in DER encoded to ByteArray format ] OwnershipProxyEntry { bo:{ \"hp\": Hash, # hash of previous entry (only the \u201cbo\u201d) \"hc\": Hash, # hash[GUID||DeviceInfo] in header* \"pk\": PublicKey # public key being signed }, \"pk\": PKNull, # place holder (null pub key) \"sg\": Signature # signature } Note: GUID||DeviceInfo indicates the bitwise concatenation of the \"g\" and \"d\" fields from the ownership proxy header. Message Meaning: The \u201coh\u201d field contains header information, a copy of which is stored in the Device (the Device stores only a hash of the public key \u201coh.pk\u201d). The \u201coh\u201d field\u2019s contents are hashed into \u201chmac\u201d by the device TEE and combined with a secret, which is only stored in the device TEE. \u201coh.pv\u201d is the protocol version (major version * 100 + minor version). \u201coh.pe\u201d is the protocol encoding used in all Ownership Voucher public keys. \u201cr\u201d is the rendezvous info for connecting to the Rendezvous Server. \u201cg\u201d is the current GUID of the device. For ECDSA device attestation, the device certificate chain is present in the Ownership Voucher as OwnershipProxy.dc (device certificate). This is of type CertChain. When the device uses an Intel \u00ae EPID root of trust, OwnershipProxy.dc is not present. \u201cpk\u201d is the public key of the device\u2019 initial owner (For example, the manufacturer). The \u201cen\u201d tag contains the Ownership Voucher entries, in order. If there are no entries (\u201csz\u201d is zero) the \u201cen\u201d tag is an empty array ([]). PM.PublicKey, Type 4 \u00b6 This message format is used by each successive owner in the supply chain to identify his public key to the previous owner. The previous owner signs the public key (and other information) to extend the ownership voucher. See section \u00a7 : The Ownership Voucher. Message Body: { \"pk\": PublicKey } Message Meaning: For a description of the various public key formats, see section \u00a7 : Public Key Types. For a description of how the public key of the new Owner is used to extend the Ownership Voucher, see section \u00a7 : Build The Ownership Voucher. PM.ServiceInfo, Type 5 \u00b6 Stored in Device Filesystem: This message format is used to save the key-value pairs that are sent as part of the TO2.ReceiveDeviceInfo and TO2.SendSetupInfo messages. Message Body: { \"k1\": \"v1\", # note: k1 must be ASCII \"k2\": \"v2\", # note: k2 must be ASCII \u2026 \"kN\": \"vN\" #note: kN must be ASCII } Note - k1, k2, \u2026 kN must all be unescaped ASCII. For example: \"abc\" is legal, but \"a\\u0062c\" is illegal. This does mean that keys cannot have special characters in them. However, values can have escaped characters, as needed, to support the full Unicode set. Message Meaning: ServiceInfo is a set of key-value pairs that is used in a negotiation between the Device and the Owner during the TO2 Protocol. A set of key-value pairs, the Device ServiceInfo is first transmitted from the Device to the Owner. Then a set of key-value pairs, the Owner ServiceInfo, is sent from the Owner to the Device. Definitions of ServiceInfo key-value pairs is given in section \u00a7 . PM.DeviceCredentials, Type 6 \u00b6 Stored in Device Filesystem: This message format is suggested to store the device state for implementations that use a filesystem instead of a TEE. It may also be signed or encrypted (sealed) in these implementations, to improve security. A given implementation may also use another, more convenient, format. Message Body: { \"ST\": UInt8, # State \"Secret\": ByteArray, \"M\": {#ManufacturerBlock \"d\": String }, \"O\": {#OwnerBlock \"pv\": UInt16, \"pe\": UInt8, \"g\": Guid, \"r\": RendezvousInfo, \"pkh\": Hash } } Message Meaning: \u201cST\u201d is the Secure Device Onboard state, as defined in the Secure Device Onboard architectural specification. \u201cM\u201d is the manufacturer state. \u201cO\u201d is the owner state. Device Initialize Protocol (DI) \u00b6 The Device Initialize Protocol (DI) serves to set the manufacturer and owner of the device in the TEE. It is assumed to be performed at device manufacture time. This protocol uses a Trust On First Use (TOFU) trust model, consistent with the Secure Device Onboard assumption that the manufacturing environment is trusted. It would be possible to implement a more restricted trust model for the DI Protocol by embedding a public key into the TEE, with the TEE owner providing signing (or at least CA) services to the manufacturer. The DI Protocol runs between a manufacturing support station, which contains the Secure Device Onboard Manufacturing Component, and the Device TEE. The Device is assumed to be running with some other kind of support software, which is able to access the TEE and provide communications services for it. For example, the device may be PXE-booted into a RAM-based Linux* system, with features to access the TEE. It is assumed that this software is able to determine from its environment the IP address for the manufacturing support station. DI Protocol Diagram DI.AppStart, Type 10 \u00b6 From Device TEE to Manufacturer: The App Start message starts talking to the TEE application to start. Downloading, verifying, and starting the TEE application is outside the scope of this document. Message Format: { \"m\": String } Message Meaning: Start the process of taking initial ownership of the device. If available, the device may include a serial number or other identifying mark from the hardware in this message, using the \u201cm\u201d tag. This is intended to help the manufacturing station to index Secure Device Onboard information with other information available to the manufacturer. If no such information is available, the \u201cm\u201d tag is sent with an empty string. The manufacturing station must always be able to handle a device that sends an empty string for tag \u201cm.\u201d DI.SetCredentials, Type 11 \u00b6 From Manufacturer to Device TEE: Message Format: { \"oh\":{# See Ownership Voucher \u201coh\u201d tag. \"pv\": UInt16, \"pe\": UInt8, \"r\": Rendezvous, \"g\": GUID, \"d\": String, \"pk\": PublicKey, \"hdc\": Hash # Absent if using Intel EPID } } Message Meaning: The manufacturing station sends credentials to the Device TEE. The credentials in \"oh\" are identical to the \u201coh\u201d field of the Ownership Voucher (see section \u00a7 ). Some additional credentials allow the original manufacturer of the device to be determined across future ownership transfers. When the device uses ECDSA method for device attestation, the manufacturing station will compute the Hash of the device certificate chain (provided by the manufacturer to the manufacturing tool) and include the Hash as \u201coh.hdc\u201d in the message. When the device uses Intel \u00ae EPID root of trust, this field must not be present. The manufacturing station typically will use the \u201cm\u201d tag (see section \u00a7 ) to determine information for \u201coh.r,\u201d \u201coh.d\u201d and \u201coh.pk.\u201d The \u201coh.g\u201d field (GUID) shall be a secure-randomly created unique identifier and not derived in any way from device-specific information to ensure the privacy of the protocol. The Device TEE allocates a secret, stores this information in the Device TEE as PM.DeviceCredentials, along with the secret. The public key oh.pk is stored as a hash of the public key oh.pk. The Device does not have to use the persisted message format for PM.DeviceCredentials, as long as the information can be accurately retrieved on demand. The Device TEE also computes an HMAC based on the above secret and the entire contents of this message body (including the brace brackets). This HMAC is used in the next message. DI.SetHMAC, Type 12 \u00b6 From Device TEE to Manufacturer: Message Format: { \"hmac\": Hash } Message Meaning: The device TEE returns the HMAC of the internal secret and the DI.SetCredentials.oh tag, as mentioned above. The manufacturer combines this HMAC with its own transmitted information to create an Ownership Voucher with zero entries. DI.Done, Type 13 \u00b6 From Manufacturer to Device TEE: Message Body: -no-body- Message Meaning: Indicates successful completion of the DI protocol. This message must not be sent before the Credentials associated with the device (see section \u00a7 ) is recoverably persisted in the manufacturing backend to prevent the release of an unusable device due to loss of its Ownership Voucher. Upon receive of this message, the device persists all information associated with the Device Initialization protocol. Transfer Ownership Protocol 0 (TO0) \u00b6 The function of Transfer Ownership Protocol 0 (TO0) is to register the new owner\u2019s current Internet location with the Rendezvous server under the GUID of the device being registered. The Rendezvous server negotiates a length of time during which it will remember the new owner\u2019s current IP address. If the new owner does not receive a device transfer of ownership within this time, it must re-connect to the Rendezvous server to repeat Transfer Ownership Protocol 0. The protocol begins when the Owner Client opens a connection to the Rendezvous Server as is given in the Ownership Voucher. The preferred protocol to use is TLS with server authentication only. The necessary client authentication is provided by the ownership voucher. TO0 Protocol Diagram TO0.Hello, Type 20 \u00b6 From New Owner Client to Rendezvous Server Message Format: -No body- Message Meaning: Initiates the TO0 Protocol, requests a Hello Ack nonce. TO0.HelloAck, Type 21 \u00b6 From Rendezvous Server to New Owner Client Message Format: { \"n3\": Nonce # nonce #3 } Message Meaning: Requests proof of the ownership voucher. TO0.OwnerSign, Type 22 \u00b6 From New Owner Client to Rendezvous Server Message Format: { \"to0d\": { # covered in signature \u201cop\u201d: OwnershipProxy, # Ownership Voucher (complete) \"ws\": UInt32, # how many seconds to wait. \"n3\": Nonce # Freshness of signature }, \"to1d\": { \"bo\": { #sign with \u201cOwner key\u201d \"i1\": IPAddress, # IP address where we are waiting \"dns1\": String, # DNS address where we are waiting (alternative) \"port1\": UInt16, # TCP/UDP port number \"to0dh\": Hash # Hash(to0d object, brace to brace) }, \"pk\": PKNull, \"sg\": Signature # signed with \u201cOwner key\u201d == last public key in \u201cop\u201d. } } Message Meaning: The new owner demonstrates its credentials for a given GUID by providing the Ownership Voucher and signing with the Owner Key. In addition, the owner provides the Internet location where it is waiting for a Device to connect (fields: \u201ci1\u201d, \u201cdns1\u201d, \u201cport1\u201d) and upper bound of how long it is willing to wait (field: \u201cws\u201d). The wait time is negotiated with the server, see TO0.AcceptOwner.ws. After the negotiated wait time passes, the owner must re-run the TO0 Protocol to refresh its mapping. The Ownership Voucher is given in \u201cto0d.op\u201d as a single object. The Ownership Voucher must have at least one entry, such as, to0d.op.bo.sz > 0, or the Rendezvous Service must drop the connection. 1 The Rendezvous Service may also restrict the maximum number of entries it is willing to accept, to prevent DoS attacks. The current recommended maximum is ten entries (to0d.op.bo.sz > 0 && to0d.op.bo.sz \u2264 10). The encoding of this message is divided into two JSON* objects: \u201cto0d\u201d and \u201cto1d\u201d, which are linked by the hash \u201cto0dh\u201d inside of \u201cto1d\u201d. The object \u201cto0d\u201d contains fields that are only used in the TO0 Protocol, and the object \u201cto1d\u201d contains fields that are also used in the TO1 Protocol. The fields in to0d are: to0d.op: The entire Ownership Voucher. The GUID is given in to0d.op.oh.g. The Owner Key is given in to0d.op.en[to0d.op.sz-1].bo.pk (that is, the \u201cbo.pk\u201d in the last OwnershipProxyEntry). The Owner key is used to verify to1d.sg. to0d.ws: The wait time offered by the Owner, which is adjusted and confirmed in TO0.AcceptOwner.ws. to0d.n3: A copy of TO0.HelloAck.n3, used to ensure the freshness of the signature in TO0.to1d.sg. The to1d object is a signed \u201cblob\u201d that indicates an Internet address where the Device can find Owner for the TO2 Protocol. The entire object is stored by the Rendezvous Service and returned verbatim to the Device in the TO1 Protocol. See how this value is verified by the Device in section \u00a7 . The fields in to1d are: to1d.bo.i1: An internet address where the Owner is listening for a TO2 connection. It may be 0.0.0.0 if only \u201cdns1\u201d matters. Since the to1d value has a time limit associated with it (\u201cws\u201d), the server may use the Internet address to create a temporary address that is harder to map to its identity. If both DNS and IP address are specified, the IP address is used only when the DNS address fails to resolve. to1d.bo.dns1: A DNS name where the Owner is listening for a TO2 connection. Any IP address resolved by the DNS name must be equivalently able to process the TO2 connection. A null string (\u201c\u201d) may be used if only the \u201ci1\u201d value matters. to1d.bo.port1: A TCP port where the Owner is listening for a TO2 connection. A value of zero (0) indicates that the default port (80 for HTTP or 443 for HTTPS) is used. to1d.bo.to0dh: A SHA256 or SHA384 hash of the TO0.OwnerSign.to0d object (from brace to brace, inclusive). The Rendezvous Server must verify that to0dh matches the hash of the to0d object (from brace to brace). Otherwise, the Rendezvous Server shall end the connection in error. to1.pk: Always PKNull. to1.sg: Signature of to1d.bo with the Owner key from to0d.op. It is preferred that the Rendezvous Service has a basis on which to trust at least one public key within the Ownership Voucher. For example, the manufacturer who ran the DI protocol to configure the Device, thereby choosing the Rendezvous Service, may register key hashes with the Rendezvous Service to establish such a trust. The Owner may register its own keys additionally, or as an alternative. An intermediate signer of the Ownership Voucher might act as a national point of entry, using its keys to establish trust for devices in the Rendezvous Service as they arrive in country. A given Rendezvous Service may choose to reject Ownership Proxies that are not trusted. If the Rendezvous Service has no basis on which to trust the Ownership Voucher, it must apply its own internal policies to protect itself against a DoS attack, but may otherwise safely provide the Rendezvous Service (that is, it can allow the TO0 and TO1 Protocols to succeed). This behavior is acceptable because the TO2 Protocol is able to verify the to1d \u201cblob\u201d defined in this message. However, such a Rendezvous Service must ensure that untrusted Ownership Proxies cannot degrade the service for trusted Ownership Proxies. This may be accomplished through hard limiting of resources, or even allocating a trusted- and non-trusted version of the service. The Rendezvous Server needs to verify that the signature on this message is verified by the public key on the last message of the ownership voucher, such as by saving the public key transmitted and verifying it is the same public key. In case of ECDSA device attestation method, Rendezvous Service must verify the binding of the certificate to the Ownership Voucher (verify the certificate chain hash). It is the only non-owner entity which can do this. It is recommended that the Service should also do revocation check for the certificate chain. TO0.AcceptOwner, Type 25 \u00b6 From Rendezvous Server to New Owner Client Message Format: { \"ws\": Uint32 # waitSeconds; } Message Meaning: Indicates acceptance of the new Owner. The Rendezvous Server will associate GUID with the new owner\u2019s address information for the waitSeconds seconds. WaitSeconds may not exceed NewOwnerHello.waitSeconds, but it may be less. If the GUID indicated in: TO0.OwnerSign.to0d.bo.op.oh.g is already associated with another IP address, the Rendezvous Server retargets this association as specified in this protocol. The New Owner Client can drop the connection after this message is processed. If the new Owner does not receive a Transfer Ownership connection from a Device within waitSeconds seconds, it must repeat Transfer Ownership Protocol 0 and re-register its GUID to address association. When the new Owner is actively changing its address from time to time (For example, to mask its identity), the frequency of changing address dictates the magnitude of WaitSeconds. Otherwise, the negotiation depends on the frequency at which the new owner wishes to refresh the server, traded off with the server\u2019s need to remember many GUID associations. Note The Rendezvous Server has no sure way to know when a device ownership is successful or fails, since it is not party to the TO2 Protocol. This is intended to make it harder for an intruder who is monitoring the Rendezvous Server to trace a device, even by the Secure Device Onboard GUID (which is replaced in the TO2 Protocol). Thus the Rendezvous Server may arrange to keep the timeouts short enough that it does not have to keep every Secure Device Onboard transaction ever created in its database. We imagine a timeout of a day or two, or perhaps a week or two. Note The type for this message is 25, which is not contiguous with other message types. Earlier versions of this section incorrectly gave the type as 23. Transfer Ownership Protocol 1 \u00b6 Transfer Ownership Protocol 1 (TO1) finishes the rendezvous started between the New Owner and the Rendezvous Server in the Transfer Ownership Protocol 0 (TO0). In this protocol, the Device TEE communicates with the Rendezvous Server and obtains the IP addressing info for the (potential) new Owner. Then the Device may establish trust with the new Owner by connecting to it, using the TO2 Protocol. Note The Transfer Ownership Protocols 0 and 1 serve only to get the Device the IP addressing information for a potential Owner candidate\u2014no trust is conveyed in these protocols. When possible, the TO1 Protocol should arrive at the Rendezvous service under HTTPS to protect the privacy of the Owner. It is possible that intermediate stages of the protocol are run under HTTP, such as from a sensor to a gateway or from a management engine to an OS user process. If it is NOT possible to use HTTPS to protect the TO1 Protocol, the Owner may also take measures to protect its privacy: The Owner may use a private IP address (For example, IPv6 privacy address) and refresh the address periodically, to make it more difficult for an attacker to glean information from the rendezvous address. The Owner may use a multi-tenant model, where the actual Owner of the Device does not relate to the IP address or DNS name of the Owner. Transfer Ownership Protocol 1 (TO1) TO1.HelloSDO, Type 30 \u00b6 From Device TEE to Rendezvous Server: Message Format: { \"g2\": GUID, # device GUID. \"eA\": SigInfo } Message Meaning: Establishes the presence of the device at the Rendezvous Server. The Device GUID is included to help a REST server create a token. It is not otherwise needed. The \u201cg2\u201d variable is the GUID of the Device. This may be used as an index by the Rendezvous Service to look up information associated with the Device. The \u201ceA\u201d variable contains signature related information, as described in section \u00a7 . TO1.HelloSDOAck, Type 31 \u00b6 From Rendezvous Server to Device TEE Message Format: { \"n4\": Nonce, \"eB\": SigInfo } Message Meaning: Sets up Device TEE for next message. The \u201cn4\u201d tag contains a nonce to use as a guarantee of signature freshness in the TO1.ProveTOSDO. The \u201ceB\u201d variable contains signature related information, as described in in section \u00a7 . TO1.ProveToSDO, Type 32 \u00b6 From Device TEE to Rendezvous Server: Message Format: { \"bo\": { \"ai\": AppId, \"n4\": Nonce, \"g2\": GUID, }, \"pk\": PublicKey, # Intel<sup>\u00ae</sup> EPID key for Intel<sup>\u00ae</sup> EPID device attestation; PKNull if ECDSA \"sg\": Signature } Message Meaning: Proves validity of device identity to the Rendezvous Server for the Device seeking its owner, and indicates its GUID, \u201cg2\u201d. AppID provides evidence of the TEE application that is running, which indicates that the behavior may be trusted. It is verified using information from the TEE author (For example, Intel). Nonce4 proves that the signature was just computed, and not a reply (signature \u2018freshness\u2019 test). The field \u201cpk\u201d shall contain the Intel \u00ae EPID public key in case Intel \u00ae EPID device attestation. It shall be PKNull in case of ECDSA device attestation. If the device signature cannot be verified, or fails to verify, the connection is terminated with an error message (see section \u00a7 ). When the device attestation method is Intel \u00ae EPID, the signature is checked with Intel \u00ae EPID group keys (For example, from Intel). In the case of ECDSA, the leaf certificate in the device certificate chain contained in the Ownership Voucher is used to verify the signature. TO1.SDORedirect, Type 33 \u00b6 From Rendezvous Server to Device TEE: Message Format: The exact value of: TO0.OwnerSign.to1d, being: { \"bo\": { \"i1\": IPAddress, # IP address where we are waiting \"dns1\": String, # DNS address where we are waiting (alternative) \"port1\": UInt16, # TCP/UDP port number \"to0dh\": Hash # Hash(to0d object, brace to brace) }, \"pk\": PKNull, \"sg\": Signature # signed with \u201cOwner key\u201d that Device will get in TO2 } Message Meaning: Indicates to the Device TEE that a new Owner is indeed waiting for it, and may be found by connecting to the given DNS name or IP address. If only an IP address is needed, the DNS String can be empty (zero length). If a DNS name is present, the DNS lookup is performed first, and all resolved IP addresses are tried before the given IP address is tried. If the given IP address was one of the IP addresses returned by DNS, it does not have to be tried separately (once is enough). Note This message is bit-for-bit identical to TO1.OwnerSign.to1d. Transfer Ownership Protocol 2 \u00b6 The Device communicates with the Owner Client based on the values in the [TO1.SDORedirect] message. The TO2 Protocol is the most complicated of the protocols in Secure Device Onboard, because it has several steps that are not present in other protocols: Establishes trust in both directions: The Device uses its device attestation key and the Owner uses the Ownership Voucher. Creates an encrypted channel, based on the above trust, using a supported key exchange mechanism. Exchanges device service info for owner service info. The Owner replaces all Secure Device Onboard credentials in the Device (this does not include the Device\u2019s hardware root of trust); the Device gives the Owner an HMAC that allows it to generate a replacement Ownership Voucher. The Owner can use this new Ownership Voucher in future Secure Device Onboard transactions (For example, to resell the Device). In addition, in all these operations, all unbounded data items are divided across multiple messages, to limit the size of an HTTP transaction that the Device is required to process (ideally, each message fits into a single packet; this is not guaranteed at present). This causes several loops in the protocol: The Ownership Voucher is transmitted header first, then entry by entry in successive messages. The service info (in each direction) is transmitted in as many messages as necessary to keep the message size to a single packet. A constrained device may assume that the connection MTU size is 1500 bytes. The Owner should try to keep the size of each service info message down to less than 1300 bytes, to allow constrained device protocols to operate correctly. The ServiceInfo exchange in Secure Device Onboard allows the cooperating client entities on the Device and Owner to negotiate their own \u201cprotocol\u201d for setting up the Device. The names and meanings of key value pairs is generally up to the Device and Owner, but specific (useful) values are given in section \u00a7 . Transfer Ownership Protocol 2 (TO2) Limitation of Round Trip Times \u00b6 The implementation shall complete the Transfer Ownership Protocol 2 in no more than 1,000,000 round trip times, overall. Owner and Device implementations should not request more iterations than this. TO2.HelloDevice, Type 40 \u00b6 From Device TEE to New Owner Client Message Format: { \"g2\": GUID, \"n5\": Nonce, \"pe\": Uint8, # Public key encoding \"kx\": String, # key exchange suite name \"cs\": String, # Ciphersuite name \"eA\": SigInfo # Device attestation signature info } Message Meaning: Sets up new owner for proof of ownership. The \u201cpe\u201d field indicates the preferred public key encoding. The \u201ckx\u201d and \u201ccs\u201d fields indicate the key exchange protocol and cipher suite to use. Because we assume the Device may be constrained, it gets to choose these values; the Owner side must support all choices that a Device can make. The value for \u201ckx\u201d is given in section \u00a7 , either: Secure Device Onboard 1.0 & Secure Device Onboard 1.1 protocol spec: DHKEXid14, ASYMKEX, or ECDH Future crypto: DHKEXid15, ASYMKEX3072, or ECDH384 The cipher suite \u201cbo.cs\u201d is as given here in Table 2. Cipher Suite Names and* Meanings. Other key exchange protocols or cipher suites may be supported in the future. The \u201ceA\u201d tag starts the Device\u2019 signature process. TO2.ProveOPHdr, Type 41 \u00b6 From New Owner Client to Device TEE: Message Format: { # Signature of OP Owner Key bo: { \"sz\": UInt8, # Ownership Voucher \u201csz\u201d tag \"oh\": {#Ownership Voucher Hdr \"pv\": UInt16, \"pe\": UInt8, \"r\": Rendezvous, \"g\": GUID, \"d\": String, \"pk\": PublicKey, \"hdc\": Hash # Absent if using Intel EPID }, \"hmac\":Hash, # Ownership Voucher \u201chmac\u201d tag \"n5\": Nonce, # n5 from TO2.HelloDevice \"n6\": Nonce, # used below in TO2.ProveDevice and TO2.Done \"eB\": SigInfo, # Device attestation signature info \"xA\": KeyExchange # Key exchange first step }, \"pk\": PublicKey, # owner public key, may not be PKNull \"sg\": Signature } Message Meaning: This message serves several purposes: The Owner begins sending the Ownership Voucher to the device (only the header is in this message). The Owner signs the message with the Owner key (the last key in the Ownership Voucher), allowing the Device to verify (later on) that the Owner controls this private key. The Owner starts the key exchange protocol by sending the initial key exchange parameter xA (For example, in Diffie Hellman, the parameter \u2018A\u2019) to the Device. The Ownership Voucher\u2019s header is sent in the \u201coh\u201d and \u201chmac\u201d tags. The \u201csz\u201d tag gives the number of Ownership Voucher Entries. The entries will be sent in subsequent messages. It is legal for the \u201csz\u201d tag to have a value of zero (0), but this is only useful in re-manufacturing situations since the Rendezvous Service cannot verify (or accept) these Ownership Proxies. The \u201chmac\u201d tag is a HMAC-SHA256 (Secure Device Onboard 1.0 and Secure Device Onboard 1.1 protocol spec) or HMAC-SHA384 (future crypto) over the \u201coh\u201d tag. The HMAC key is the one that was created in the Device during the DI Protocol (or stored in the Device, if an alternate mechanism is used to initialize the Device). The Device re-computes the HMAC value against the received contents of the \u201coh\u201d tag using this stored secret, and verifies that the \u201chmac\u201d tag has the same value. This ensures that the Device itself has not been reinitialized since it was originally programmed during manufacturing. For ECDSA device attestation method, the New Owner Client includes the hash of device certificate chain from Ownership Voucher (OP.oh.hdc) in the TO2.ProveOPHdr message (as TO2.ProveOPHdr.bo.oh.hdc) for the device to verify the HMAC. The device temporarily saves the oh.hdc on receiving the message. When the device computes the new HMAC based on the fields received inTO2.SetupDevice message, it uses the value of TO2.ProveOPHdr.bo.oh.hdc that was previously saved. The new HMAC is returned to the New Owner Client as part of TO2.Done message The public key \u201cpk\u201d is the Owner Key. This key, which verifies the message signature (\u201csg\u201d), must be compared with the public key in the last Ownership Voucher Entry when it is received (later in the sequence of this protocol). 2 This key must also be able to verify the signature of the TO1.SDORedirect message. The Device must store the TO1.SDORedirect message (or its hash) until the TO2.ProveOPHdr message is received. At this time, the Device can verify the TO1.SDORedirect signature with the give Owner key in TO2.ProveOPHdr.pk. If the TO1.SDORedirect signature does not verify, the Device must assume that a man in the middle is monitoring its traffic, and fail immediately with an error code message. The bo.eB field continues the Device\u2019 signing process. The bo.xA field begins the key exchange protocol. See section \u00a7 for more details on key exchange. The key exchange is finished in the TO2.ProveDevice message (section \u00a7 ). The verification of this message is critical, but may be a little hard to understand. The Device initially verifies this message\u2019s signature \u201csg\u201d using the supplied key \u201cpk\u201d, then saves a copy of this key (for memory reasons, the Device may save a SHA hash of the key). As the Ownership Voucher entries are transmitted in successive TO2.GetOPNextEntry messages, the Device can verify them using the signature chain embedded in the Ownership Voucher, from header to entry 1 to entry 2, and so on. The last such entry signs bo.pk, which is called the \u201cowner key\u201d. Now the Device must verify that the Owner can sign with this bo.pk public key\u2019s corresponding private key. But if this bo.pk matches the TO2.ProveOPHdr.pk, then the signature verification at the start has verified exactly this. The following diagram illustrates the process, using only the signature chain, for an Ownership Voucher 3 entries: Verification of Ownership Voucher by Device TO2.GetOPNextEntry, Type 42 \u00b6 From Device TEE to New Owner Client: Message Format: { \"enn\": UInt8 } Message Meaning: Acknowledges the previous message and requests the next Ownership Voucher Entry. TO2.OPNextEntry, Type 43 \u00b6 From New Owner Client to Device TEE Message Format: { \"enn\":UInt8, \"eni\":{ \"bo\":{ \"hp\": Hash, \"hc\": Hash, \"pk\": PublicKey }, \"pk\": PKNull, \"sg\": Signature } } Message Meaning: Transmits the requested Ownership Voucher entry from the New Owner to the Device TEE. The value of tag \u201cenn\u201d matches the value of TO2.GetOPNextEntry.enn. If enn == TO2.ProveOPHdr.bo.sz-1, then the next state is TO2.ProveDevice. Otherwise the next state is TO2.GetOPNextEntry. The Device TEE verifies the ownership voucher entries incrementally as follows: Variables: hp \u2013 hash of previous entry. The hash only covers the \u201cbo\u201d in the previous entry with the \u201cbo:\u201d tag but includes the enclosing braces . For the first entry, the hash is SHA [TO2.ProveOPHdr.bo.oh||TO2.ProveOpHdr.bo.hmac]. pk \u2013 public key signed in previous entry (initialize with TO2.ProveOPHdr.bo.oh.pk) hc \u2013 hash of GUID and DeviceInfo, compute from TO.OwnerSign.bo as: SHA[TO2.ProveOPHdr.bo.oh.g||TO2.ProveOPHdr.bo.oh.d] Use SHA256 (Secure Device Onboard 1.0 and Secure Device Onboard 1.1 protocol spec) or SHA384 (future crypto). Pad the hash text on the right with zeros to match the hash length. For each entry: Verify signature TO2.OPNextEntry.eni.sg using variable pk Verify variable hc matches TO2.OPNextEntry.eni.bo.hc Verify hp matches TO2.OpNextEntry.eni.bo.hp Update variable pk TO2.OPNextEntry.eni.bo.pk Update variable hp SHA [TO2.OpNextEntry.eni.bo] (SHA256 for Secure Device Onboard1.0 and Secure Device Onboard 1.1 protocol spec and SHA384 for future crypto) If enn == TO2.ProveOpHdr.bo.sz-1 then verify TO2.ProveOPHdr.pk == TO2.OpNextEntry.eni.bo.pk TO2.ProveDevice, Type 44 \u00b6 From Device TEE to New Owner Client Message Format: { # Signature \"bo\": { \"ai\": AppId, # proves App provenance within TEE \"n6: Nonce, # proves signature freshness \"n7: Nonce, # used in TO2.SetupDevice \"g2\": GUID, # proves the GUID matches with g2 in TO2.HelloDevice and TO2.Done2 \"nn\": UInt8, # number of device service info messages to come \"xB\": DHKeyExchange # Key Exchange, 2nd Step }, \"pk\": PublicKey, # Intel<sup>\u00ae</sup> EPID key for Intel<sup>\u00ae</sup> EPID device attestation; PKNull if ECDSA \"sg\": Signature } Message Meaning: Proves the provenance of the device to the new owner, using the device attestation signature (\u201csg\u201d) based on the challenge (nonce) \u201cn6\u201d. If the signature cannot be verified, or fails to verify, the connection is terminated with an error message (section \u00a7 ). Completes the key exchange, by sending \u201cxB\u201d. Sends \u201cn7\u201d for later use. Sends \u201cnn\u201d to indicate number of TO2.GetNextDeviceServiceInfo messages. The field \u201cpk\u201d shall contain the Intel \u00ae EPID public key in case of Intel \u00ae EPID device attestation. It shall be PKNull in case of ECDSA device attestation. Note Subsequent message bodies are HMac\u2019d and Encrypted. See section \u200e \u00a7 for more details on key exchange. TO2.GetNextDeviceServiceInfo, Type 45 \u00b6 From New Owner Client to Device TEE Message Format - after decryption and verification of HMAC: { \"nn\": UInt8, #Index of device service info message expected \"psi\": String # extra for this version of protocol only } Message Meaning: Acknowledges the TO2.ProveDevice message. Requests the next Device Service Info message. \u201cnn\u201d is the index of the next device service info expected, starting at zero. \u201cpsi\u201d is an optional string that may be used to inform the Device before it generates the Device Service Info. The value of \u201cpsi\u201d is only significant when \u201cnn\u201d == 0, and otherwise \u201cpsi\u201d must be the empty string. The value of \u201cpsi\u201d may be used when the Device Service Info is dependent on information from the Owner. For example, if the Owner needs the Device to allocate 4 key pairs, the \u201cpsi\u201d variable may be used to transmit the number \u201c4\u201d as a string.[^23] [^23]: This facility is intended to work around a problem that will be solved by multiple \u201crounds\u201d of Service Info in a future release of Secure Device Onboard. TO2.NextDeviceServiceInfo, Type 46 \u00b6 From Device TEE to New Owner Client Message Format - after decryption and verification of HMAC: { \"nn\": UInt8, # index of this message, from zero upwards. \"dsi\": ServiceInfo # service info entries to add or append to previous ones. } Message Meaning: Sends as many Device to Owner ServiceInfo entries as will conveniently fit into a message, based on protocol and Device constraints. When entries are received with the same name, the second and subsequent entries are concatenated onto the end of the previous entry. For example, a 3000 byte entry \u201ccert\u201d might be sent in 3 successive TO2.DeviceServiceInfo messages, one containing a \u201ccert\u201d entry with the first 1000 bytes, the second containing a \u201ccert\u201d entry with the second 1000 bytes, and the third containing a \u201ccert\u201d entry with the last 1000 bytes. This facility is intended to allow ServiceInfo entries to be large, but still fit into constrained message sizes. If \u201cnn\u201d == TO2.ProveDevice.bo.nn-1 then the next message is TO2.SetupDevice. Otherwise, the next message is TO2.GetNextDeviceServiceInfo. Note ServiceInfo messages might need to be converted to use \\uFFFF syntax to avoid internal characters. TO2.SetupDevice, Type 47 \u00b6 From New Owner Client to Device TEE Message Format - after decryption and verification of HMAC: { \"osinn\":UInt8, # number of service info messages to come \"noh\":{ # update to ownership voucher header for resale. \"bo\":{ \"r3\": Rendezvous, # replaces stored Rendevous \"g3\": GUID, # replaces stored GUID \"n7\": Nonce # proves freshness of signature }, \"pk\": PublicKey, # Owner2 key (replaces Manufacturer\u2019s key). \"sg\": Signature # Proof of Owner2 key. } } Message Meaning: This message effects ownership transfer, causing the credentials previously used to take over the device to be replaced. If we recall the credentials programmed in the DI protocol, these are now updated based on the new credentials downloaded from the new Owner. Table 2 - Message Meaning Transformation - DI to T02 Old Entry (section \u200e5.3.1) New Value (Typical use case) New Value (Credential Reuse) Comments DI.SetCredentials.oh.**pv** unchanged unchanged Protocol version (fixed) DI.SetCredentials.oh.**pe** unchanged unchanged Public key encoding (fixed) DI.SetCredentials.oh.**r** TO2.SetupDevice.noh.bo.**r3** unchanged DI.SetCredentials.oh.**g** TO2.SetupDevice.noh.bo.**g3** unchanged DI.SetCredentials.oh.**d** Unchanged unchanged Manufacturer\u2019s info DI.SetCredentials.oh.**pk** TO2.SetupDevice.noh.**pk** unchanged noh.pk is Owner2 key The \u201cosinn\u201d field gives the number of owner service info messages that will be transmitted to the Device. The Owner should try to keep the size of each service info message down to less than 1300 bytes, to allow constrained device protocols to operate correctly. Note See Section \u00a7 for additional information on Resale protocol, and section \u00a7 for additional information on Credential Reuse protocol. TO2.GetNextOwnerServiceInfo, Type 48 \u00b6 From Device TEE to New Owner Client Message format, after decryption and verification of HMAC: { \"nn\":Uint8 } Message Meaning: Requests next Owner Service Info message. TO2.OwnerServiceInfo, Type 49 \u00b6 From New Owner Client to Device TEE Message Format - after decryption and verification of HMAC: { \"nn\": UInt8, # index of this message, from zero upwards \"sv\": ServiceInfo } Message Meaning: Contains ServiceInfo key value pairs, transmitted from Owner to Device. The Owner should send only enough pairs to keep within the likely constraints of the Device and the protocol. In particular, no more than 1300 bytes of ServiceInfo should be sent in a single message. ServiceInfo entries that are duplicated in subsequent messages are appended to the same named entries at the destination. This makes it possible to send an arbitrary sized ServiceInfo message. See section \u00a7 for information on service info. If TO2.OwnerServiceInfo.nn == TO2.SetupDevice.osinn-1 then the next state is TO2.Done. Otherwise the next state is TO2.GetNextOwnerServiceInfo. TO2.Done, Type 50 \u00b6 From Device TEE to New Owner Client: Message Format - after decryption and verification of HMAC: { \"hmac:\": Hash, \"n6:\": Nonce # Nonce generated by New Owner Client # and sent to Device TEE in Msg TO2.ProveOPHdr } Message Meaning: Indicates successful completion of the Transfer of Ownership. The Client and Owner software now transitions to performing the requested actions between Device and Owner. For example, the Client can activate the scripting implicit in the ServiceInfo data structure received from the Rendezvous Server. The Device TEE discards and regenerates the secret from the DI Protocol. It then generates an \u201chmac\u201d field equivalent to the one in the [DI.SetHMac] message (see section \u00a7 ). The Owner may use this information to construct a new Ownership Voucher based on the Owner2 key and the new information configured into the Device in the TO2.SetupDevice message. This information permits the Owner to effect a new transfer of ownership by re-enabling the Secure Device Onboard software on the Device. If the Device does not support resale (see section \u00a7 ), and wishes to so inform the Owner, the HMAC is returned with zero length. It is legal for the Device to generate a valid HMAC but refuse to support resale at a later time. In this case, it is highly recommended that an out-of-band mechanism be provided to let the Owner know that the resale protocols will not work. If the Device supports Credential Reuse protocol and all the conditions for Credential Reuse are satisfied in TO2.SetupDevice, then a special value of HMAC with length 1 is returned (see section \u200e \u00a7 ). TO2.Done2, Type 51 \u00b6 From New Owner Client to Device TEE: Message Format - after decryption and verification of HMAC: { \"n7:\": Nonce # Nonce generated by Device TEE and send to Owner in TO2.ProveDevice } Message Meaning: This message provides an opportunity for a final ACK after the Owner has invoked the System Info block to establish agent-to-server communications between the Device and its final Owner. When possible, the TO2.Done2 should be delayed until the Device has established agent-to-server communications, allowing an Secure Device Onboard error to occur when such communications fail. On some constrained devices, Secure Device Onboard software might not be able to run after the agent-to-server communications are set up. On these systems, this ACK can happen right after the TO2.Done message. Such systems cannot recover from a failure that appears after Secure Device Onboard has finished, but that prevents agent-to-server communications from being established. Examples of systems that cannot generate a response after agent-to-server communications are working include: Constrained systems that don\u2019t have enough resources to run both Secure Device Onboard and the agent-to-server subsystems. Systems that require a reboot to complete agent-to-server setup. After Transfer Ownership Protocol Success \u00b6 The New Owner Client transfers device information to the manager server. The Device TEE indicates to its user-space handler to invoke the Device to Manager Agent for the manager service. This Device to Manager Agent should be given all the information that the TEE has now collected. The Device TEE transitions to the IDLE state. The new Owner has changed all credentials in the device, except the Device hardware root of trust (and some manufacturer-specific credentials) and has sufficient information to construct an Ownership Voucher with zero entries. The Rendezvous Service cannot verify an ownership voucher with zero entries. \u21a9 Note that bo.oh.pk is the initial owner public key from the Ownership Proxy Header, and should not be confused with bo.pk. \u21a9","title":"Detailed Protocol Description"},{"location":"protocol-specification/detailed-protocol-description/#detailed-protocol-description","text":"This section defines protocol messages and interactions. Protocol message names match the table, in section \u00a7 : Message Types*. The notation for each message is based on JavaScript* Object Notation (JSON). The message is presented as a message header and a JSON* object as body. The body uses comments to indicate the meaning of particular JSON* elements. Note that these comments and the whitespace are illegal to be transmitted within the JSON* encoding described in section \u00a7 , and are provided for explanation only. Composite types described in the tables in section \u00a7 are used freely. These are also expanded out in some cases, to allow comments on the internal members. In this case, the opening bracket should contain a comment to indicate the composite type.","title":"Detailed Protocol Description"},{"location":"protocol-specification/detailed-protocol-description/#general-messages","text":"","title":"General Messages"},{"location":"protocol-specification/detailed-protocol-description/#error-type-255","text":"Message Body: { #Error message body \"ec\": Uint16, # Error code \"emsg\": UInt8, # Message ID of the previous message \"em\": String # Error string } Message Meaning: The error message indicates that the previous protocol message could not be processed. The error message is described in detail in section \u200e \u00a7 .","title":"Error - Type 255"},{"location":"protocol-specification/detailed-protocol-description/#persisted-messages","text":"Persisted messages are messages that are stored on non-volatile media and retrieved later. They may also be transmitted outside of the Secure Device Onboard protocols, such as in e-mail messages, and act as an interchange format. Since all Secure Device Onboard messages are printable ASCII, persisted messages may be generated and parsed in exactly the same way as transmitted messages, with only their message type to distinguish them as persisted. Persisted messages always contain the JSON* 4-element sequence encapsulation, as described in section \u00a7 . The 4-element JSON* encapsulation always appears for these messages when they are stored. For example, if the PM.PublicKey type\u2019s body is the 16 characters: {\"pk\":[0,0,[0]]} (This is a null public key, not very useful.) Then the persisted message will actually be: [\"001d\",4,7,{\"pk\":[0,0,[0]]}] Where the \u201c001d\u201d in the 4-character length field indicates that the entire message is 29 bytes (=0x1d) long.","title":"Persisted Messages"},{"location":"protocol-specification/detailed-protocol-description/#pmcredowner-type-1","text":"Stored in Device TEE This is the Ownership Credential that is stored in the device TEE during the Device Initialize Protocol (DI), and updated in Transfer Ownership 2 Protocol (TO2). Message Body: { # OwnerBlock \"pv\": UInt16, \"pe\": UInt8, \"g\": Guid, \"r\": RendezvousInfo, \"pkh\": Hash } Message Meaning: The \u201cpv\u201d parameter specifies the protocol version as a UInt16, in the same format as the message header. The protocol version must be persisted whether the message header information is available or not (For example, in the Device TEE). The \u201cpe\u201d parameter specifies the key encoding used in this credential, and in ownership proxies based on this credential. The GUID parameter \u201cg\u201d is the current device GUID, to be used for the next ownership transfer. The RendezvousInfo parameter \u201cr\u201d contains instructions on how to find the Secure Device Onboard Rendezvous Server. The Public Key Hash \u201cpkh\u201d is a hash of the Owner\u2019s public key, which must match the first entry of the Ownership Voucher used to transfer ownership for this device. The recommended default hash to use is SHA-256 (Secure Device Onboard 1.0 & Secure Device Onboard 1.1 protocol spec; SHA-384 for future crypto).","title":"PM.CredOwner, Type 1"},{"location":"protocol-specification/detailed-protocol-description/#pmcredmfg-type-2","text":"Stored in Device TEE: This is the Manufacturing Credential that is stored in the device TEE during the Device Initialize Protocol (DI). It is never changed afterwards. Message Body: { # ManufacturerBlock \"d\": String } Message Meaning: The DeviceInfo parameter \u201cd\u201d is the manufacturer\u2019s DeviceInfo field. This may be used to identify the device model.","title":"PM.CredMfg, Type 2"},{"location":"protocol-specification/detailed-protocol-description/#pmownershipproxy-type-3","text":"The [Ownership Voucher] (previously called as Ownership Proxy) is used to convey the trust of the device in the factory to the new owner. The OwnershipProxy structure is shown in Table \u200e1: Table 1 - OwnershipProxy Structure OwnershipProxy { \"sz\": UInt8, # number of entries \"oh\": { \"pv\": UInt16, # protocol version \"pe\": UInt8, # public key encoding \"r\": Rendezvous, # rendezvous \"g\": GUID, # guid \"d\": String, # DeviceInfo \"pk\": PublicKey, # mfg public key \"hdc\": Hash # hmac[secret, \u201coh\u201d] # Hash of device certificate chain, absent if using Intel<sup>\u00ae</sup> EPID }, \"hmac\": HMac, \u201cdc\u201d: CertChain, # Device certificate chain, absent if EPID \"en\": [# entries. OwnershipProxyEntry[0], \u2026 OwnershipProxyEntry\\[SZ-1] ]#(Actually, zero entries are permitted, and looks like \"en\":[],) } Note: When \"sz\" is zero, \"en\" is []. CertChain [ type(Uint8), # format of certificate entries (1==x509) numEntries(Uint8), # number of certificate entries [ # Array of certs from Device to CA, each signed by next Cert[0], \u2026 Cert[numEntries-1] ] ] Cert [ length(Uint16), # number of bytes in certificate certBytes(ByteArray) # certificate data in DER encoded to ByteArray format ] OwnershipProxyEntry { bo:{ \"hp\": Hash, # hash of previous entry (only the \u201cbo\u201d) \"hc\": Hash, # hash[GUID||DeviceInfo] in header* \"pk\": PublicKey # public key being signed }, \"pk\": PKNull, # place holder (null pub key) \"sg\": Signature # signature } Note: GUID||DeviceInfo indicates the bitwise concatenation of the \"g\" and \"d\" fields from the ownership proxy header. Message Meaning: The \u201coh\u201d field contains header information, a copy of which is stored in the Device (the Device stores only a hash of the public key \u201coh.pk\u201d). The \u201coh\u201d field\u2019s contents are hashed into \u201chmac\u201d by the device TEE and combined with a secret, which is only stored in the device TEE. \u201coh.pv\u201d is the protocol version (major version * 100 + minor version). \u201coh.pe\u201d is the protocol encoding used in all Ownership Voucher public keys. \u201cr\u201d is the rendezvous info for connecting to the Rendezvous Server. \u201cg\u201d is the current GUID of the device. For ECDSA device attestation, the device certificate chain is present in the Ownership Voucher as OwnershipProxy.dc (device certificate). This is of type CertChain. When the device uses an Intel \u00ae EPID root of trust, OwnershipProxy.dc is not present. \u201cpk\u201d is the public key of the device\u2019 initial owner (For example, the manufacturer). The \u201cen\u201d tag contains the Ownership Voucher entries, in order. If there are no entries (\u201csz\u201d is zero) the \u201cen\u201d tag is an empty array ([]).","title":"PM.OwnershipProxy, Type 3"},{"location":"protocol-specification/detailed-protocol-description/#pmpublickey-type-4","text":"This message format is used by each successive owner in the supply chain to identify his public key to the previous owner. The previous owner signs the public key (and other information) to extend the ownership voucher. See section \u00a7 : The Ownership Voucher. Message Body: { \"pk\": PublicKey } Message Meaning: For a description of the various public key formats, see section \u00a7 : Public Key Types. For a description of how the public key of the new Owner is used to extend the Ownership Voucher, see section \u00a7 : Build The Ownership Voucher.","title":"PM.PublicKey, Type 4"},{"location":"protocol-specification/detailed-protocol-description/#pmserviceinfo-type-5","text":"Stored in Device Filesystem: This message format is used to save the key-value pairs that are sent as part of the TO2.ReceiveDeviceInfo and TO2.SendSetupInfo messages. Message Body: { \"k1\": \"v1\", # note: k1 must be ASCII \"k2\": \"v2\", # note: k2 must be ASCII \u2026 \"kN\": \"vN\" #note: kN must be ASCII } Note - k1, k2, \u2026 kN must all be unescaped ASCII. For example: \"abc\" is legal, but \"a\\u0062c\" is illegal. This does mean that keys cannot have special characters in them. However, values can have escaped characters, as needed, to support the full Unicode set. Message Meaning: ServiceInfo is a set of key-value pairs that is used in a negotiation between the Device and the Owner during the TO2 Protocol. A set of key-value pairs, the Device ServiceInfo is first transmitted from the Device to the Owner. Then a set of key-value pairs, the Owner ServiceInfo, is sent from the Owner to the Device. Definitions of ServiceInfo key-value pairs is given in section \u00a7 .","title":"PM.ServiceInfo, Type 5"},{"location":"protocol-specification/detailed-protocol-description/#pmdevicecredentials-type-6","text":"Stored in Device Filesystem: This message format is suggested to store the device state for implementations that use a filesystem instead of a TEE. It may also be signed or encrypted (sealed) in these implementations, to improve security. A given implementation may also use another, more convenient, format. Message Body: { \"ST\": UInt8, # State \"Secret\": ByteArray, \"M\": {#ManufacturerBlock \"d\": String }, \"O\": {#OwnerBlock \"pv\": UInt16, \"pe\": UInt8, \"g\": Guid, \"r\": RendezvousInfo, \"pkh\": Hash } } Message Meaning: \u201cST\u201d is the Secure Device Onboard state, as defined in the Secure Device Onboard architectural specification. \u201cM\u201d is the manufacturer state. \u201cO\u201d is the owner state.","title":"PM.DeviceCredentials, Type 6"},{"location":"protocol-specification/detailed-protocol-description/#device-initialize-protocol-di","text":"The Device Initialize Protocol (DI) serves to set the manufacturer and owner of the device in the TEE. It is assumed to be performed at device manufacture time. This protocol uses a Trust On First Use (TOFU) trust model, consistent with the Secure Device Onboard assumption that the manufacturing environment is trusted. It would be possible to implement a more restricted trust model for the DI Protocol by embedding a public key into the TEE, with the TEE owner providing signing (or at least CA) services to the manufacturer. The DI Protocol runs between a manufacturing support station, which contains the Secure Device Onboard Manufacturing Component, and the Device TEE. The Device is assumed to be running with some other kind of support software, which is able to access the TEE and provide communications services for it. For example, the device may be PXE-booted into a RAM-based Linux* system, with features to access the TEE. It is assumed that this software is able to determine from its environment the IP address for the manufacturing support station. DI Protocol Diagram","title":"Device Initialize Protocol (DI)"},{"location":"protocol-specification/detailed-protocol-description/#diappstart-type-10","text":"From Device TEE to Manufacturer: The App Start message starts talking to the TEE application to start. Downloading, verifying, and starting the TEE application is outside the scope of this document. Message Format: { \"m\": String } Message Meaning: Start the process of taking initial ownership of the device. If available, the device may include a serial number or other identifying mark from the hardware in this message, using the \u201cm\u201d tag. This is intended to help the manufacturing station to index Secure Device Onboard information with other information available to the manufacturer. If no such information is available, the \u201cm\u201d tag is sent with an empty string. The manufacturing station must always be able to handle a device that sends an empty string for tag \u201cm.\u201d","title":"DI.AppStart, Type 10"},{"location":"protocol-specification/detailed-protocol-description/#disetcredentials-type-11","text":"From Manufacturer to Device TEE: Message Format: { \"oh\":{# See Ownership Voucher \u201coh\u201d tag. \"pv\": UInt16, \"pe\": UInt8, \"r\": Rendezvous, \"g\": GUID, \"d\": String, \"pk\": PublicKey, \"hdc\": Hash # Absent if using Intel EPID } } Message Meaning: The manufacturing station sends credentials to the Device TEE. The credentials in \"oh\" are identical to the \u201coh\u201d field of the Ownership Voucher (see section \u00a7 ). Some additional credentials allow the original manufacturer of the device to be determined across future ownership transfers. When the device uses ECDSA method for device attestation, the manufacturing station will compute the Hash of the device certificate chain (provided by the manufacturer to the manufacturing tool) and include the Hash as \u201coh.hdc\u201d in the message. When the device uses Intel \u00ae EPID root of trust, this field must not be present. The manufacturing station typically will use the \u201cm\u201d tag (see section \u00a7 ) to determine information for \u201coh.r,\u201d \u201coh.d\u201d and \u201coh.pk.\u201d The \u201coh.g\u201d field (GUID) shall be a secure-randomly created unique identifier and not derived in any way from device-specific information to ensure the privacy of the protocol. The Device TEE allocates a secret, stores this information in the Device TEE as PM.DeviceCredentials, along with the secret. The public key oh.pk is stored as a hash of the public key oh.pk. The Device does not have to use the persisted message format for PM.DeviceCredentials, as long as the information can be accurately retrieved on demand. The Device TEE also computes an HMAC based on the above secret and the entire contents of this message body (including the brace brackets). This HMAC is used in the next message.","title":"DI.SetCredentials, Type 11"},{"location":"protocol-specification/detailed-protocol-description/#disethmac-type-12","text":"From Device TEE to Manufacturer: Message Format: { \"hmac\": Hash } Message Meaning: The device TEE returns the HMAC of the internal secret and the DI.SetCredentials.oh tag, as mentioned above. The manufacturer combines this HMAC with its own transmitted information to create an Ownership Voucher with zero entries.","title":"DI.SetHMAC, Type 12"},{"location":"protocol-specification/detailed-protocol-description/#didone-type-13","text":"From Manufacturer to Device TEE: Message Body: -no-body- Message Meaning: Indicates successful completion of the DI protocol. This message must not be sent before the Credentials associated with the device (see section \u00a7 ) is recoverably persisted in the manufacturing backend to prevent the release of an unusable device due to loss of its Ownership Voucher. Upon receive of this message, the device persists all information associated with the Device Initialization protocol.","title":"DI.Done, Type 13"},{"location":"protocol-specification/detailed-protocol-description/#transfer-ownership-protocol-0-to0","text":"The function of Transfer Ownership Protocol 0 (TO0) is to register the new owner\u2019s current Internet location with the Rendezvous server under the GUID of the device being registered. The Rendezvous server negotiates a length of time during which it will remember the new owner\u2019s current IP address. If the new owner does not receive a device transfer of ownership within this time, it must re-connect to the Rendezvous server to repeat Transfer Ownership Protocol 0. The protocol begins when the Owner Client opens a connection to the Rendezvous Server as is given in the Ownership Voucher. The preferred protocol to use is TLS with server authentication only. The necessary client authentication is provided by the ownership voucher. TO0 Protocol Diagram","title":"Transfer Ownership Protocol 0 (TO0)"},{"location":"protocol-specification/detailed-protocol-description/#to0hello-type-20","text":"From New Owner Client to Rendezvous Server Message Format: -No body- Message Meaning: Initiates the TO0 Protocol, requests a Hello Ack nonce.","title":"TO0.Hello, Type 20"},{"location":"protocol-specification/detailed-protocol-description/#to0helloack-type-21","text":"From Rendezvous Server to New Owner Client Message Format: { \"n3\": Nonce # nonce #3 } Message Meaning: Requests proof of the ownership voucher.","title":"TO0.HelloAck, Type 21"},{"location":"protocol-specification/detailed-protocol-description/#to0ownersign-type-22","text":"From New Owner Client to Rendezvous Server Message Format: { \"to0d\": { # covered in signature \u201cop\u201d: OwnershipProxy, # Ownership Voucher (complete) \"ws\": UInt32, # how many seconds to wait. \"n3\": Nonce # Freshness of signature }, \"to1d\": { \"bo\": { #sign with \u201cOwner key\u201d \"i1\": IPAddress, # IP address where we are waiting \"dns1\": String, # DNS address where we are waiting (alternative) \"port1\": UInt16, # TCP/UDP port number \"to0dh\": Hash # Hash(to0d object, brace to brace) }, \"pk\": PKNull, \"sg\": Signature # signed with \u201cOwner key\u201d == last public key in \u201cop\u201d. } } Message Meaning: The new owner demonstrates its credentials for a given GUID by providing the Ownership Voucher and signing with the Owner Key. In addition, the owner provides the Internet location where it is waiting for a Device to connect (fields: \u201ci1\u201d, \u201cdns1\u201d, \u201cport1\u201d) and upper bound of how long it is willing to wait (field: \u201cws\u201d). The wait time is negotiated with the server, see TO0.AcceptOwner.ws. After the negotiated wait time passes, the owner must re-run the TO0 Protocol to refresh its mapping. The Ownership Voucher is given in \u201cto0d.op\u201d as a single object. The Ownership Voucher must have at least one entry, such as, to0d.op.bo.sz > 0, or the Rendezvous Service must drop the connection. 1 The Rendezvous Service may also restrict the maximum number of entries it is willing to accept, to prevent DoS attacks. The current recommended maximum is ten entries (to0d.op.bo.sz > 0 && to0d.op.bo.sz \u2264 10). The encoding of this message is divided into two JSON* objects: \u201cto0d\u201d and \u201cto1d\u201d, which are linked by the hash \u201cto0dh\u201d inside of \u201cto1d\u201d. The object \u201cto0d\u201d contains fields that are only used in the TO0 Protocol, and the object \u201cto1d\u201d contains fields that are also used in the TO1 Protocol. The fields in to0d are: to0d.op: The entire Ownership Voucher. The GUID is given in to0d.op.oh.g. The Owner Key is given in to0d.op.en[to0d.op.sz-1].bo.pk (that is, the \u201cbo.pk\u201d in the last OwnershipProxyEntry). The Owner key is used to verify to1d.sg. to0d.ws: The wait time offered by the Owner, which is adjusted and confirmed in TO0.AcceptOwner.ws. to0d.n3: A copy of TO0.HelloAck.n3, used to ensure the freshness of the signature in TO0.to1d.sg. The to1d object is a signed \u201cblob\u201d that indicates an Internet address where the Device can find Owner for the TO2 Protocol. The entire object is stored by the Rendezvous Service and returned verbatim to the Device in the TO1 Protocol. See how this value is verified by the Device in section \u00a7 . The fields in to1d are: to1d.bo.i1: An internet address where the Owner is listening for a TO2 connection. It may be 0.0.0.0 if only \u201cdns1\u201d matters. Since the to1d value has a time limit associated with it (\u201cws\u201d), the server may use the Internet address to create a temporary address that is harder to map to its identity. If both DNS and IP address are specified, the IP address is used only when the DNS address fails to resolve. to1d.bo.dns1: A DNS name where the Owner is listening for a TO2 connection. Any IP address resolved by the DNS name must be equivalently able to process the TO2 connection. A null string (\u201c\u201d) may be used if only the \u201ci1\u201d value matters. to1d.bo.port1: A TCP port where the Owner is listening for a TO2 connection. A value of zero (0) indicates that the default port (80 for HTTP or 443 for HTTPS) is used. to1d.bo.to0dh: A SHA256 or SHA384 hash of the TO0.OwnerSign.to0d object (from brace to brace, inclusive). The Rendezvous Server must verify that to0dh matches the hash of the to0d object (from brace to brace). Otherwise, the Rendezvous Server shall end the connection in error. to1.pk: Always PKNull. to1.sg: Signature of to1d.bo with the Owner key from to0d.op. It is preferred that the Rendezvous Service has a basis on which to trust at least one public key within the Ownership Voucher. For example, the manufacturer who ran the DI protocol to configure the Device, thereby choosing the Rendezvous Service, may register key hashes with the Rendezvous Service to establish such a trust. The Owner may register its own keys additionally, or as an alternative. An intermediate signer of the Ownership Voucher might act as a national point of entry, using its keys to establish trust for devices in the Rendezvous Service as they arrive in country. A given Rendezvous Service may choose to reject Ownership Proxies that are not trusted. If the Rendezvous Service has no basis on which to trust the Ownership Voucher, it must apply its own internal policies to protect itself against a DoS attack, but may otherwise safely provide the Rendezvous Service (that is, it can allow the TO0 and TO1 Protocols to succeed). This behavior is acceptable because the TO2 Protocol is able to verify the to1d \u201cblob\u201d defined in this message. However, such a Rendezvous Service must ensure that untrusted Ownership Proxies cannot degrade the service for trusted Ownership Proxies. This may be accomplished through hard limiting of resources, or even allocating a trusted- and non-trusted version of the service. The Rendezvous Server needs to verify that the signature on this message is verified by the public key on the last message of the ownership voucher, such as by saving the public key transmitted and verifying it is the same public key. In case of ECDSA device attestation method, Rendezvous Service must verify the binding of the certificate to the Ownership Voucher (verify the certificate chain hash). It is the only non-owner entity which can do this. It is recommended that the Service should also do revocation check for the certificate chain.","title":"TO0.OwnerSign, Type 22"},{"location":"protocol-specification/detailed-protocol-description/#to0acceptowner-type-25","text":"From Rendezvous Server to New Owner Client Message Format: { \"ws\": Uint32 # waitSeconds; } Message Meaning: Indicates acceptance of the new Owner. The Rendezvous Server will associate GUID with the new owner\u2019s address information for the waitSeconds seconds. WaitSeconds may not exceed NewOwnerHello.waitSeconds, but it may be less. If the GUID indicated in: TO0.OwnerSign.to0d.bo.op.oh.g is already associated with another IP address, the Rendezvous Server retargets this association as specified in this protocol. The New Owner Client can drop the connection after this message is processed. If the new Owner does not receive a Transfer Ownership connection from a Device within waitSeconds seconds, it must repeat Transfer Ownership Protocol 0 and re-register its GUID to address association. When the new Owner is actively changing its address from time to time (For example, to mask its identity), the frequency of changing address dictates the magnitude of WaitSeconds. Otherwise, the negotiation depends on the frequency at which the new owner wishes to refresh the server, traded off with the server\u2019s need to remember many GUID associations. Note The Rendezvous Server has no sure way to know when a device ownership is successful or fails, since it is not party to the TO2 Protocol. This is intended to make it harder for an intruder who is monitoring the Rendezvous Server to trace a device, even by the Secure Device Onboard GUID (which is replaced in the TO2 Protocol). Thus the Rendezvous Server may arrange to keep the timeouts short enough that it does not have to keep every Secure Device Onboard transaction ever created in its database. We imagine a timeout of a day or two, or perhaps a week or two. Note The type for this message is 25, which is not contiguous with other message types. Earlier versions of this section incorrectly gave the type as 23.","title":"TO0.AcceptOwner, Type 25"},{"location":"protocol-specification/detailed-protocol-description/#transfer-ownership-protocol-1","text":"Transfer Ownership Protocol 1 (TO1) finishes the rendezvous started between the New Owner and the Rendezvous Server in the Transfer Ownership Protocol 0 (TO0). In this protocol, the Device TEE communicates with the Rendezvous Server and obtains the IP addressing info for the (potential) new Owner. Then the Device may establish trust with the new Owner by connecting to it, using the TO2 Protocol. Note The Transfer Ownership Protocols 0 and 1 serve only to get the Device the IP addressing information for a potential Owner candidate\u2014no trust is conveyed in these protocols. When possible, the TO1 Protocol should arrive at the Rendezvous service under HTTPS to protect the privacy of the Owner. It is possible that intermediate stages of the protocol are run under HTTP, such as from a sensor to a gateway or from a management engine to an OS user process. If it is NOT possible to use HTTPS to protect the TO1 Protocol, the Owner may also take measures to protect its privacy: The Owner may use a private IP address (For example, IPv6 privacy address) and refresh the address periodically, to make it more difficult for an attacker to glean information from the rendezvous address. The Owner may use a multi-tenant model, where the actual Owner of the Device does not relate to the IP address or DNS name of the Owner. Transfer Ownership Protocol 1 (TO1)","title":"Transfer Ownership Protocol 1"},{"location":"protocol-specification/detailed-protocol-description/#to1hellosdo-type-30","text":"From Device TEE to Rendezvous Server: Message Format: { \"g2\": GUID, # device GUID. \"eA\": SigInfo } Message Meaning: Establishes the presence of the device at the Rendezvous Server. The Device GUID is included to help a REST server create a token. It is not otherwise needed. The \u201cg2\u201d variable is the GUID of the Device. This may be used as an index by the Rendezvous Service to look up information associated with the Device. The \u201ceA\u201d variable contains signature related information, as described in section \u00a7 .","title":"TO1.HelloSDO, Type 30"},{"location":"protocol-specification/detailed-protocol-description/#to1hellosdoack-type-31","text":"From Rendezvous Server to Device TEE Message Format: { \"n4\": Nonce, \"eB\": SigInfo } Message Meaning: Sets up Device TEE for next message. The \u201cn4\u201d tag contains a nonce to use as a guarantee of signature freshness in the TO1.ProveTOSDO. The \u201ceB\u201d variable contains signature related information, as described in in section \u00a7 .","title":"TO1.HelloSDOAck, Type 31"},{"location":"protocol-specification/detailed-protocol-description/#to1provetosdo-type-32","text":"From Device TEE to Rendezvous Server: Message Format: { \"bo\": { \"ai\": AppId, \"n4\": Nonce, \"g2\": GUID, }, \"pk\": PublicKey, # Intel<sup>\u00ae</sup> EPID key for Intel<sup>\u00ae</sup> EPID device attestation; PKNull if ECDSA \"sg\": Signature } Message Meaning: Proves validity of device identity to the Rendezvous Server for the Device seeking its owner, and indicates its GUID, \u201cg2\u201d. AppID provides evidence of the TEE application that is running, which indicates that the behavior may be trusted. It is verified using information from the TEE author (For example, Intel). Nonce4 proves that the signature was just computed, and not a reply (signature \u2018freshness\u2019 test). The field \u201cpk\u201d shall contain the Intel \u00ae EPID public key in case Intel \u00ae EPID device attestation. It shall be PKNull in case of ECDSA device attestation. If the device signature cannot be verified, or fails to verify, the connection is terminated with an error message (see section \u00a7 ). When the device attestation method is Intel \u00ae EPID, the signature is checked with Intel \u00ae EPID group keys (For example, from Intel). In the case of ECDSA, the leaf certificate in the device certificate chain contained in the Ownership Voucher is used to verify the signature.","title":"TO1.ProveToSDO, Type 32"},{"location":"protocol-specification/detailed-protocol-description/#to1sdoredirect-type-33","text":"From Rendezvous Server to Device TEE: Message Format: The exact value of: TO0.OwnerSign.to1d, being: { \"bo\": { \"i1\": IPAddress, # IP address where we are waiting \"dns1\": String, # DNS address where we are waiting (alternative) \"port1\": UInt16, # TCP/UDP port number \"to0dh\": Hash # Hash(to0d object, brace to brace) }, \"pk\": PKNull, \"sg\": Signature # signed with \u201cOwner key\u201d that Device will get in TO2 } Message Meaning: Indicates to the Device TEE that a new Owner is indeed waiting for it, and may be found by connecting to the given DNS name or IP address. If only an IP address is needed, the DNS String can be empty (zero length). If a DNS name is present, the DNS lookup is performed first, and all resolved IP addresses are tried before the given IP address is tried. If the given IP address was one of the IP addresses returned by DNS, it does not have to be tried separately (once is enough). Note This message is bit-for-bit identical to TO1.OwnerSign.to1d.","title":"TO1.SDORedirect, Type 33"},{"location":"protocol-specification/detailed-protocol-description/#transfer-ownership-protocol-2","text":"The Device communicates with the Owner Client based on the values in the [TO1.SDORedirect] message. The TO2 Protocol is the most complicated of the protocols in Secure Device Onboard, because it has several steps that are not present in other protocols: Establishes trust in both directions: The Device uses its device attestation key and the Owner uses the Ownership Voucher. Creates an encrypted channel, based on the above trust, using a supported key exchange mechanism. Exchanges device service info for owner service info. The Owner replaces all Secure Device Onboard credentials in the Device (this does not include the Device\u2019s hardware root of trust); the Device gives the Owner an HMAC that allows it to generate a replacement Ownership Voucher. The Owner can use this new Ownership Voucher in future Secure Device Onboard transactions (For example, to resell the Device). In addition, in all these operations, all unbounded data items are divided across multiple messages, to limit the size of an HTTP transaction that the Device is required to process (ideally, each message fits into a single packet; this is not guaranteed at present). This causes several loops in the protocol: The Ownership Voucher is transmitted header first, then entry by entry in successive messages. The service info (in each direction) is transmitted in as many messages as necessary to keep the message size to a single packet. A constrained device may assume that the connection MTU size is 1500 bytes. The Owner should try to keep the size of each service info message down to less than 1300 bytes, to allow constrained device protocols to operate correctly. The ServiceInfo exchange in Secure Device Onboard allows the cooperating client entities on the Device and Owner to negotiate their own \u201cprotocol\u201d for setting up the Device. The names and meanings of key value pairs is generally up to the Device and Owner, but specific (useful) values are given in section \u00a7 . Transfer Ownership Protocol 2 (TO2)","title":"Transfer Ownership Protocol 2"},{"location":"protocol-specification/detailed-protocol-description/#limitation-of-round-trip-times","text":"The implementation shall complete the Transfer Ownership Protocol 2 in no more than 1,000,000 round trip times, overall. Owner and Device implementations should not request more iterations than this.","title":"Limitation of Round Trip Times"},{"location":"protocol-specification/detailed-protocol-description/#to2hellodevice-type-40","text":"From Device TEE to New Owner Client Message Format: { \"g2\": GUID, \"n5\": Nonce, \"pe\": Uint8, # Public key encoding \"kx\": String, # key exchange suite name \"cs\": String, # Ciphersuite name \"eA\": SigInfo # Device attestation signature info } Message Meaning: Sets up new owner for proof of ownership. The \u201cpe\u201d field indicates the preferred public key encoding. The \u201ckx\u201d and \u201ccs\u201d fields indicate the key exchange protocol and cipher suite to use. Because we assume the Device may be constrained, it gets to choose these values; the Owner side must support all choices that a Device can make. The value for \u201ckx\u201d is given in section \u00a7 , either: Secure Device Onboard 1.0 & Secure Device Onboard 1.1 protocol spec: DHKEXid14, ASYMKEX, or ECDH Future crypto: DHKEXid15, ASYMKEX3072, or ECDH384 The cipher suite \u201cbo.cs\u201d is as given here in Table 2. Cipher Suite Names and* Meanings. Other key exchange protocols or cipher suites may be supported in the future. The \u201ceA\u201d tag starts the Device\u2019 signature process.","title":"TO2.HelloDevice, Type 40"},{"location":"protocol-specification/detailed-protocol-description/#to2proveophdr-type-41","text":"From New Owner Client to Device TEE: Message Format: { # Signature of OP Owner Key bo: { \"sz\": UInt8, # Ownership Voucher \u201csz\u201d tag \"oh\": {#Ownership Voucher Hdr \"pv\": UInt16, \"pe\": UInt8, \"r\": Rendezvous, \"g\": GUID, \"d\": String, \"pk\": PublicKey, \"hdc\": Hash # Absent if using Intel EPID }, \"hmac\":Hash, # Ownership Voucher \u201chmac\u201d tag \"n5\": Nonce, # n5 from TO2.HelloDevice \"n6\": Nonce, # used below in TO2.ProveDevice and TO2.Done \"eB\": SigInfo, # Device attestation signature info \"xA\": KeyExchange # Key exchange first step }, \"pk\": PublicKey, # owner public key, may not be PKNull \"sg\": Signature } Message Meaning: This message serves several purposes: The Owner begins sending the Ownership Voucher to the device (only the header is in this message). The Owner signs the message with the Owner key (the last key in the Ownership Voucher), allowing the Device to verify (later on) that the Owner controls this private key. The Owner starts the key exchange protocol by sending the initial key exchange parameter xA (For example, in Diffie Hellman, the parameter \u2018A\u2019) to the Device. The Ownership Voucher\u2019s header is sent in the \u201coh\u201d and \u201chmac\u201d tags. The \u201csz\u201d tag gives the number of Ownership Voucher Entries. The entries will be sent in subsequent messages. It is legal for the \u201csz\u201d tag to have a value of zero (0), but this is only useful in re-manufacturing situations since the Rendezvous Service cannot verify (or accept) these Ownership Proxies. The \u201chmac\u201d tag is a HMAC-SHA256 (Secure Device Onboard 1.0 and Secure Device Onboard 1.1 protocol spec) or HMAC-SHA384 (future crypto) over the \u201coh\u201d tag. The HMAC key is the one that was created in the Device during the DI Protocol (or stored in the Device, if an alternate mechanism is used to initialize the Device). The Device re-computes the HMAC value against the received contents of the \u201coh\u201d tag using this stored secret, and verifies that the \u201chmac\u201d tag has the same value. This ensures that the Device itself has not been reinitialized since it was originally programmed during manufacturing. For ECDSA device attestation method, the New Owner Client includes the hash of device certificate chain from Ownership Voucher (OP.oh.hdc) in the TO2.ProveOPHdr message (as TO2.ProveOPHdr.bo.oh.hdc) for the device to verify the HMAC. The device temporarily saves the oh.hdc on receiving the message. When the device computes the new HMAC based on the fields received inTO2.SetupDevice message, it uses the value of TO2.ProveOPHdr.bo.oh.hdc that was previously saved. The new HMAC is returned to the New Owner Client as part of TO2.Done message The public key \u201cpk\u201d is the Owner Key. This key, which verifies the message signature (\u201csg\u201d), must be compared with the public key in the last Ownership Voucher Entry when it is received (later in the sequence of this protocol). 2 This key must also be able to verify the signature of the TO1.SDORedirect message. The Device must store the TO1.SDORedirect message (or its hash) until the TO2.ProveOPHdr message is received. At this time, the Device can verify the TO1.SDORedirect signature with the give Owner key in TO2.ProveOPHdr.pk. If the TO1.SDORedirect signature does not verify, the Device must assume that a man in the middle is monitoring its traffic, and fail immediately with an error code message. The bo.eB field continues the Device\u2019 signing process. The bo.xA field begins the key exchange protocol. See section \u00a7 for more details on key exchange. The key exchange is finished in the TO2.ProveDevice message (section \u00a7 ). The verification of this message is critical, but may be a little hard to understand. The Device initially verifies this message\u2019s signature \u201csg\u201d using the supplied key \u201cpk\u201d, then saves a copy of this key (for memory reasons, the Device may save a SHA hash of the key). As the Ownership Voucher entries are transmitted in successive TO2.GetOPNextEntry messages, the Device can verify them using the signature chain embedded in the Ownership Voucher, from header to entry 1 to entry 2, and so on. The last such entry signs bo.pk, which is called the \u201cowner key\u201d. Now the Device must verify that the Owner can sign with this bo.pk public key\u2019s corresponding private key. But if this bo.pk matches the TO2.ProveOPHdr.pk, then the signature verification at the start has verified exactly this. The following diagram illustrates the process, using only the signature chain, for an Ownership Voucher 3 entries: Verification of Ownership Voucher by Device","title":"TO2.ProveOPHdr, Type 41"},{"location":"protocol-specification/detailed-protocol-description/#to2getopnextentry-type-42","text":"From Device TEE to New Owner Client: Message Format: { \"enn\": UInt8 } Message Meaning: Acknowledges the previous message and requests the next Ownership Voucher Entry.","title":"TO2.GetOPNextEntry, Type 42"},{"location":"protocol-specification/detailed-protocol-description/#to2opnextentry-type-43","text":"From New Owner Client to Device TEE Message Format: { \"enn\":UInt8, \"eni\":{ \"bo\":{ \"hp\": Hash, \"hc\": Hash, \"pk\": PublicKey }, \"pk\": PKNull, \"sg\": Signature } } Message Meaning: Transmits the requested Ownership Voucher entry from the New Owner to the Device TEE. The value of tag \u201cenn\u201d matches the value of TO2.GetOPNextEntry.enn. If enn == TO2.ProveOPHdr.bo.sz-1, then the next state is TO2.ProveDevice. Otherwise the next state is TO2.GetOPNextEntry. The Device TEE verifies the ownership voucher entries incrementally as follows: Variables: hp \u2013 hash of previous entry. The hash only covers the \u201cbo\u201d in the previous entry with the \u201cbo:\u201d tag but includes the enclosing braces . For the first entry, the hash is SHA [TO2.ProveOPHdr.bo.oh||TO2.ProveOpHdr.bo.hmac]. pk \u2013 public key signed in previous entry (initialize with TO2.ProveOPHdr.bo.oh.pk) hc \u2013 hash of GUID and DeviceInfo, compute from TO.OwnerSign.bo as: SHA[TO2.ProveOPHdr.bo.oh.g||TO2.ProveOPHdr.bo.oh.d] Use SHA256 (Secure Device Onboard 1.0 and Secure Device Onboard 1.1 protocol spec) or SHA384 (future crypto). Pad the hash text on the right with zeros to match the hash length. For each entry: Verify signature TO2.OPNextEntry.eni.sg using variable pk Verify variable hc matches TO2.OPNextEntry.eni.bo.hc Verify hp matches TO2.OpNextEntry.eni.bo.hp Update variable pk TO2.OPNextEntry.eni.bo.pk Update variable hp SHA [TO2.OpNextEntry.eni.bo] (SHA256 for Secure Device Onboard1.0 and Secure Device Onboard 1.1 protocol spec and SHA384 for future crypto) If enn == TO2.ProveOpHdr.bo.sz-1 then verify TO2.ProveOPHdr.pk == TO2.OpNextEntry.eni.bo.pk","title":"TO2.OPNextEntry, Type 43"},{"location":"protocol-specification/detailed-protocol-description/#to2provedevice-type-44","text":"From Device TEE to New Owner Client Message Format: { # Signature \"bo\": { \"ai\": AppId, # proves App provenance within TEE \"n6: Nonce, # proves signature freshness \"n7: Nonce, # used in TO2.SetupDevice \"g2\": GUID, # proves the GUID matches with g2 in TO2.HelloDevice and TO2.Done2 \"nn\": UInt8, # number of device service info messages to come \"xB\": DHKeyExchange # Key Exchange, 2nd Step }, \"pk\": PublicKey, # Intel<sup>\u00ae</sup> EPID key for Intel<sup>\u00ae</sup> EPID device attestation; PKNull if ECDSA \"sg\": Signature } Message Meaning: Proves the provenance of the device to the new owner, using the device attestation signature (\u201csg\u201d) based on the challenge (nonce) \u201cn6\u201d. If the signature cannot be verified, or fails to verify, the connection is terminated with an error message (section \u00a7 ). Completes the key exchange, by sending \u201cxB\u201d. Sends \u201cn7\u201d for later use. Sends \u201cnn\u201d to indicate number of TO2.GetNextDeviceServiceInfo messages. The field \u201cpk\u201d shall contain the Intel \u00ae EPID public key in case of Intel \u00ae EPID device attestation. It shall be PKNull in case of ECDSA device attestation. Note Subsequent message bodies are HMac\u2019d and Encrypted. See section \u200e \u00a7 for more details on key exchange.","title":"TO2.ProveDevice, Type 44"},{"location":"protocol-specification/detailed-protocol-description/#to2getnextdeviceserviceinfo-type-45","text":"From New Owner Client to Device TEE Message Format - after decryption and verification of HMAC: { \"nn\": UInt8, #Index of device service info message expected \"psi\": String # extra for this version of protocol only } Message Meaning: Acknowledges the TO2.ProveDevice message. Requests the next Device Service Info message. \u201cnn\u201d is the index of the next device service info expected, starting at zero. \u201cpsi\u201d is an optional string that may be used to inform the Device before it generates the Device Service Info. The value of \u201cpsi\u201d is only significant when \u201cnn\u201d == 0, and otherwise \u201cpsi\u201d must be the empty string. The value of \u201cpsi\u201d may be used when the Device Service Info is dependent on information from the Owner. For example, if the Owner needs the Device to allocate 4 key pairs, the \u201cpsi\u201d variable may be used to transmit the number \u201c4\u201d as a string.[^23] [^23]: This facility is intended to work around a problem that will be solved by multiple \u201crounds\u201d of Service Info in a future release of Secure Device Onboard.","title":"TO2.GetNextDeviceServiceInfo, Type 45"},{"location":"protocol-specification/detailed-protocol-description/#to2nextdeviceserviceinfo-type-46","text":"From Device TEE to New Owner Client Message Format - after decryption and verification of HMAC: { \"nn\": UInt8, # index of this message, from zero upwards. \"dsi\": ServiceInfo # service info entries to add or append to previous ones. } Message Meaning: Sends as many Device to Owner ServiceInfo entries as will conveniently fit into a message, based on protocol and Device constraints. When entries are received with the same name, the second and subsequent entries are concatenated onto the end of the previous entry. For example, a 3000 byte entry \u201ccert\u201d might be sent in 3 successive TO2.DeviceServiceInfo messages, one containing a \u201ccert\u201d entry with the first 1000 bytes, the second containing a \u201ccert\u201d entry with the second 1000 bytes, and the third containing a \u201ccert\u201d entry with the last 1000 bytes. This facility is intended to allow ServiceInfo entries to be large, but still fit into constrained message sizes. If \u201cnn\u201d == TO2.ProveDevice.bo.nn-1 then the next message is TO2.SetupDevice. Otherwise, the next message is TO2.GetNextDeviceServiceInfo. Note ServiceInfo messages might need to be converted to use \\uFFFF syntax to avoid internal characters.","title":"TO2.NextDeviceServiceInfo, Type 46"},{"location":"protocol-specification/detailed-protocol-description/#to2setupdevice-type-47","text":"From New Owner Client to Device TEE Message Format - after decryption and verification of HMAC: { \"osinn\":UInt8, # number of service info messages to come \"noh\":{ # update to ownership voucher header for resale. \"bo\":{ \"r3\": Rendezvous, # replaces stored Rendevous \"g3\": GUID, # replaces stored GUID \"n7\": Nonce # proves freshness of signature }, \"pk\": PublicKey, # Owner2 key (replaces Manufacturer\u2019s key). \"sg\": Signature # Proof of Owner2 key. } } Message Meaning: This message effects ownership transfer, causing the credentials previously used to take over the device to be replaced. If we recall the credentials programmed in the DI protocol, these are now updated based on the new credentials downloaded from the new Owner. Table 2 - Message Meaning Transformation - DI to T02 Old Entry (section \u200e5.3.1) New Value (Typical use case) New Value (Credential Reuse) Comments DI.SetCredentials.oh.**pv** unchanged unchanged Protocol version (fixed) DI.SetCredentials.oh.**pe** unchanged unchanged Public key encoding (fixed) DI.SetCredentials.oh.**r** TO2.SetupDevice.noh.bo.**r3** unchanged DI.SetCredentials.oh.**g** TO2.SetupDevice.noh.bo.**g3** unchanged DI.SetCredentials.oh.**d** Unchanged unchanged Manufacturer\u2019s info DI.SetCredentials.oh.**pk** TO2.SetupDevice.noh.**pk** unchanged noh.pk is Owner2 key The \u201cosinn\u201d field gives the number of owner service info messages that will be transmitted to the Device. The Owner should try to keep the size of each service info message down to less than 1300 bytes, to allow constrained device protocols to operate correctly. Note See Section \u00a7 for additional information on Resale protocol, and section \u00a7 for additional information on Credential Reuse protocol.","title":"TO2.SetupDevice, Type 47"},{"location":"protocol-specification/detailed-protocol-description/#to2getnextownerserviceinfo-type-48","text":"From Device TEE to New Owner Client Message format, after decryption and verification of HMAC: { \"nn\":Uint8 } Message Meaning: Requests next Owner Service Info message.","title":"TO2.GetNextOwnerServiceInfo, Type 48"},{"location":"protocol-specification/detailed-protocol-description/#to2ownerserviceinfo-type-49","text":"From New Owner Client to Device TEE Message Format - after decryption and verification of HMAC: { \"nn\": UInt8, # index of this message, from zero upwards \"sv\": ServiceInfo } Message Meaning: Contains ServiceInfo key value pairs, transmitted from Owner to Device. The Owner should send only enough pairs to keep within the likely constraints of the Device and the protocol. In particular, no more than 1300 bytes of ServiceInfo should be sent in a single message. ServiceInfo entries that are duplicated in subsequent messages are appended to the same named entries at the destination. This makes it possible to send an arbitrary sized ServiceInfo message. See section \u00a7 for information on service info. If TO2.OwnerServiceInfo.nn == TO2.SetupDevice.osinn-1 then the next state is TO2.Done. Otherwise the next state is TO2.GetNextOwnerServiceInfo.","title":"TO2.OwnerServiceInfo, Type 49"},{"location":"protocol-specification/detailed-protocol-description/#to2done-type-50","text":"From Device TEE to New Owner Client: Message Format - after decryption and verification of HMAC: { \"hmac:\": Hash, \"n6:\": Nonce # Nonce generated by New Owner Client # and sent to Device TEE in Msg TO2.ProveOPHdr } Message Meaning: Indicates successful completion of the Transfer of Ownership. The Client and Owner software now transitions to performing the requested actions between Device and Owner. For example, the Client can activate the scripting implicit in the ServiceInfo data structure received from the Rendezvous Server. The Device TEE discards and regenerates the secret from the DI Protocol. It then generates an \u201chmac\u201d field equivalent to the one in the [DI.SetHMac] message (see section \u00a7 ). The Owner may use this information to construct a new Ownership Voucher based on the Owner2 key and the new information configured into the Device in the TO2.SetupDevice message. This information permits the Owner to effect a new transfer of ownership by re-enabling the Secure Device Onboard software on the Device. If the Device does not support resale (see section \u00a7 ), and wishes to so inform the Owner, the HMAC is returned with zero length. It is legal for the Device to generate a valid HMAC but refuse to support resale at a later time. In this case, it is highly recommended that an out-of-band mechanism be provided to let the Owner know that the resale protocols will not work. If the Device supports Credential Reuse protocol and all the conditions for Credential Reuse are satisfied in TO2.SetupDevice, then a special value of HMAC with length 1 is returned (see section \u200e \u00a7 ).","title":"TO2.Done, Type 50"},{"location":"protocol-specification/detailed-protocol-description/#to2done2-type-51","text":"From New Owner Client to Device TEE: Message Format - after decryption and verification of HMAC: { \"n7:\": Nonce # Nonce generated by Device TEE and send to Owner in TO2.ProveDevice } Message Meaning: This message provides an opportunity for a final ACK after the Owner has invoked the System Info block to establish agent-to-server communications between the Device and its final Owner. When possible, the TO2.Done2 should be delayed until the Device has established agent-to-server communications, allowing an Secure Device Onboard error to occur when such communications fail. On some constrained devices, Secure Device Onboard software might not be able to run after the agent-to-server communications are set up. On these systems, this ACK can happen right after the TO2.Done message. Such systems cannot recover from a failure that appears after Secure Device Onboard has finished, but that prevents agent-to-server communications from being established. Examples of systems that cannot generate a response after agent-to-server communications are working include: Constrained systems that don\u2019t have enough resources to run both Secure Device Onboard and the agent-to-server subsystems. Systems that require a reboot to complete agent-to-server setup.","title":"TO2.Done2, Type 51"},{"location":"protocol-specification/detailed-protocol-description/#after-transfer-ownership-protocol-success","text":"The New Owner Client transfers device information to the manager server. The Device TEE indicates to its user-space handler to invoke the Device to Manager Agent for the manager service. This Device to Manager Agent should be given all the information that the TEE has now collected. The Device TEE transitions to the IDLE state. The new Owner has changed all credentials in the device, except the Device hardware root of trust (and some manufacturer-specific credentials) and has sufficient information to construct an Ownership Voucher with zero entries. The Rendezvous Service cannot verify an ownership voucher with zero entries. \u21a9 Note that bo.oh.pk is the initial owner public key from the Ownership Proxy Header, and should not be confused with bo.pk. \u21a9","title":"After Transfer Ownership Protocol Success"},{"location":"protocol-specification/introduction/","text":"Introduction \u00b6 This document specifies the protocol interactions and message formats for the Secure Device Onboard protocols. Secure Device Onboard is a device provisioning scheme, sometimes called device \u201conboarding.\u201d Device provisioning is the process of installing secrets and network addresses into a device so that the device and its network-based manager are able to connect using a trusted connection. For example, they may share a secret or have trusted PKI credentials. Device provisioning causes a new entity to own the device. This requires a strong degree of trust, since the device owner must at least provision communications credentials into a Device, and probably needs complete control over the device operating system and software. For example, the device owner must patch security vulnerabilities, install or update drivers, query hardware devices, program actuators, and others. A given kind of device may restrict what an owner can do to it using Secure Device Onboard, trading off the risk of remote network compromise with the cost of perhaps needing to physically access the device to do some restricted configuration. For the purposes of Secure Device Onboard, we assume that the device initiates a connection to the manager, and not the reverse. This is common industry practice, and has the advantages that: The IP address of the manager is less likely to change than the IP address of the device. The traffic outbound through network firewalls tends to be more permissive than the reverse, increasing the likelihood that the device to manager connection will not need special firewall policy. In Secure Device Onboard, device physical installation is kept separate from device keying and remote control. Secure Device Onboard works by establishing the ownership of a device during manufacturing, then tracking the transfers of ownership of the device until it is finally provisioned and put into service. In this way, the device provisioning problem can be thought of as a device \u201ctransfer of ownership\u201d problem. In Secure Device Onboard, we assume that this factory-time configuration is the only configuration done to the device. Other steps taken outside the device make it possible for the device to use this configuration to find and establish trust with its owner when it is first powered on after manufacturing. Between when the device is manufactured and when it is first powered on and given access to the Internet, the device may transfer ownership multiple times. A structured digital document, called an Ownership Voucher, is used to transfer digital ownership credentials from owner to owner without the need to power on the device. When the device is first plugged in, the Secure Device Onboard protocols are invoked, causing the device to access the Secure Device Onboard Rendezvous Server. By protocol cooperation between the device, the Rendezvous server, and the new owner, the device and new owner are able to prove themselves to each other, sufficient to allow the new owner to establish new cryptographic control of the device. When this process is finished, the device is equipped with: The Internet address and public key of its manager A random number that may be used as shared secret Optionally, a key pair whose public key is in a certificate signed by a trusted party of its manager This is expected to be a strong and flexible set of credentials, enough to satisfy most IoT device to manager needs. For example, this permits a 2-way authenticated Transport Layer Security (TLS) connection from device to manager. In the case where other credentials are needed, a TLS connection with the provisioned credentials should suffice to allow the manager to provide different ones. In our current model, we assume the device has access to the Internet when it is first powered on. In some environments, this will require that a second Secure Device Onboard Installer Tool be used to provide a temporary, perhaps restricted, Internet connection, sufficient to allow Secure Device Onboard to proceed. During manufacturing, an Secure Device Onboard equipped device is ideally configured with: A processor containing: A Trusted Execution Environment (TEE), with cryptographic hardware root of trust, based on either Intel \u00ae EPID or Elliptic Curve Digital Signature Algorithm (ECDSA) An Secure Device Onboard application that runs in the processor\u2019s TEE that maintains and operates on device credentials A set of device ownership credentials, accessible only within the TEE: Rendezvous information for determining the current owner of the device Hash of a public key to form the base of a chain of signatures, referred to as the Ownership Voucher Other credentials, please see section \u00a7 for more information. Secure Device Onboard may be deployed in other environments, perhaps with less expectation of security and tamper resistance. These include: A microcontroller unit (MCU), perhaps with a hardware root of trust, where the entire system image is considered to be a single trusted object An OS daemon, with keys sealed by a Trusted Platform Module (TPM) or in the filesystem The remainder of this document presumes the ideal environment, as described previously. Transmitted Protocol Version \u00b6 The current protocol version of Secure Device Onboard is 13.1 Every message of the transmitted protocol for Secure Device Onboard specifies a protocol version . This version indicates the compatibility of the protocol being transmitted and received. The actual number of the protocol version is a major version and a minor version, expressed in this document with a period character ('.') between them. The specification version may be chosen for the convenience of the public. The protocol version changes for technical reasons, and may or may not change for a given change in specification. The protocol version and specification version are different values, although a given specification must map to a given protocol version. The receiving party of a message can use the protocol version to verify: That the version is supported by the receiver That the version is the same as with previous received messages in the same protocol transaction Whether the receiver needs to invoke a backwards compatibility option. Since Secure Device Onboard allows the Device to choose any supported version of the protocol, this applies to the Owner or Rendezvous. Privacy Concerns \u00b6 Secure Device Onboard has a number of protocol features to preserve the privacy of a device\u2019s progress from manufacturing to ownership, to resale or decommissioning. All keys exposed by protocol entities are created only for the purposes of Secure Device Onboard, and can be used temporarily, and new ones generated frequently to keep them from being used as to profile a manufacturer, a device, or a device owner/operator. The Intel \u00ae Enhanced Privacy ID (Intel \u00ae EPID) can be used to prove the ability to take ownership without identifying the device to the Rendezvous server or to anyone monitoring Internet traffic at the Rendezvous server. Intel\u00ae EPID may also be used to prove manufacturer and model number without identifying device. Transfer Ownership protocol 2 (TO2), replaces all keys and identifiers in the device, except the root of trust, so that no record of previous ownership chain exists. In case of Intel \u00ae EPID, it is not necessary to replace the Intel \u00ae EPID key for based on a privacy concern. IP addresses can be allocated dynamically by the device owner. This does not prevent a determined adversary from using IP addresses to trace devices, but can raise the bar against more casual attempts to trace devices from outside to inside an organization. Intel \u00ae Enhanced Privacy ID (Intel \u00ae EPID) Attributes \u00b6 As Intel has acted to enable other companies to use Intel \u00ae EPID2 for a variety of devices and applications, a new Intel \u00ae EPID2 attributes feature has been added by the Intel Key Generation Facility ( iKGF ), an independent key issuing authority. Intel \u00ae EPID attributes are identifiers associated with an Intel \u00ae EPID group, and reflected in the group certificate. A common set of attributes is also represented in the 128-bit EPID2 Group ID. Group ID attributes are important because Intel \u00ae EPID does not identify a device except as the member of a group. Thus, an Intel \u00ae EPID signature is only as trustworthy as the least trustworthy member of the group, implying that\u2014for best results\u2014all members of the group should be equally trustworthy. The group ID attribute allows an Intel \u00ae EPID user to work with Intel Key Generation Facility (iKGF) so that all devices in a given Intel \u00ae EPID group have the same security posture (For example, the same binary or the same source code base). The iKGF can work with the device builder to allocate multiple EPID groups from within a single \u201cgroup address space\u201d so that a given product type can be detected by a 128-bit mask-and-compare operation. The Owner is responsible for maintaining a list of Intel \u00ae EPID attribute mask-and-compare sets for each kind of device that it is provisioning. When an Intel \u00ae EPID signature appears at the Owner (in the TO2 Protocol): The Group ID is compared against the Intel \u00ae EPID Attribute mask-and-compare sets to determine that this device is supported by this Owner (if not, the signature is rejected) The Group is checked for revocation (if so, the signature is rejected) The signature is verified against the group public key (if it fails to verify, the signature is rejected) We envision that Intel \u00ae EPID attribute mask-and-compare sets are included by manufacturers as part of their product documentation. Secure Device Onboard Terminologies \u00b6 SIGMA is a protocol that allows an Intel \u00ae EPID device to establish a trusted connection with a known entity, based on the provisioning of a Public Key Infrastructure (PKI) certificate on the trusted entity\u2019s server. This is similar to the operation performed by the Transfer Ownership Protocol 2 (TO2). In Secure Device Onboard, the trust of the Owner\u2019s server is derived from the manufacturer\u2019s credentials (its public key), through the Ownership Voucher, to the Owner key. 1 Trust in Secure Device Onboard follows the supply chain entities, and not an outside single root of trust. In particular, Secure Device Onboard specifically does not require server belonging to the Owner of a device to have a certificate that is rooted in any particular authority chosen by Intel. While this makes SIGMA itself inappropriate for Secure Device Onboard, the concepts of SIGMA are incorporated in the TO2 protocol. For example, Secure Device Onboard uses a similar key exchange and a Session Verification Key (SVK)/Session Encryption Key (SEK) mechanism to create an encrypted channel. Refer to the Secure Device Onboard Glossary document. Secure Device Onboard Transport Interfaces \u00b6 Figure \u200e1 describes the way in which Secure Device Onboard data is transported. Secure Device Onboard protocols are defined in terms of an Secure Device Onboard message layer (section \u00a7 ) and an encapsulation of these messages for transport to Secure Device Onboard network entities (section \u00a7 ). Secure Device Onboard Devices may be either natively IP-based or non-IP-based. In the case of Secure Device Onboard Devices which are natively connected to an IP network, the Secure Device Onboard Device is capable of connecting directly to the Secure Device Onboard Owner or Secure Device Onboard Rendezvous server. In some cases, an Secure Device Onboard Installer Tool is needed to allow these devices to connect to the IP network. The Secure Device Onboard Installer Tool is a HTTP/HTTPS Proxy, with security set up to allow only Secure Device Onboard protocols to authorized Secure Device Onboard Rendezvous and Secure Device Onboard Owners. Secure Device Onboard Devices which are not capable of IP protocols can still use Secure Device Onboard by tunneling the Secure Device Onboard Message Layer across a reliable non-IP connection. Secure Device Onboard messages implement authentication, integrity, and confidentiality mechanisms, so any reliable transport is acceptable. The Secure Device Onboard message layer also permits Secure Device Onboard to be implemented end-to-end in a co-processor or trusted execution environment. However, security mechanisms must be provided to allow credentials provisioned by Secure Device Onboard to be copied to where they are needed. For example, if Secure Device Onboard is used to provision a symmetric secret into a co-processor, but the secret is used in the main processor, there needs to be a mechanism to preserve the confidentiality and integrity of the secret when it is transmitted between the co-processor and main-processor. This mechanism is outside the scope of this specification. Figure 1 - Secure Device Onboard Transport Interfaces The Owner Key is the key signed in the last entry of the Ownership Voucher. The corresponding private key is held by the current owner of the Device. See section \u00a7 . \u21a9","title":"Introduction"},{"location":"protocol-specification/introduction/#introduction","text":"This document specifies the protocol interactions and message formats for the Secure Device Onboard protocols. Secure Device Onboard is a device provisioning scheme, sometimes called device \u201conboarding.\u201d Device provisioning is the process of installing secrets and network addresses into a device so that the device and its network-based manager are able to connect using a trusted connection. For example, they may share a secret or have trusted PKI credentials. Device provisioning causes a new entity to own the device. This requires a strong degree of trust, since the device owner must at least provision communications credentials into a Device, and probably needs complete control over the device operating system and software. For example, the device owner must patch security vulnerabilities, install or update drivers, query hardware devices, program actuators, and others. A given kind of device may restrict what an owner can do to it using Secure Device Onboard, trading off the risk of remote network compromise with the cost of perhaps needing to physically access the device to do some restricted configuration. For the purposes of Secure Device Onboard, we assume that the device initiates a connection to the manager, and not the reverse. This is common industry practice, and has the advantages that: The IP address of the manager is less likely to change than the IP address of the device. The traffic outbound through network firewalls tends to be more permissive than the reverse, increasing the likelihood that the device to manager connection will not need special firewall policy. In Secure Device Onboard, device physical installation is kept separate from device keying and remote control. Secure Device Onboard works by establishing the ownership of a device during manufacturing, then tracking the transfers of ownership of the device until it is finally provisioned and put into service. In this way, the device provisioning problem can be thought of as a device \u201ctransfer of ownership\u201d problem. In Secure Device Onboard, we assume that this factory-time configuration is the only configuration done to the device. Other steps taken outside the device make it possible for the device to use this configuration to find and establish trust with its owner when it is first powered on after manufacturing. Between when the device is manufactured and when it is first powered on and given access to the Internet, the device may transfer ownership multiple times. A structured digital document, called an Ownership Voucher, is used to transfer digital ownership credentials from owner to owner without the need to power on the device. When the device is first plugged in, the Secure Device Onboard protocols are invoked, causing the device to access the Secure Device Onboard Rendezvous Server. By protocol cooperation between the device, the Rendezvous server, and the new owner, the device and new owner are able to prove themselves to each other, sufficient to allow the new owner to establish new cryptographic control of the device. When this process is finished, the device is equipped with: The Internet address and public key of its manager A random number that may be used as shared secret Optionally, a key pair whose public key is in a certificate signed by a trusted party of its manager This is expected to be a strong and flexible set of credentials, enough to satisfy most IoT device to manager needs. For example, this permits a 2-way authenticated Transport Layer Security (TLS) connection from device to manager. In the case where other credentials are needed, a TLS connection with the provisioned credentials should suffice to allow the manager to provide different ones. In our current model, we assume the device has access to the Internet when it is first powered on. In some environments, this will require that a second Secure Device Onboard Installer Tool be used to provide a temporary, perhaps restricted, Internet connection, sufficient to allow Secure Device Onboard to proceed. During manufacturing, an Secure Device Onboard equipped device is ideally configured with: A processor containing: A Trusted Execution Environment (TEE), with cryptographic hardware root of trust, based on either Intel \u00ae EPID or Elliptic Curve Digital Signature Algorithm (ECDSA) An Secure Device Onboard application that runs in the processor\u2019s TEE that maintains and operates on device credentials A set of device ownership credentials, accessible only within the TEE: Rendezvous information for determining the current owner of the device Hash of a public key to form the base of a chain of signatures, referred to as the Ownership Voucher Other credentials, please see section \u00a7 for more information. Secure Device Onboard may be deployed in other environments, perhaps with less expectation of security and tamper resistance. These include: A microcontroller unit (MCU), perhaps with a hardware root of trust, where the entire system image is considered to be a single trusted object An OS daemon, with keys sealed by a Trusted Platform Module (TPM) or in the filesystem The remainder of this document presumes the ideal environment, as described previously.","title":"Introduction"},{"location":"protocol-specification/introduction/#transmitted-protocol-version","text":"The current protocol version of Secure Device Onboard is 13.1 Every message of the transmitted protocol for Secure Device Onboard specifies a protocol version . This version indicates the compatibility of the protocol being transmitted and received. The actual number of the protocol version is a major version and a minor version, expressed in this document with a period character ('.') between them. The specification version may be chosen for the convenience of the public. The protocol version changes for technical reasons, and may or may not change for a given change in specification. The protocol version and specification version are different values, although a given specification must map to a given protocol version. The receiving party of a message can use the protocol version to verify: That the version is supported by the receiver That the version is the same as with previous received messages in the same protocol transaction Whether the receiver needs to invoke a backwards compatibility option. Since Secure Device Onboard allows the Device to choose any supported version of the protocol, this applies to the Owner or Rendezvous.","title":"Transmitted Protocol Version"},{"location":"protocol-specification/introduction/#privacy-concerns","text":"Secure Device Onboard has a number of protocol features to preserve the privacy of a device\u2019s progress from manufacturing to ownership, to resale or decommissioning. All keys exposed by protocol entities are created only for the purposes of Secure Device Onboard, and can be used temporarily, and new ones generated frequently to keep them from being used as to profile a manufacturer, a device, or a device owner/operator. The Intel \u00ae Enhanced Privacy ID (Intel \u00ae EPID) can be used to prove the ability to take ownership without identifying the device to the Rendezvous server or to anyone monitoring Internet traffic at the Rendezvous server. Intel\u00ae EPID may also be used to prove manufacturer and model number without identifying device. Transfer Ownership protocol 2 (TO2), replaces all keys and identifiers in the device, except the root of trust, so that no record of previous ownership chain exists. In case of Intel \u00ae EPID, it is not necessary to replace the Intel \u00ae EPID key for based on a privacy concern. IP addresses can be allocated dynamically by the device owner. This does not prevent a determined adversary from using IP addresses to trace devices, but can raise the bar against more casual attempts to trace devices from outside to inside an organization.","title":"Privacy Concerns"},{"location":"protocol-specification/introduction/#intel-enhanced-privacy-id-intel-epid-attributes","text":"As Intel has acted to enable other companies to use Intel \u00ae EPID2 for a variety of devices and applications, a new Intel \u00ae EPID2 attributes feature has been added by the Intel Key Generation Facility ( iKGF ), an independent key issuing authority. Intel \u00ae EPID attributes are identifiers associated with an Intel \u00ae EPID group, and reflected in the group certificate. A common set of attributes is also represented in the 128-bit EPID2 Group ID. Group ID attributes are important because Intel \u00ae EPID does not identify a device except as the member of a group. Thus, an Intel \u00ae EPID signature is only as trustworthy as the least trustworthy member of the group, implying that\u2014for best results\u2014all members of the group should be equally trustworthy. The group ID attribute allows an Intel \u00ae EPID user to work with Intel Key Generation Facility (iKGF) so that all devices in a given Intel \u00ae EPID group have the same security posture (For example, the same binary or the same source code base). The iKGF can work with the device builder to allocate multiple EPID groups from within a single \u201cgroup address space\u201d so that a given product type can be detected by a 128-bit mask-and-compare operation. The Owner is responsible for maintaining a list of Intel \u00ae EPID attribute mask-and-compare sets for each kind of device that it is provisioning. When an Intel \u00ae EPID signature appears at the Owner (in the TO2 Protocol): The Group ID is compared against the Intel \u00ae EPID Attribute mask-and-compare sets to determine that this device is supported by this Owner (if not, the signature is rejected) The Group is checked for revocation (if so, the signature is rejected) The signature is verified against the group public key (if it fails to verify, the signature is rejected) We envision that Intel \u00ae EPID attribute mask-and-compare sets are included by manufacturers as part of their product documentation.","title":"Intel\u00ae Enhanced Privacy ID (Intel\u00ae EPID) Attributes"},{"location":"protocol-specification/introduction/#secure-device-onboard-terminologies","text":"SIGMA is a protocol that allows an Intel \u00ae EPID device to establish a trusted connection with a known entity, based on the provisioning of a Public Key Infrastructure (PKI) certificate on the trusted entity\u2019s server. This is similar to the operation performed by the Transfer Ownership Protocol 2 (TO2). In Secure Device Onboard, the trust of the Owner\u2019s server is derived from the manufacturer\u2019s credentials (its public key), through the Ownership Voucher, to the Owner key. 1 Trust in Secure Device Onboard follows the supply chain entities, and not an outside single root of trust. In particular, Secure Device Onboard specifically does not require server belonging to the Owner of a device to have a certificate that is rooted in any particular authority chosen by Intel. While this makes SIGMA itself inappropriate for Secure Device Onboard, the concepts of SIGMA are incorporated in the TO2 protocol. For example, Secure Device Onboard uses a similar key exchange and a Session Verification Key (SVK)/Session Encryption Key (SEK) mechanism to create an encrypted channel. Refer to the Secure Device Onboard Glossary document.","title":"Secure Device Onboard Terminologies"},{"location":"protocol-specification/introduction/#secure-device-onboard-transport-interfaces","text":"Figure \u200e1 describes the way in which Secure Device Onboard data is transported. Secure Device Onboard protocols are defined in terms of an Secure Device Onboard message layer (section \u00a7 ) and an encapsulation of these messages for transport to Secure Device Onboard network entities (section \u00a7 ). Secure Device Onboard Devices may be either natively IP-based or non-IP-based. In the case of Secure Device Onboard Devices which are natively connected to an IP network, the Secure Device Onboard Device is capable of connecting directly to the Secure Device Onboard Owner or Secure Device Onboard Rendezvous server. In some cases, an Secure Device Onboard Installer Tool is needed to allow these devices to connect to the IP network. The Secure Device Onboard Installer Tool is a HTTP/HTTPS Proxy, with security set up to allow only Secure Device Onboard protocols to authorized Secure Device Onboard Rendezvous and Secure Device Onboard Owners. Secure Device Onboard Devices which are not capable of IP protocols can still use Secure Device Onboard by tunneling the Secure Device Onboard Message Layer across a reliable non-IP connection. Secure Device Onboard messages implement authentication, integrity, and confidentiality mechanisms, so any reliable transport is acceptable. The Secure Device Onboard message layer also permits Secure Device Onboard to be implemented end-to-end in a co-processor or trusted execution environment. However, security mechanisms must be provided to allow credentials provisioned by Secure Device Onboard to be copied to where they are needed. For example, if Secure Device Onboard is used to provision a symmetric secret into a co-processor, but the secret is used in the main processor, there needs to be a mechanism to preserve the confidentiality and integrity of the secret when it is transmitted between the co-processor and main-processor. This mechanism is outside the scope of this specification. Figure 1 - Secure Device Onboard Transport Interfaces The Owner Key is the key signed in the last entry of the Ownership Voucher. The corresponding private key is held by the current owner of the Device. See section \u00a7 . \u21a9","title":"Secure Device Onboard Transport Interfaces"},{"location":"protocol-specification/protocol-data-types/","text":"Protocol Data Types \u00b6 All data is transmitted in a JavaScript* Object Notation (JSON) subset, as described in section \u00a7 : Message Passing Protocol. Base Types \u00b6 Numeric Types \u00b6 Numeric types are transmitted as JSON* integers. Numbers are represented in JSON* using the following representation: Table 1 - Numeric Types Type Data Size JSON* Representation Uint8 8 bits 0..255 Uint16 16 bits 0..65535 Uint32 32 bits 0..4294967303 The JSON* representation does not indicate the size of the object. The size (8-bits, 16-bits, and 32-bits) is given to allow constrained implementations the ability to select the data size in which to store the result. Also, there are no negative numbers used in the JSON* subset. The parser does not have to support them. All integers will fit in 32 bits of data. However, integers in the range of 0x8000000-0xffffffff may be interpreted as negative numbers on some systems (For example, Java* integers). The implementations should take care to ensure that the integers are always treated as positive. Boolean \u00b6 True is represented as the number 1 False is represented as the number 0 JSON* true and false are not used. String Types \u00b6 Strings are represented as JSON* strings, delimited with double quotation marks (\"). However: Only printable ASCII characters may be in strings (ASCII codes 0x20-0x7e). Non-ASCII characters may be encoded in \\uXXXX format (For example, \\u20ac is the euro symbol). To simplify parsing, the follow characters may not be encoded in strings, except using the \\uXXXX format: Double quote (\", \\u0022) Open and close square brackets ([, \\u005b) and (], \\u005d) Open and close brace brackets ({, \\u007b) and (}, \\u007d) Backslash (\\, \\u005c) Ampersand (&, \\u0026) Backslash escaping is NOT used (For example, a string containing a double quote \"\\\"\" must be transmitted as \"\\u0022\" rather than \"\\\"\"). ByteArray Types \u00b6 Byte arrays are represented as a string containing base64 data, padded with equal signs. The string may contain only the base64 characters, and may not contain embedded spaces or new lines, regardless of its length. With this proviso, the base64 encoding follows MIME, as described in [[RFC2045]]. However, only characters from the base64 alphabet may be encoded into these strings; whitespace is not permitted. For example: \" CgU/GQ==\" represents a byte array with 4 bytes, containing 10,5,63,25. Byte arrays look like JSON* strings. The context is used to tell them apart. The length of a ByteArray is not specified in the encoding, but messages always have a length field sufficient to pre-allocate storage for the ByteArray. This is not needed for the encoding, but makes constrained implementations easier. Note that, if the storage for the ByteArray is n , the length of the base64 string is ((n+2)/3)*4 , using integer arithmetic. 1 To simplify the parser, we specify that ByteArrays always contain encoded data for every byte (this avoids the need to scan ahead to see how big the input is compared to the expected buffer size). 2 Composite Types \u00b6 Composite types are combinations or contextual encodings of base types. In the following table, the type is represented by a JSON* pseudo-code, where name(type) is used to indicate the name of the quantity and the JSON* type. Table 2 - JSON* Pseudo-Code Types Type Format Meaning Stream Message 3 [ Length((String containing hex), Type(integer), ProtocolVersion, Message Body (Object) ] See section \u00a7 . The length is stored in hexadecimal format fully specified as 4 hex characters. A message longer than 0xFFFF bytes is stored as a 32-bit hexadecimal number fully specified as 8 hex characters. Length((String containing hex), ProtocolVersion Integer, represented as: Major * 100 + Minor States the protocol version. For example: version 10.35 is represented as: 1035. Hash / HMAC [ length (UInt8), hashtype (UInt8), hash[length] (ByteArray) ] Crypto hash, with length in bytes preceding. For example, a SHA256 hash looks like: [32,8,\"base64\u2026\"] Hashes are computed in accordance with [[FIPS-180-4]] A HMAC is encoded as a hash. See the following Wikipedia page for more information: https://en.wikipedia.org/wiki/Hash-based_message_authentication_code PKNull [ 0 ] Encoding of null public key, used as a placeholder when no public key is available. PKX509Enc [ pkBytes, #Bytes in X.509 encoding pkx509[pkBytes](ByteArray) #X509 encoding itself ] Encoding of Public Key in X.509 4 PKRMEEnc [ modBytes, # size of group number modba(ByteArray), # group number as byte array expBytes, # Exponent bytes expba(ByteArray) # Exponent as byte array ] Public Key RSAMODEXP encoding. Encoding is compatible with Java* BigInteger PKEPIDEnc [ epidGroupNoBytes, # size of group number epidGroupNo(ByteArray) # group number as byte array ] Public Key EPID 1.1 encoding. The group no identifies the specific Intel \u00ae EPID public key used to generate the signature. The actual key value is extracted from Intel \u00ae EPID artifacts are maintained by Intel. /td> SigInfo [ sgType(Uint8) Length(Uint16), Info(ByteArray) ] SigInfo is used to encode parameters for the device attestation signature, This is specifically needed for Intel \u00ae EPID revocation and other parameters needed for Intel \u00ae EPID signing. sgType is a Signature Type from section \u00a7 . PublicKey [ pkType(Uint8), # Crypto type<sup id=\"fnref:9\"><a class=\"footnote-ref\" href=\"#fn:9\">5</a></sup> pkEnc(Uint8), # Encoding of key<sup id=\"fnref:12\"><a class=\"footnote-ref\" href=\"#fn:12\">8</a></sup> PKX509Enc | # body PKRMEEnc | PKEPIDEnc | PKNull ] Public key. Body is one of the above types, depending on the encoding. Signature [ Length(Uint16), Signature(ByteArray) ] The actual signature bits. These come at the end of the signature block. SignatureBlock { \"bo\": body(JSON object), # The thing being signed (body) \"pk\": PublicKey, \"sg\": Signature } ManufacturerBlock {# ManufacturerBlock \"d\": String # deviceInfo \u2013 manufacturer\u2019s model num } Manufacturer block, stored in device OwnerBlock {# OwnerBlock \"pv\": UInt16, # Protocol version \"pe\": UInt8, # key encoding \"g\": Guid, # GUID of this device \"r\": RendezvousInfo, # How to find rendezvous server \"pkh\": Hash # Hash of mfg's pubkey } Ownership block, stored in device DeviceCredentials { \"ST\": UInt8 # SDO State \"Secret\": ByteArray # HMAC secret \"M\": {#ManufacturerBlock \"d\": String } \"O\": {#OwnerBlock \"pv\": UInt16 \"pe\": UInt8 \"r\": RendezvousInfo \"g\": Guid \"pkh\": Hash } } Credentials stored in device Nonce ByteArray\\* (16 bytes) 128-bit Random number, intended to be used *only once*. GUID ByteArray\\* (16 bytes) 128-bit Random number used for identification. Typically 128 bits. IP Address [ length(Uint8), ByteArray ] Length = 4 for IPv4. Length = 16 for IPv6. RendezvousInstr [length(Uint8), {ve1:v1,ve2:v2\u2026}] Length = num of ve:v pairs. VE 6 stands for Variable Encoding. RendezvousInfo [ length(Uint8), RendezvousInstr1\u2026 RendezvousInstrN ] Rendezvous information. This explains how to contact a Rendezvous Server. AppID [ length(Uint8), # length in bytes of array type(Uint8), # Type is always ByteArray appIdBytes(ByteArray) # Bytearray containing ID ] AppID values currently in use are allocated by the Intel Client. 10 This type value is not currently used, but maintained for backwards compatibility. KeyExchange [ length(Uint16), KexParam(ByteArray) # Parameter A or B (owner is A) ] Key exchange parameters 7 IVData [ length(Uint8), IVData (ByteArray) ] Cipher Initialization Vector (section \u00a7 ). IV encoded as byte array Hash Types and HMAC Types \u00b6 Hash types are based on IANA DNSSEC codes. Please view the following webpage for more details: http://www.iana.org/assignments/dns-sec-alg-numbers/dns-sec-alg-numbers.xhtml HMAC types are the corresponding hash type incremented by 100. The HMAC secret must be derived by context. Table 3 - Hash Types and HMAC Hash number Hash Algorithm 0 No hash present or hash/HMAC of illegal length present. This value is used only in the Credential Reuse protocol. 8 SHA256* 10 SHA512 14 SHA384 108 HMAC-SHA256* 110 HMAC-SHA512 114 HMAC-SHA384 Other values Reserved The size of the hash and HMAC functions used in the protocol depend on the size of the keys used for device and owner attestation. Table \u200e3\u20114 lists the mapping. The hash and HMAC that are affected by the size of device and owner attestation keys are listed as follows: Hash of device certificate in Ownership Voucher (OP.hdc) Hash of previous entry in Ownership Voucher entries (OP.OwnershipProxyEntry.hp) Hash of header in Ownership Voucher entries (OP.OwnershipProxyEntry.hc) Public key hash in Ownership Credentials (PM.CredOwner.pkh) Hash of to0d object (TO0.OwnerSign.to1d.to0dh) HMAC generated by device (DI.SetHMAC.hmac ,TO2.Done.hmac, and OP.hmac) Table 4 - Mapping of Hash/HMAC Types with Key Sizes Device Attestation Owner Attestation Hash and HMAC Types Intel \u00ae EPID RSA2048RESTR SHA256/HMAC-SHA256 ECDSA NIST P-256 RSA2048RESTR SHA256/HMAC-SHA256 ECDSA NIST P-384 RSA2048RESTR SHA384/HMAC-SHA384 (Not a recommended configuration)* Intel \u00ae EPID RSA 3072-bit key SHA256/HMAC-SHA256 ECDSA NIST P-256 RSA 3072-bit key SHA256/HMAC-SHA256 (Not a recommended configuration)* ECDSA NIST P-384 RSA 3072-bit key SHA384/HMAC-SHA384 Intel \u00ae EPID ECDSA NIST P-256 SHA256/HMAC-SHA256 ECDSA NIST P-256 ECDSA NIST P-256 SHA256/HMAC-SHA256 ECDSA NIST P-384 ECDSA NIST P-256 SHA384/HMAC-SHA384 (Not a recommended configuration)* Intel \u00ae EPID ECDSA NIST P-384 SHA384/HMAC-SHA384 ECDSA NIST P-256 ECDSA NIST P-384 SHA384/HMAC-SHA384 (Not a recommended configuration)* ECDSA NIST P-384 ECDSA NIST P-384 SHA384/HMAC-SHA384 Note on not recommended configurations, above The Ownership Voucher and the Device key in this configuration have different cryptographic strengths. It is recommended that the strongest cryptographic strength always be used, and that the strengths match between Device and Owner. Public Key Types \u00b6 Public keys types are based on IANA DNSSEC codes, see: http://www.iana.org/assignments/dns-sec-alg-numbers/dns-sec-alg-numbers.xhtml The public key length is derived based on the (explicit) length of the storage provided for it. Table 5 - Public Key Number and Associated Algorithm Public Key Number Public Key Algorithm 0 No public key present 1 RSA2048RESTR (RSA with restrictions imposed by legacy TEE environments) 2 DH 3 DSA (not currently used) 4 RSA_UR (Any valid RSA public key) 13 ECDSA P-256 14 ECDSA P-384 90 Intel \u00ae Enhanced Privacy ID (Intel \u00ae EPID) v1.0 91 Intel \u00ae EPID v1.1 92 Intel \u00ae EPID v2.0 113 ECC P-256 key used for ECDH key exchange (this code is not currently used in the protocol) 114 ECC P-384 key used for ECDH key exchange (this code is not currently used in the protocol) Other values Reserved Public Key Encodings \u00b6 The key encoding is listed in the table below. Table 6 - Encoding Number Table Public Key Encoding Encoding Name 0 No public key present 1 X.509 3 RSAMODEXP \u2013 RSA2048RESTR or RSA_UR key with modulus + exponent 4 Intel \u00ae EPID Owner and Server implementations must support all public key encodings, as well as null keys under X.509 encoding. RSAMODEXP Encoding \u00b6 In the RSAMODEXP encoding, an RSA key is represented by two byte arrays, one for the modulus and one for the exponent. The modulus and exponent are based on the Java* Big Integer encoding, a big-endian, signed, two\u2019s complement representation: Big-endian: most significant byte is first, least significant byte is last. Signed encoding: the modulus and exponent are always positive, but the encoding can handle negative numbers. This means that the most significant bit of the most significant byte (that is, the top bit of byte 0) must match the sign. To accomplish this, an extra most significant byte of 0x00 or 0xff might need to be pre-pended to the number. For example: 32768 = 0x8000 must be represented as three bytes: 0x008000 . Note that this may require removing the first byte transmitted for some crypto packages and key values. Two\u2019s complement: the normal encoding of integers in a computer, where the negative of a number is the complement of the bits (aka: one\u2019s complement), plus one. For example, 32768 is represented as: 0x008000 (as above). Complementing the bits gives 0xff7fff . Adding one gives: 0xff8000 which is -32768. This can be simplified to two bytes: 0x8000 , since the sign bit still correctly identifies the number as negative. For implementation , we are aware of crypto packages that use similar encodings, except that the modulus and exponent are always positive, so no extra sign byte is needed. The above encoding may need to be \u201ctweaked\u201d by removing/adding the extra sign byte to work with such packages. For example, one package requires that the size of the modulus always be the number of bytes which is a power of two (For example, 256 bytes), and the sign byte pushed it over by one (to 257 bytes). Signatures \u00b6 A signature is a JSON* object with 3 tags: \"bo\" -- the body to be signed. The signature body is the entire object associated with the \u201cbo\u201d tag, exclusive of the tag itself. This object is hashed byte-for-byte as transmitted. Note that no spaces or comments are permitted in our subset of JSON*, and that strings are always encapsulated with double quotes. In some implementations, it might be necessary to reconstruct the original JSON* from a parsed version to verify the signature.' \"pk\" -- the public key to apply to the signature. Note, when the Public Key is null, the \u201cpk\u201d tag must still be present with the value \u201cPKNull\u201d (see section \u00a7 ). \"sg\" -- the signature material itself. Signatures may be: RSA sign with PKCS1 v1.5 padding, using SHA-256 hash ECDSA NIST P-256. The signature format uses ASN.1 schema ([12], [13]) encoded with Distinguished Encoding Rules (DER) [14]. RSA sign with PKCS1 v1.5 padding, using SHA-384 hash (future crypto) ECDSA NIST P-384 (future crypto) Intel \u00ae EPID 1.0 signatures. The signature format uses ASN.1 schema ([12], [13]) encoded with Distinguished Encoding Rules (DER) [14] Intel \u00ae EPID 1.1 signatures Intel \u00ae EPID 2.0 signatures Signature generation proceeds as follows: Compute the hash on the body, exactly as you will transmit it. Encrypt the hash using the private key. Include the public key in the signature object, under the \u201cpk\u201d tag. Signature verification proceeds as follows: Compute the hash on the body, exactly as transmitted. Decrypt the signature with the public key, as provided in the \u201cpk\u201d tag. Verify that the decrypted signature matches the hash. The body is a single JSON* item that is terminated by a comma, which in practice is always a JSON* object. Thus, the plain text for the signature will be an object that is inclusive of the brace brackets. Example: {\"bo\":{\"n3\":\"WpTgdZooMD0=\"},\"pk\":[1,3,[257,\"AKgIjL \u2026 257 bytes of b64 ...5nCQRk=\", 3,\"AQAB\"]],\"sg\":[256,\"kuL2 ... 256 bytes of b64 \u2026 Ps/pfw==\"]} The plaintext to be signed is the string: {\"n3\":\"WpTgdZooMD0=\"} Device Attestation Signature and Mechanism \u00b6 The Device Attestation signature is used by the Secure Device Onboard Device to prove its authenticity to the Secure Device Onboard Rendezvous and the Secure Device Onboard Owner. Various cryptographic signing mechanisms can be used for this purpose. In this specification, we present mechanisms based on Intel \u00ae Enhanced Privacy Identifier (Intel \u00ae EPID) signatures and Elliptical Curve Digital Signature Algorithm (ECDSA) signatures. In some cases, a signature cannot stand alone, but requires some protocol interaction to prepare for it. For example, a multi-application Trusted Execution Environment (TEE) may need to negotiate program instance parameters with the verifier before the signature can be trusted. In particular, Intel \u00ae EPID signers need to obtain revocation information and cooperatively sign \u201cproofs\u201d. For this reason, the Device Attestation mechanism exchanges the following three messages: eA -- from device to signature verifier, provides initial device based information eB -- from verifier to device, provides a response to eA sg -- from device to verifier, contains the actual signature The eA and eB messages are structured as \u201cSigInfo\u201d, and contain a field that identifies the signature type as defined in Table \u200e3\u20117. Table 7 - Signatures Types Encoding Type Name Type Description 13 ECDSA P-256 ECDSA P-256 signature with SHA-256 hash 14 ECDSA P-384 ECDSA P-384 signature with SHA-384 hash 90 EPID10 Intel \u00ae EPID 1.0 signature information for the Intel Client environment. Sufficient information to generate the Intel Client \u201cEPID provisioning\u201d call. 91 EPID11 Intel \u00ae EPID 1.1 signature information for the Intel Client environment. Sufficient information to generate the Client \u201cEPID provisioning\u201d call. 92 EPID20 Intel \u00ae EPID 2.0 signature information for non-Intel Client implementation. Intel \u00ae Enhanced Privacy ID (Intel \u00ae EPID) Signatures Overview \u00b6 Intel \u00ae Enhanced Privacy ID (Intel \u00ae EPID) signatures are generated by Devices that support a Hardware Root of Trust based on Intel \u00ae EPID 1.0, Intel \u00ae EPID 1.1, or Intel \u00ae EPID 2.0. Intel \u00ae EPID 2.0 is implemented at Intel with both 32-bit and 128-bit group IDs. This specification assumes 128-bit group IDs for Intel \u00ae EPID. Intel \u00ae EPID 32-bit group IDs are supported by extending the 32-bit group ID to 128 bits by zero padding to the left (most significant bits), thus mapping the 32-bit group space into the 128-bit group space. In some cases, the Secure Device Onboard implementation must convert group IDs back and forth for platform software that requires 32-bit group IDs. To our knowledge, platforms where the Intel \u00ae EPID 2.0 software supports only 32-bit group IDs are matched by hardware provisioned with Intel \u00ae EPID keys with 32-bits. The EPID signer needs Intel \u00ae EPID revocation information in order to generate a valid Intel \u00ae EPID signature from an Intel \u00ae EPID private key. In particular, the signer needs the signature revocation list (SIGRL) for its group. The SIGRL may be obtained from Intel\u2019s iKGF web sites, but it is easiest to obtain using the Intel \u00ae EPID Verification Service. In some platforms, Intel \u00ae EPID revocation information is downloaded using other tools. However, for consistency, Secure Device Onboard allows the Device to download this information as part of the TO1 and TO2 Protocols. Intel \u00ae EPID information is encoded in the SigInfo structures eA, eB, and in the pkType and sg fields of the signature itself. Typically eA and eB are in subsequent messages, with the Intel \u00ae EPID signed message coming just afterwards. Intel \u00ae Enhanced Privacy ID (Intel \u00ae EPID) 1.1 Signatures (type EPID11) \u00b6 Intel \u00ae EPID 1.1 signature information is encoded using the EPID11 signature type, using the \u201ceA\u201d, \u201ceB\u201d and \u201csg\u201d fields, each from separate messages. The contents of each field is as follows: eA encodes the EPID group ID as 4 bytes, in network byte order (MSB first): Table 8 - eA Encoding, type EPID11 Type Name Description BYTE[4] groupId EPID 1.1 group ID eB encodes the EPID certificate and other items needed by the Intel Client. The SIGRL is inside the group certificate. Length values (UInt16) are encoded in network order (MSB first): Table 9 - eB Encoding, type EPID11 Type Name Description UInt16 groupCertSigma10Size Size of data in groupCertSigma10 field BYTE[] groupCertSigma10 Legacy group certificate (binary format) UInt16 groupCertSigma11Size Size of data in groupCertSigma11 field BYTE[] groupCertSigma11 X.509 group certificate UInt16 sigRLSize Size of data in sigRL field (in bytes) BYTE[] sigRL SigRL as given below If there is no SIGRL, sigRLSize is zero, and sigRL is empty (not present). Note sigRL non-zero implies that n2 > 0 (below). The sigRL format is as follows (all fields are encoded in network order (MSB first)): Table 10 - SigRL Format Type Field Name Description UInt16 sver Intel \u00ae EPID version number. Must be 0x0001 for Intel \u00ae EPID1.1 UInt16 blobID ID of the data type. Must be 0x000e for SigRL UInt32 gid Group ID UInt32 RLver Revocation list version number UInt32 n2 Number of entries in SigRL BYTE[64] (n2 of them) B[i] for i in range [0; n2-1] Bi elements of G3 BYTE[64] (n2 of them) K[i] for i in range [0; n2-1] Ki elements of G3 BYTE[64] sig 512-bit ECDSA signature on the revocation list signed by the issuer using Intel Signing Key (ISK). **Contact Secure Device Onboard Enablement team for details.** sg encodes the signature, according to the Intel \u00ae EPID1.1 specification. The length is given in the message format: Table 11 - sg Encoding, type EPID11 Type Name Description BYTE[] signature Intel \u00ae EPID 1.1 signature according to the Intel \u00ae EPID 1.1 specification The data being signed is: Table 12 - Data Signatures, type EPID11 Type Name Description BYTE[48] Prefix All zeros, except: Prefix[4]=0x48 and Prefix[8]=0x8 BYTE[16] ID App-ID, same as in message body (\u201cai\u201d tag in messages: TO1.ProveToSDO and TO2.ProveDevice) BYTE[16] Zero-padding Zeros BYTE[16] Nonce Nonce value same as in message body (\u201cn4\u201d tag in messages: TO1.ProveToSDO and \u201cn6\u201d tag in TO2.ProveDevice) BYTE[16] Zero-padding Zeros (used to allow Nonce to be 32 bytes) BYTE[] Message body As in this protocol specification, from open to close brace bracket of JSON* text. Rendezvous Service and Owner must (logically) prefix the contents of the message with specific data (as above), before doing Intel \u00ae EPID verification. Intel \u00ae Enhanced Privacy ID (Intel \u00ae EPID) 2.0 Signatures (non-Intel Client, type EPID20) \u00b6 Intel \u00ae EPID 2.0 signatures are encoded using \u201ceA\u201d, \u201ceB\u201d and the \u201csg\u201d fields, each from separate messages. The contents of each field is as follows: eA encodes the EPID group ID as 16 bytes, in network byte order (MSB first). Hosts which use Intel \u00ae EPID2.0 with 32-bit group IDs must zero pad the top 96 bits. Table 13 - eA Encoding, type EPID20 Type Name Description BYTE[16] groupId Intel \u00ae EPID 2.0 group ID eB encodes the signature revocation list (sigRL) and EPID group public key. Length values (UInt16) are encoded in network order (MSB first): Table 14 - eB Encoding, type EPID20 Type Name Description UInt16 sigRLSize Size of data in sigRL field BYTE[sigRLSize] sigRL SigRL according to Intel \u00ae EPID 2.0 specification UInt16 publicKeySize Size of data in publicKey field BYTE[publicKeySize] publicKey Group public key according to Intel \u00ae EPID 2.0 specification sg encodes the signature, according to the Intel \u00ae EPID 2.0 specification. The length is given in the message format. Table 15 - sg Encoding, type EPID20 Type Name Description BYTE[] signature Intel \u00ae EPID 2.0 signature according to Intel \u00ae EPID 2.0 specification Intel \u00ae Enhanced Privacy ID (Intel \u00ae EPID) 1.0 Signatures (type EPID10) \u00b6 Intel \u00ae EPID 1.0 signature information is encoded using the EPID10 signature type, using the \u201ceA\u201d, \u201ceB\u201d and \u201csg\u201d fields, each from separate messages. The contents of each field is as follows: eA encodes the EPID group ID as 4 bytes, in network byte order (MSB first): Table 16 - eA Encoding, type EPID10 Type Name Description BYTE[4] groupId Intel \u00ae EPID 1.0 group ID eB encodes the Intel \u00ae EPID certificate and other items needed by the Intel Client. The SIGRL is inside the group certificate. Length values (UInt16) are encoded in network order (MSB first): Table 17 - eB Encoding, type EPID10 Type Name Description UInt16 groupCertSigma10Size Size of data in groupCertSigma10 field BYTE[] groupCertSigma10 Legacy group certificate (binary format) sg encodes the signature, according to the Intel \u00ae EPID 1.0 specification. The length is given in the message format: Table 18 - sg Encoding, type EPID10 Type Name Description BYTE[] Signature Intel \u00ae EPID 1.0 signature according to Intel \u00ae EPID 1.0 specification The data being signed is: Table 19 - Data Signatures, type EPID10 Type Name Description BYTE ID-length Length of ID field BYTE[] ID App-ID, same as in message body (\u201cai\u201d tag in messages: TO1.ProveToSDO and TO2.ProveDevice) BYTE[16] Nonce Nonce value same as in message body (\u201cn4\u201d tag in messages: TO1.ProveToSDO and \u201cn6\u201d tag in TO2.ProveDevice) BYTE[] Message body As in this protocol specification, from open to close brace bracket of JSON text. Rendezvous Service and Owner must (logically) prefix the contents of the message with specific data (as above), before doing Intel \u00ae EPID verification. ECDSA NIST P-256 and ECDSA NIST P-384 Signatures \u00b6 The ECDSA attestation is used for devices where the Intel \u00ae EPID privacy mechanisms are not needed. The Device contains an ECDSA private key, and the Ownership Voucher is enhanced to give the Owner access to the public key. The public key is typically encoded in an X.509 certificate, signed by one or more Certificate Authorities. The private key is used to sign the device attestation. The public key is used to verify the signature. For ECDSA attestation, the Length field in eA and eB encoding is set to 0 and Info field is not present (zero length). ECDSA NIST P-256 uses SHA-256 hash, and ECDSA NIST P-384 uses SHA-384 hash. For ECDSA, both the private key and the public key are Device identities. This means that the Secure Device Onboard Rendezvous Service and Secure Device Onboard Owner who verify the Device attestation signature receive a unique and permanent identity for the device, even before they verify the signature. This information can be used to trace the subsequent owners of the device. For this reason, we recommend careful administrative measures to ensure that this information is used securely and discarded appropriately. Null Public Keys \u00b6 A public key in the \u201cpk\u201d tag may be left as null. This is done when the public key is already known to the verifying party, because it is a requirement that it know it, or because it was already transmitted earlier. Intel \u00ae EPID public keys encode only the group number in the \u201cpk\u201d tag, since this is sufficient to identify the public key to the Intel back end. Null public keys are used for some testing stubs. RendezvousInfo \u00b6 The RendezvousInfo type indicates the manner and order in which the Device and Owner find the Rendezvous Server. It is configured during manufacturing (For example, at an ODM), so the manufacturing entity has the choice of which Rendezvous Server to use and how to access it. RendezvousInfo consists of a sequence of rendezvous instructions which are interpreted in order during the TO0 and TO1 Protocols (JSON* sequence of object, such as [{t1:v1,\u2026},\u2026,{tn,\u2026}]). The tags are encoded in alphabetical/character encoding order. Unlike other Secure Device Onboard JSON* objects, JSON* tags appear only for instructions that differ from the default. Other variables assume default values. A default value of \u201cnone\u201d indicates that the variable is assumed not present in the instruction unless its tag appears explicitly. Each set of rendezvous instructions (that is, each element of the JSON* sequence) is interpreted as one set of instructions for reaching the Rendezvous Server, with differing conditions. For example, one set might indicate using the wireless interface, and another set might indicate using the wired interface. It is possible that a given set corresponds to multiple ways to access the Rendezvous Server (For example, multiple IP addresses that correspond to a single DNS name), and these must all be tried before the Device or Owner moves to the next element of the sequence. The Owner and Device process the RendezvousInfo, attempting to access the Rendezvous Server. The first successful connection may be used. The Device and Owner may avoid obviously redundant operations, such as contacting the same IP address twice when a DNS name maps to an IP address explicit in a separate rendezvous instruction. To execute each rendezvous instruction, the program defines a set of variables, one for each JSON* tag in the RendezvousInfo instructions. It initializes all variables to default values. Then the rendezvous instruction is interpreted, and updates each variable. If the user input variable is set to true, and user input is available, the user is allowed to update each variable. On constrained devices, some variables do not exist. The constrained implementation interprets each instruction as if this variable was not present. Some variables apply only to the Owner and some only to the Device. See the table below. When a variable does not apply, it is interpreted as if it had never been specified. This means that the Owner can only ever notice the tags: \u201conly\u201d, \u201cip\u201d, \u201cpow\u201d, \u201cdelaysec\u201d, and \u201cdn\u201d. This is because the Owner, as a cloud-based server, is expected to use normal Internet rules to access the Rendezvous Service. The Device, which may be in a specialized network and may be constrained, might need additional parameters. The \u201conly\u201d (Only for) and \"delaysec\" tags have side effects. When \"only\":\"dev\" appears in a set of instructions, an Owner must skip the entire set When \"only\":\"owner\" appears in a set of instructions, a Device must skip the entire set When \"delay\":UInt32 appears in a set of instructions, the set is followed by a delay for the number of seconds specified, increased or decreased by a random value up to 25%. An instruction that contains just a \u201cdelay\u201d, can be appended to the end of the RendezvousInfo to force a particular randomized delay before retrying the entire sequence. Table 20 - RendezvousInfo Variables Rendezvous Instruction Variable Default Value Variable Encoding Tag Variable Type Required Device Owner Only for None \"only\" \"dev\" or \"owner\" No Yes Yes IP address None \"ip\" IPAddress Yes Yes Yes Port, Device Based on protocol \"po\" UInt16 Yes Yes No Port, Owner Based on protocol \u201cpow\u201d UInt16 No No Yes DNS name None \"dn\" String Yes Yes Yes TLS Server cert hash None \"sch\" Hash No Yes No TLS CA cert hash None \"cch\" Hash No Yes No User input No \"ui\" UInt8 (0/1) No Yes No SSID None \"ss\" String If has Wi-Fi* Yes No Wireless Password None \"pw\" String If has Wi-Fi* Yes No Wireless Security Password Chosen Automatically \"wsp\" String If has Wi-Fi* Yes No Medium *Device dependent* \"me\" String Yes Yes No Protocol TLS \"pr\" String No Yes No Delay 0 \u201cdelaysec\u201d UInt32 Yes Yes Yes Rendezvous Instruction (RendezvousInstr) entries are specified as having the variables in alphabetical order. This does not affect the interpretation of these variables, but makes the computation of a signature that includes them simpler for some implementations. If the \u201conly\u201d element appears, and the value does not match the interpreting entity (Device/Owner), this instruction is terminated and control proceeds with the next set of instructions. Medium is selected (\u201cme\u201d). The Device uses the selected preferred medium, or terminates this instruction. When no medium is specified, the Device may establish its own preference, perhaps based on the other parameters (for example, TLS might be available on one medium, but not another). The protocol is chosen (\u201cpr\u201d), if it is supported. Otherwise, the instruction terminates. The Owner always chooses the protocol \u201chttps\u201d. The Device attempts to resolve the DNS address. If DNS query is successful, then the resolved IP addresses are tried one after another. Else, if DNS resolution fails or the Device fails to communicate with all of the resolved IP addresses, then the specified IP address is used as the target IP address. Else, the instruction terminates. If TLS is used on a Device (pr=https or pr=tls), the hash instructions are used as specified against server certificates appearing in the TLS handshake (or, for ps=https, the underlying TLS connection\u2019s handshake). This applies to the Device only. If the server certificate hash is specified (on a Device), the server\u2019s certificate is extracted from the certificate chain, SHA256 hash computed, and compared to the specified value. Failure to match causes the TLS authentication to fail. If the CA certificate hash is specified (on a Device), the other certificates in the server certificate chain are extracted one by one, SHA256 hash computed, and compared to the specified value. Any match allows TLS authentication to proceed. No match causes TLS authentication to fail. The Owner always applies usual CA trust to server certificates used in TLS for the TO0 Protocol. Attempt as many connections as are implied by the set of variables established and choices made, above. For example, try each of the addresses returned by a DNS query if there is a valid DNS name. If a \u201cdelaysec\u201d tag appears, delay as specified. If \u201cdelaysec\u201d does not appear and the last entry in RendezvousInfo has been processed, a delay of 120s \u00b1 random(30) is executed. Medium values: \"eth0\"..\"eth9\" mapped to first through 10th wired Ethernet interfaces. These interfaces may appear with different names in a given platform. \"eth\\*\" means to try as many wired interfaces as makes sense for this platform, in any order. For example, a device which has one or more wired interfaces that are configured to access the Internet (For example, \u201cwan0\u201d) might use this configuration to try any of them that has Ethernet link. \"wifi0\" .. \"wifi9\" mapped to first through 10th Wi-Fi* interfaces. These interfaces may appear with different names in a given platform. \"wifi\\*\" means to try as many Wi-Fi* interfaces as makes sense for this platform, in any order *Others* *device dependent.* Protocol Values: \"rest\": first supported protocol from: HTTPS HTTP CoAP/TCP \"tcp\": bare TCP, if supported \"tls\": bare TLS, if supported \"CoAP/tcp\": CoAP protocol over tcp, if supported \"http\": HTTP over TCP \"https\": HTTP over TLS, if supported Example of RendezvousInfo: Different Ports for Device and Owner \u00b6 \u2026\"r\":[1,{\"dn\":\"mpservice.net\",\"po\":80,\"pow\":443}]\u2026 On both Device (TO1 Protocol) and Owner (TO0 Protocol), attempt to connect to all IP addresses returned by the DNS query for \u201cmpservice.net\u201d. The Owner queries TO0 Protocol on port 443 (Owner always uses TLS). The Device queries TO1 Protocol on port 80 (might be HTTP or HTTPS, or both, depending on the device default). In the following situation, the Device needs to try Wi-Fi* media, as many as it can connect to. The Owner just uses the DNS name without the Wi-Fi* media specification, because \u201cme\u201d applies only to Devices, and is thus ignored by the Owner. [1,{\"me\":\"wifi\\*\",\"dn\":\"mpservice.net\"}] The above is thus equivalent to: [2,[3, {\"only\":\"dev\",\"me\":\"wifi\\*\",\"dn\":\"mpservice.net\"}], [2{\"only\":\"owner\",\"dn\":\"mpservice.net\"}]] (Inserted newline for formatting purposes) In the above, \u201ceth \u201d could be used for wired interfaces that are purposed for Internet access, such as the outside* wired interface on a gateway or router. ServiceInfo and Management Service \u2013 Agent Interactions \u00b6 The ServiceInfo type is a collection of key-value pairs which allows an interaction between the Management Service (on the cloud side) and Management Agent functions (on the device side), using the Secure Device Onboard encrypted channel as a transport. Conceptually, each key-value pair is a message between a module in the Owner and a module on the Device that implements some primitive function. Messages have a name and a value. The ServiceInfo key is the module name and the message name, separated by a colon. ServiceInfo is constrained to a subset of printable ASCII, but base64 or other encoding may be used to encode any textual or binary formats. ServiceInfo Key ServiceInfo Value moduleName:messageName where both moduleName and messageName are printable ASCII characters containing no Unicode escapes (\\uXXXX) or the characters: {}[]&\"\\ (see Table 1 in section \u00a7 ). Where appropriate, the moduleName may contain a version of the module. By convention, the version is separated using a hyphen character (\u2018-\u2018), as in: tpm-1.2 or tpm-2. Printable ASCII characters containing no Unicode escapes (\\uXXXX) or the characters: {}[]&\"\\ (see Table 1 in section \u00a7 ) Individual or lists of Numbers and selectors (enum type strings) may be expressed directly in ASCII. Textual and binary data should be encoded in base64. Other encodings are permissible on a module-by-module basis, with the above limits. Messages sent to a module on the Secure Device Onboard Device may interact with the Device OS to install software components. Another message might use those components in combination with a cryptographic key, to establish communications. In some systems, the Management Agent might be installed by cooperating modules before it is active by others, allowing an \u201coff-the-shelf\u201d device to be customized by Secure Device Onboard. The intention is that modules will implement common or standardized IOT provisioning functions, and will be reused for different IOT solutions provisioned by Secure Device Onboard. In some cases, modules on the Secure Device Onboard Owner and Secure Device Onboard Device will be designed to cooperate directly with each other. For example, a module that implements a particular device management client on the Secure Device Onboard Device, and its counterpart that feeds it exactly the right credentials on the Secure Device Onboard Owner. In other cases, modules may implement IOT or OS primitives so that the Secure Device Onboard Owner or Secure Device Onboard Device picks and chooses among them. For example, allocating a key pair on the Secure Device Onboard Device; signing a certificate on the Secure Device Onboard Owner; transferring a file into the OS; upgrading software; and so on. The following set of examples is presented for illustrative purposes, and is not intended to constrain Secure Device Onboard implementations in any way: Example Key Example Value Comment firmware_update:active 1 Hypothetical firmware update module, sends \u201cactive\u201d message with value of 1 (true) firmware_update:codeSize 262144 Code size is 256k firmware_update:code001 Base64 data First 512 bytes of firmware update, encoded in base64 firmware_update:verify Base64 data SHA-384 of firmware image wget:hashSha384 Base64 data SHA-384 hash of data that is downloaded in the next message wget:CAfiles.dat http://myserver/CAfiles.dat Download CA database cmd-linux:\\#!/bin/sh exec /usr/local/bin/mydaemon -k mykeyfile.pkcs7 -ca CAfiles.dat Hypothetical module to execute Linux* scripting commands, message name gives interpreter, value gives shell code The API between the Management Agent / Device OS and the Secure Device Onboard Device, and between the Management Service and the Secure Device Onboard Owner, are outside the scope of this document. The requirements for this API are as follows: A mechanism to discover modules on the Secure Device Onboard Owner and to establish a preference among them (analogous to a preference for TPM2 over TPM1.2) A mechanism to connect modules on the Secure Device Onboard Device. A complex Secure Device Onboard Device might be able to discover modules, but a simpler device could have modules \u201chard\u201d coded A mechanism to generate Secure Device Onboard messages to modules. As above, modules can send messages to their counterparts or to other modules On constrained Secure Device Onboard Devices, common code for performing base64 decoding is desirable. Common code for modules to store and buffer state from messages is desirable. On complex Secure Device Onboard Devices, the ability of modules to send messages to each other may also be supported. For example, a file transfer module and a file storage module might be called as primitives for a \u201cfile transfer and store\u201d module. One special case of the above. We envision a \u201cTEE\u201d module, that encapsulates messages for other modules, but causes an error unless these modules are implemented at the same security level as the Secure Device Onboard implementation (For example, in the same Trusted Execution Environment). For example, TEE:tpm:createkey causes an error if the module called \u201ctpm\u201d is not at the same security level as Secure Device Onboard. This module might encrypt data to ensure that it can only be processed in a trusted environment. Implementations which support multiple security levels for code execution should allow for this function, since this capability cannot be simulated using other Secure Device Onboard mechanisms. Management Service - Agent Interactions via ServiceInfo Mapping Messages to ServiceInfo \u00b6 A module may have an arbitrary number of messages. There are no arrays, but numbered message names can be used to simulate their effect (mod:key1, mod:key2). Since ServiceInfo messages are separated into one or more Secure Device Onboard messages, it is possible to use the same message over and over again. Whether this is has a cumulative or repetitive effect is up to the module that interprets the messages (For example, file:part might be repeated for successive parts, but tpm:certificate might be individual certificates). Messages are processed in the order they appear in ServiceInfo. The same message may also be repeated in a single ServiceInfo. ServiceInfo does not have to be interpreted as it is parsed from the message. It is legal to buffer the entire ServiceInfo and interpret it all later. However, the messages must be interpreted in the same order. The SDO Device Module \u00b6 The \u201csdodev\u201d module implements a set of messages to the Secure Device Onboard Owner that identify the capabilities of the device. All Secure Device Onboard Owners must implement this module, and Secure Device Onboard Owner implementations must provide these messages to any module asks for them. The \u201csdodev\u201d messages must appear first in the Device ServiceInfo. The following messages are defined in the SDO Device Module: Table 21 - sdodev Module Device Service Info Keys Device Service Info Key Disposition Meaning / Action sdodev:os Required OS name (For example, Linux*) sdodev:arch Required Architecture name / instruction set (For example, X86_64) sdodev:version Required Version of OS (For example, \u201cUbuntu* 16.0.4LTS\u201d) sdodev:device Required Model specifier for this Secure Device Onboard Device, manufacturer specific sdodev:sn Optional Serial number for this Secure Device Onboard Device, manufacturer specific sdodev:pathsep Optional Filename path separator, between the directory and sub-directory (For example, \u2018/\u2019 or \u2018\\\u2019) sdodev:sep Required Filename separator, that works to make lists of file names (For example, \u2018:\u2019 or \u2018;\u2019) sdodev:nl Optional Newline sequence (For example, \u201c\\u000a\u201d or \u201c\\u000d\\u000a\u201d) sdodev:tmp Optional Location of temporary directory, including terminating file separator (For example, \u201c/tmp\u201d) sdodev:dir Optional Location of suggested installation directory, including terminating file separator (For example, \u201c.\u201d or \u201c/home/sdo\u201d or \u201cc:\\Program Files\\SDO\u201d) sdodev:progenv Optional Programming environment. See Table \u200e22 (For example, \u201cbin:java:py3:py2\u201d) sdodev:bin Required Either the same value as \u201carch\u201d, or a list of machine formats that can be interpreted by this device, in preference order, separated by the \u201csep\u201d value (For example, \u201cx86:X86_64\u201d) sdodev:mudurl Optional URL for the Manufacturer Usage Description file that relates to this device (See CR023) sdodev:modules Optional A list of module names supported by this Secure Device Onboard Device, separated by the separator specified in \u201csdodev:sep\u201d The \u201cprogenv\u201d key-value is used to indicate the Device\u2019 capabilities for running programs. This is a list of tags, separated by the \u201csep\u201d value, that indicates which programming environments are available and preferred on this platform. For example, bin;perl;cmd means use system binary format (preferred), but Perl* is also supported, and Windows* CMD shell is also supported, but Perl* is preferred over CMD. The following tags are supported at present. Version numbers may be appended to the tag (as in py2 and py3). Table 22 - sdodev Module \"progenv\" Key Tags \u201cprogenv\u201d tag Meaning bin System-dependent most common binary format (the \u201carch\u201d key-value may inform the format) java Java* class/jar (openJDK* compatible) js Node.js* (Javascript*) py2 Python* version 2 py3 Python* version 3 perl* Perl* 5 bash Bourne shell ksh KornShell* sh *NIX system shell (whichever one it is) cmd Windows* CMD psh Windows PowerShell* vbs Windows Visual Basic* Script \u2026 (Other specifiers may be defined on request. Contact the Secure Device Onboard Enablement team) Module Selection \u00b6 In some Secure Device Onboard implementations, multiple modules can perform overlapping functions. Some modules may implement legacy versions of others (For example, TPM versions) and some modules may implement alternative IOT control techniques (For example, MQTT versus CoAP). The Secure Device Onboard Owner and Secure Device Onboard Device need to negotiate to select the right set of modules. In this version of Secure Device Onboard, module selection is as follows: The [TO2.GetNextDeviceServiceInfo.psi] variable lists modules supported by the Secure Device Onboard Owner in order of Owner preference. The [Device ServiceInfo] indicates which modules are selected by including an \u201cactive\u201d message and provides device-side data for the modules from the Management Agent. The [Owner ServiceInfo] may deselect modules with its own \u201cactive\u201d messages, and provides messages containing owner-side data from the Management Service. If possible, all module functions should complete in time to allow the Secure Device Onboard operation to succeed or fail based on module operation, so that a module failure causes the entire Secure Device Onboard operation to fail and be retried later. In some cases, the module cannot determine success criteria before Secure Device Onboard completes (For example, a firmware update module must restart the system to invoke the new software), and Secure Device Onboard must complete \u201con faith\u201d that all is well. Any error in a module must cause the entire Secure Device Onboard session to fail with an error message. Module Selection Using the Pre-ServiceInfo (PSI) Variable 11 \u00b6 The \u201cPre-ServiceInfo\u201d variable: TO2.GetNextDeviceServiceInfo.psi is a string that starts the ServiceInfo handshake. The Psi variable encodes a mini-ServiceInfo. The format of the \u201cpsi\u201d variable is: modName1 : modMsg1 \\~ modVal1 , modName2 : modMsg2 \\~ modVal2 \u2026 This is a comma-list of module-message-value triplets, where the module name is delimited with a colon (\u2018:\u2019), and the message is delimited from the value with a tilde (\u2018\\~\u2019). The moduleData is used when the Secure Device Onboard Device must perform specific Owner-driven operations before the Device ServiceInfo. For example, a TPM module might need the number of key pairs to allocate. The purpose of the Pre-ServiceInfo (PSI) variable is to allow the Secure Device Onboard Owner to require specific action from the Secure Device Onboard Device before it sends the Device ServiceInfo. This might be required, for example, if the Secure Device Onboard Owner needed the Secure Device Onboard Device to allocate a specific number of keys or other resources, then offer them to the Secure Device Onboard Owner. This choice might imply a preference from the Owner to the Device as well. If the Secure Device Onboard Owner has no such requirement, it need not generate the Pre-ServiceInfo. For example, a constrained Secure Device Onboard Device may always generate the same Device ServiceInfo. In this case, the Pre-ServiceInfo has no function. Module information in the PSI may be used to indicate a preference for one module over another. For example, the Secure Device Onboard Owner may indicate that a TPM2 module is preferred over a TPM1.2 module, even if both are supported by the Owner and the Device. Consider the following psi variable: tpm-1.2:pref\\~tpm-2;tpm-2:keys\\~3,tpm-2:type\\~ecc, tpm-1.2:keys\\~3,tpm-1.2:type\\~rsa This might indicate support for: a tpm module at version 2 that has an argument indicating 3 RSA key-pairs are needed, the same module at version 1.2 also needing 3 key-pairs (but ECC); and a preference for module tpm-2 over tpm-1.2 (the \u201cpref\u201d message). Following this example, an Secure Device Onboard Device that supports TPM 1.2 can enable the appropriate module and allocate 3 RSA key pairs, and another Secure Device Onboard Device with both TPM 1.2 and TPM 2.0 capability can select TPM 2.0 and allocate 3 ECC key pairs. In each case, the Device ServiceInfo is used to activate a particular module. Constrained Secure Device Onboard implementations do not need to parse Pre-ServiceInfo, unless they need to access moduleData. Specifically, a constrained Secure Device Onboard Device that always allocates one key pair does not need to scan the \u201cpsi\u201d variable. Module Activation in Device ServiceInfo \u00b6 A module on the Secure Device Onboard Device indicates its availability to the Secure Device Onboard Owner by sending the active message with value 1 (true): In Device ServiceInfo: \u2026 \" modName :active \":\" 1 \", \u2026 The active message must precede all other messages sent by a given module. An Secure Device Onboard Owner may only send messages to a module that has sent an active message. Messages to non-existent or non-activated modules cause the Secure Device Onboard session to be terminated with an error message. An Secure Device Onboard Owner may refuse the activation of a module by sending a de-activating active message: In Owner ServiceInfo: \u2026 \" modName :active \":\" 0 \", \u2026 If the Secure Device Onboard Owner sends a de-activate message, it may not send any other messages to this module in this Secure Device Onboard session. The Secure Device Onboard Owner must de-activate all modules that it does not intend to use. For example, a constrained Secure Device Onboard Device may implement a management module and a firmware update module. It activates both modules, sending the current firmware version as a parameter of firmware update. The Secure Device Onboard Owner can decide either to accept this version of firmware and de-activate the firmware update module, or decide to update the firmware and de-activate the management module. Secure Device Onboard Version 1.0 Key-Values \u00b6 Version 1.0 of Secure Device Onboard implemented a different set of key-value pairs. We have elected to replace this mechanism with the current one. Implementers who need to support the previous Device- and Owner-ServiceInfo key-value pairs should contact the Secure Device Onboard Enablement team at Intel. Examples \u00b6 In the following examples, spaces are provided for clarity, and fragments of ServiceInfo are presented. Expressing Values in Different Encodings \u00b6 \u2026 \"mymod:options\",\"foo,bar\"\u2026 \u2026 \"mymod:options\",\"Zm9v,YmFy\" \u2026 \u2026 \"mymod:options\",\"Zm9vLGJhcg==\" \u2026 These 3 example each defines a message \u201coptions\u201d with value \u201cfoo,bar\u201d. The first gives the value in printable ASCII, the second in a list of base64 values, the third as a list completely encoded in base64. Which value is correct depends on the implementation of \u201cmymod\u201d. Hypothetical File transfer (Owner ServiceInfo) \u00b6 \"binaryfile:name\",\"myfile.tmp\", \"binaryfile:length\",\"1234\", \"binaryfile:data001\",\"\u2014 base64-data-512-bytes \u2014\", \"binaryfile:data002\",\"\u2014 base64-data \u2014 512-bytes \u2014\", \"binaryfile:data003\",\"\u2014 base64-data-210-bytes \u2014\", \"binaryfile:sha-384\",\"\u2014 base64-data \u2014 48-bytes \u2014\" In this example, a \u201cbinary file\u201d module allows a file to be downloaded using the Secure Device Onboard secure channel. The data002 and data003 variables need to be in separate ServiceInfo messages to keep message sizes within spec. Base64 encoding is used to allow the module to generate a binary file. The last message allows the file transfer to be verified after it is stored in the filesystem, as an added integrity check. Another way to accomplish file transfer would be to use an external HTTP connection. For example: \"wget:filename\":\"myfile.tmp\", \"wget:url\":\"http://myhost/myfile.tmp\", \"wget:sha-384\":\"\u2014 base64-data \u2014 48-bytes \u2014\" In this case, the file is transferred using a separate connection, perhaps at OS level. If the file is confidential, \u2018https:\u2019 could be used instead of \u2018http:\u2019. Both these techniques are valid in Secure Device Onboard, and represent two sides of a trade-off. Using the Secure Device Onboard channel, a small file can be transferred without needing a parallel network connection (see section \u00a7 for limitations on the Secure Device Onboard channel size). However, the same file might be transferred much faster using an optimized HTTP implementation, and might not require the confidentiality built into Secure Device Onboard (For example, the file contents might be posted on a public Internet site). Table \u200e23 discusses the trade-off. Secure Device Onboard is tuned to provide access to the Secure Device Onboard server using HTTP or HTTPS. Since Secure Device Onboard may run in a proxy environment created by the Secure Device Onboard Installer Tool (see section \u00a7 ), other protocols should be used only when both the Secure Device Onboard Device, Secure Device Onboard Owner and the installation network are known to support them. Otherwise, stick with HTTP/HTTPS. Table 23 - Comparison of Transferring a File Using Secure Device Onboard Channel or Independent Channel File Transfer Using Secure Device Onboard Channel File Transfer Using HTTP Mechanism Performance based on Secure Device Onboard protocol (slow for file large data) Performance based on HTTP or HTTPS, designed for streaming large amounts of data. Second stream required. Can download large amounts of bulk data or programs (limited to the number of ServiceInfo iterations) Can download arbitrary amounts of bulk data or programs Data can be stored in a file Data can be stored in a file Data can be executed as a program Data can be executed as a program Data is encrypted using Secure Device Onboard channel Data is encrypted only if HTTPS is used. Data is verified using Secure Device Onboard channel Data can verified by the module if a hash of contents (For example, SHA-384) is included Hypothetical Direct Code Execution \u00b6 \"code:architecture\",\"x86_64\", \"code:length\":\"512\", \"code:machinecode001\",\"\u2014 base64-data-512-bytes \u2014\", In this example, a module permits loading and executing machine code (this might be needed on a MCU). Obviously, this requires a high degree of trust in the Secure Device Onboard implementation, and perhaps an ability to execute code in a sandbox. Implementation Notes \u00b6 This section is not logically part of the Secure Device Onboard specification. An Secure Device Onboard implementation may implement ServiceInfo in a variety of ways. It is recommended that Secure Device Onboard implementations create a ServiceInfo interface on both Device and Owner side, that allows an easy plug-in mechanism. On the Owner side, a dynamic plug-in mechanism may by easier to maintain. On the Device side, a statically linked or compiled mechanism may be required due to system constraints. However, a more capable Device that runs Linux OS might be able to implement a flexible scripted mechanism similar to init.d . As stated above, constrained Devices do not need to implement pre-ServiceInfo, unless they actually present choices of module, or except if they need to scan for a modData parameter. In a given implementation it is possible to process the ServiceInfo variables as they arrive or in a batch. However, the order of interpretation of messages must be preserved. To illustrate this, consider the following Python* script: import base64 s='abcdefghijklmnop' for n in range(0,5): print n, (((n+2)/3)*4), s[0:n], base64.encodestring(s[0:n]), Output is: 0 0 1 4 a YQ== 2 4 ab YWI= 3 4 abc YWJj 4 8 abcd YWJjZA== 5 8 abcde YWJjZGU= \u21a9 It is conceivable to specify a compressed data format, then define that it is encoded in a ByteArray. We do not currently have such a case in this document. \u21a9 Stream Message - Only the Message Body is transmitted for REST protocols. \u21a9 If pkBytes=0, then key is null. Please see section \u200e \u00a7 : Signatures. \u21a9 For more information, please see section \u200e \u00a7 : Public Key Types. \u21a9 For more information, please see section \u200e \u00a7 : RendezvousInfo. \u21a9 For more information, please see section \u00a7 : Key Exchange in the TO2 Protocol. Please see section \u00a7 : Data Transmission for more information. \u21a9 For more information, please see section \u200e \u00a7 : Public Key Encodings. \u21a9 For more information, please see section \u00a7 : RendezvousInfo. \u21a9 For more information, please see section \u200e \u00a7 : EPID 1.1 Signatures. \u21a9 We intend to replace the PreServiceInfo variable with a more general mechanism in future versions of Secure Device Onboard. \u21a9","title":"Protocol Data Types"},{"location":"protocol-specification/protocol-data-types/#protocol-data-types","text":"All data is transmitted in a JavaScript* Object Notation (JSON) subset, as described in section \u00a7 : Message Passing Protocol.","title":"Protocol Data Types"},{"location":"protocol-specification/protocol-data-types/#base-types","text":"","title":"Base Types"},{"location":"protocol-specification/protocol-data-types/#numeric-types","text":"Numeric types are transmitted as JSON* integers. Numbers are represented in JSON* using the following representation: Table 1 - Numeric Types Type Data Size JSON* Representation Uint8 8 bits 0..255 Uint16 16 bits 0..65535 Uint32 32 bits 0..4294967303 The JSON* representation does not indicate the size of the object. The size (8-bits, 16-bits, and 32-bits) is given to allow constrained implementations the ability to select the data size in which to store the result. Also, there are no negative numbers used in the JSON* subset. The parser does not have to support them. All integers will fit in 32 bits of data. However, integers in the range of 0x8000000-0xffffffff may be interpreted as negative numbers on some systems (For example, Java* integers). The implementations should take care to ensure that the integers are always treated as positive.","title":"Numeric Types"},{"location":"protocol-specification/protocol-data-types/#boolean","text":"True is represented as the number 1 False is represented as the number 0 JSON* true and false are not used.","title":"Boolean"},{"location":"protocol-specification/protocol-data-types/#string-types","text":"Strings are represented as JSON* strings, delimited with double quotation marks (\"). However: Only printable ASCII characters may be in strings (ASCII codes 0x20-0x7e). Non-ASCII characters may be encoded in \\uXXXX format (For example, \\u20ac is the euro symbol). To simplify parsing, the follow characters may not be encoded in strings, except using the \\uXXXX format: Double quote (\", \\u0022) Open and close square brackets ([, \\u005b) and (], \\u005d) Open and close brace brackets ({, \\u007b) and (}, \\u007d) Backslash (\\, \\u005c) Ampersand (&, \\u0026) Backslash escaping is NOT used (For example, a string containing a double quote \"\\\"\" must be transmitted as \"\\u0022\" rather than \"\\\"\").","title":"String Types"},{"location":"protocol-specification/protocol-data-types/#bytearray-types","text":"Byte arrays are represented as a string containing base64 data, padded with equal signs. The string may contain only the base64 characters, and may not contain embedded spaces or new lines, regardless of its length. With this proviso, the base64 encoding follows MIME, as described in [[RFC2045]]. However, only characters from the base64 alphabet may be encoded into these strings; whitespace is not permitted. For example: \" CgU/GQ==\" represents a byte array with 4 bytes, containing 10,5,63,25. Byte arrays look like JSON* strings. The context is used to tell them apart. The length of a ByteArray is not specified in the encoding, but messages always have a length field sufficient to pre-allocate storage for the ByteArray. This is not needed for the encoding, but makes constrained implementations easier. Note that, if the storage for the ByteArray is n , the length of the base64 string is ((n+2)/3)*4 , using integer arithmetic. 1 To simplify the parser, we specify that ByteArrays always contain encoded data for every byte (this avoids the need to scan ahead to see how big the input is compared to the expected buffer size). 2","title":"ByteArray Types"},{"location":"protocol-specification/protocol-data-types/#composite-types","text":"Composite types are combinations or contextual encodings of base types. In the following table, the type is represented by a JSON* pseudo-code, where name(type) is used to indicate the name of the quantity and the JSON* type. Table 2 - JSON* Pseudo-Code Types Type Format Meaning Stream Message 3 [ Length((String containing hex), Type(integer), ProtocolVersion, Message Body (Object) ] See section \u00a7 . The length is stored in hexadecimal format fully specified as 4 hex characters. A message longer than 0xFFFF bytes is stored as a 32-bit hexadecimal number fully specified as 8 hex characters. Length((String containing hex), ProtocolVersion Integer, represented as: Major * 100 + Minor States the protocol version. For example: version 10.35 is represented as: 1035. Hash / HMAC [ length (UInt8), hashtype (UInt8), hash[length] (ByteArray) ] Crypto hash, with length in bytes preceding. For example, a SHA256 hash looks like: [32,8,\"base64\u2026\"] Hashes are computed in accordance with [[FIPS-180-4]] A HMAC is encoded as a hash. See the following Wikipedia page for more information: https://en.wikipedia.org/wiki/Hash-based_message_authentication_code PKNull [ 0 ] Encoding of null public key, used as a placeholder when no public key is available. PKX509Enc [ pkBytes, #Bytes in X.509 encoding pkx509[pkBytes](ByteArray) #X509 encoding itself ] Encoding of Public Key in X.509 4 PKRMEEnc [ modBytes, # size of group number modba(ByteArray), # group number as byte array expBytes, # Exponent bytes expba(ByteArray) # Exponent as byte array ] Public Key RSAMODEXP encoding. Encoding is compatible with Java* BigInteger PKEPIDEnc [ epidGroupNoBytes, # size of group number epidGroupNo(ByteArray) # group number as byte array ] Public Key EPID 1.1 encoding. The group no identifies the specific Intel \u00ae EPID public key used to generate the signature. The actual key value is extracted from Intel \u00ae EPID artifacts are maintained by Intel. /td> SigInfo [ sgType(Uint8) Length(Uint16), Info(ByteArray) ] SigInfo is used to encode parameters for the device attestation signature, This is specifically needed for Intel \u00ae EPID revocation and other parameters needed for Intel \u00ae EPID signing. sgType is a Signature Type from section \u00a7 . PublicKey [ pkType(Uint8), # Crypto type<sup id=\"fnref:9\"><a class=\"footnote-ref\" href=\"#fn:9\">5</a></sup> pkEnc(Uint8), # Encoding of key<sup id=\"fnref:12\"><a class=\"footnote-ref\" href=\"#fn:12\">8</a></sup> PKX509Enc | # body PKRMEEnc | PKEPIDEnc | PKNull ] Public key. Body is one of the above types, depending on the encoding. Signature [ Length(Uint16), Signature(ByteArray) ] The actual signature bits. These come at the end of the signature block. SignatureBlock { \"bo\": body(JSON object), # The thing being signed (body) \"pk\": PublicKey, \"sg\": Signature } ManufacturerBlock {# ManufacturerBlock \"d\": String # deviceInfo \u2013 manufacturer\u2019s model num } Manufacturer block, stored in device OwnerBlock {# OwnerBlock \"pv\": UInt16, # Protocol version \"pe\": UInt8, # key encoding \"g\": Guid, # GUID of this device \"r\": RendezvousInfo, # How to find rendezvous server \"pkh\": Hash # Hash of mfg's pubkey } Ownership block, stored in device DeviceCredentials { \"ST\": UInt8 # SDO State \"Secret\": ByteArray # HMAC secret \"M\": {#ManufacturerBlock \"d\": String } \"O\": {#OwnerBlock \"pv\": UInt16 \"pe\": UInt8 \"r\": RendezvousInfo \"g\": Guid \"pkh\": Hash } } Credentials stored in device Nonce ByteArray\\* (16 bytes) 128-bit Random number, intended to be used *only once*. GUID ByteArray\\* (16 bytes) 128-bit Random number used for identification. Typically 128 bits. IP Address [ length(Uint8), ByteArray ] Length = 4 for IPv4. Length = 16 for IPv6. RendezvousInstr [length(Uint8), {ve1:v1,ve2:v2\u2026}] Length = num of ve:v pairs. VE 6 stands for Variable Encoding. RendezvousInfo [ length(Uint8), RendezvousInstr1\u2026 RendezvousInstrN ] Rendezvous information. This explains how to contact a Rendezvous Server. AppID [ length(Uint8), # length in bytes of array type(Uint8), # Type is always ByteArray appIdBytes(ByteArray) # Bytearray containing ID ] AppID values currently in use are allocated by the Intel Client. 10 This type value is not currently used, but maintained for backwards compatibility. KeyExchange [ length(Uint16), KexParam(ByteArray) # Parameter A or B (owner is A) ] Key exchange parameters 7 IVData [ length(Uint8), IVData (ByteArray) ] Cipher Initialization Vector (section \u00a7 ). IV encoded as byte array","title":"Composite Types"},{"location":"protocol-specification/protocol-data-types/#hash-types-and-hmac-types","text":"Hash types are based on IANA DNSSEC codes. Please view the following webpage for more details: http://www.iana.org/assignments/dns-sec-alg-numbers/dns-sec-alg-numbers.xhtml HMAC types are the corresponding hash type incremented by 100. The HMAC secret must be derived by context. Table 3 - Hash Types and HMAC Hash number Hash Algorithm 0 No hash present or hash/HMAC of illegal length present. This value is used only in the Credential Reuse protocol. 8 SHA256* 10 SHA512 14 SHA384 108 HMAC-SHA256* 110 HMAC-SHA512 114 HMAC-SHA384 Other values Reserved The size of the hash and HMAC functions used in the protocol depend on the size of the keys used for device and owner attestation. Table \u200e3\u20114 lists the mapping. The hash and HMAC that are affected by the size of device and owner attestation keys are listed as follows: Hash of device certificate in Ownership Voucher (OP.hdc) Hash of previous entry in Ownership Voucher entries (OP.OwnershipProxyEntry.hp) Hash of header in Ownership Voucher entries (OP.OwnershipProxyEntry.hc) Public key hash in Ownership Credentials (PM.CredOwner.pkh) Hash of to0d object (TO0.OwnerSign.to1d.to0dh) HMAC generated by device (DI.SetHMAC.hmac ,TO2.Done.hmac, and OP.hmac) Table 4 - Mapping of Hash/HMAC Types with Key Sizes Device Attestation Owner Attestation Hash and HMAC Types Intel \u00ae EPID RSA2048RESTR SHA256/HMAC-SHA256 ECDSA NIST P-256 RSA2048RESTR SHA256/HMAC-SHA256 ECDSA NIST P-384 RSA2048RESTR SHA384/HMAC-SHA384 (Not a recommended configuration)* Intel \u00ae EPID RSA 3072-bit key SHA256/HMAC-SHA256 ECDSA NIST P-256 RSA 3072-bit key SHA256/HMAC-SHA256 (Not a recommended configuration)* ECDSA NIST P-384 RSA 3072-bit key SHA384/HMAC-SHA384 Intel \u00ae EPID ECDSA NIST P-256 SHA256/HMAC-SHA256 ECDSA NIST P-256 ECDSA NIST P-256 SHA256/HMAC-SHA256 ECDSA NIST P-384 ECDSA NIST P-256 SHA384/HMAC-SHA384 (Not a recommended configuration)* Intel \u00ae EPID ECDSA NIST P-384 SHA384/HMAC-SHA384 ECDSA NIST P-256 ECDSA NIST P-384 SHA384/HMAC-SHA384 (Not a recommended configuration)* ECDSA NIST P-384 ECDSA NIST P-384 SHA384/HMAC-SHA384 Note on not recommended configurations, above The Ownership Voucher and the Device key in this configuration have different cryptographic strengths. It is recommended that the strongest cryptographic strength always be used, and that the strengths match between Device and Owner.","title":"Hash Types and HMAC Types"},{"location":"protocol-specification/protocol-data-types/#public-key-types","text":"Public keys types are based on IANA DNSSEC codes, see: http://www.iana.org/assignments/dns-sec-alg-numbers/dns-sec-alg-numbers.xhtml The public key length is derived based on the (explicit) length of the storage provided for it. Table 5 - Public Key Number and Associated Algorithm Public Key Number Public Key Algorithm 0 No public key present 1 RSA2048RESTR (RSA with restrictions imposed by legacy TEE environments) 2 DH 3 DSA (not currently used) 4 RSA_UR (Any valid RSA public key) 13 ECDSA P-256 14 ECDSA P-384 90 Intel \u00ae Enhanced Privacy ID (Intel \u00ae EPID) v1.0 91 Intel \u00ae EPID v1.1 92 Intel \u00ae EPID v2.0 113 ECC P-256 key used for ECDH key exchange (this code is not currently used in the protocol) 114 ECC P-384 key used for ECDH key exchange (this code is not currently used in the protocol) Other values Reserved","title":"Public Key Types"},{"location":"protocol-specification/protocol-data-types/#public-key-encodings","text":"The key encoding is listed in the table below. Table 6 - Encoding Number Table Public Key Encoding Encoding Name 0 No public key present 1 X.509 3 RSAMODEXP \u2013 RSA2048RESTR or RSA_UR key with modulus + exponent 4 Intel \u00ae EPID Owner and Server implementations must support all public key encodings, as well as null keys under X.509 encoding.","title":"Public Key Encodings"},{"location":"protocol-specification/protocol-data-types/#rsamodexp-encoding","text":"In the RSAMODEXP encoding, an RSA key is represented by two byte arrays, one for the modulus and one for the exponent. The modulus and exponent are based on the Java* Big Integer encoding, a big-endian, signed, two\u2019s complement representation: Big-endian: most significant byte is first, least significant byte is last. Signed encoding: the modulus and exponent are always positive, but the encoding can handle negative numbers. This means that the most significant bit of the most significant byte (that is, the top bit of byte 0) must match the sign. To accomplish this, an extra most significant byte of 0x00 or 0xff might need to be pre-pended to the number. For example: 32768 = 0x8000 must be represented as three bytes: 0x008000 . Note that this may require removing the first byte transmitted for some crypto packages and key values. Two\u2019s complement: the normal encoding of integers in a computer, where the negative of a number is the complement of the bits (aka: one\u2019s complement), plus one. For example, 32768 is represented as: 0x008000 (as above). Complementing the bits gives 0xff7fff . Adding one gives: 0xff8000 which is -32768. This can be simplified to two bytes: 0x8000 , since the sign bit still correctly identifies the number as negative. For implementation , we are aware of crypto packages that use similar encodings, except that the modulus and exponent are always positive, so no extra sign byte is needed. The above encoding may need to be \u201ctweaked\u201d by removing/adding the extra sign byte to work with such packages. For example, one package requires that the size of the modulus always be the number of bytes which is a power of two (For example, 256 bytes), and the sign byte pushed it over by one (to 257 bytes).","title":"RSAMODEXP Encoding"},{"location":"protocol-specification/protocol-data-types/#signatures","text":"A signature is a JSON* object with 3 tags: \"bo\" -- the body to be signed. The signature body is the entire object associated with the \u201cbo\u201d tag, exclusive of the tag itself. This object is hashed byte-for-byte as transmitted. Note that no spaces or comments are permitted in our subset of JSON*, and that strings are always encapsulated with double quotes. In some implementations, it might be necessary to reconstruct the original JSON* from a parsed version to verify the signature.' \"pk\" -- the public key to apply to the signature. Note, when the Public Key is null, the \u201cpk\u201d tag must still be present with the value \u201cPKNull\u201d (see section \u00a7 ). \"sg\" -- the signature material itself. Signatures may be: RSA sign with PKCS1 v1.5 padding, using SHA-256 hash ECDSA NIST P-256. The signature format uses ASN.1 schema ([12], [13]) encoded with Distinguished Encoding Rules (DER) [14]. RSA sign with PKCS1 v1.5 padding, using SHA-384 hash (future crypto) ECDSA NIST P-384 (future crypto) Intel \u00ae EPID 1.0 signatures. The signature format uses ASN.1 schema ([12], [13]) encoded with Distinguished Encoding Rules (DER) [14] Intel \u00ae EPID 1.1 signatures Intel \u00ae EPID 2.0 signatures Signature generation proceeds as follows: Compute the hash on the body, exactly as you will transmit it. Encrypt the hash using the private key. Include the public key in the signature object, under the \u201cpk\u201d tag. Signature verification proceeds as follows: Compute the hash on the body, exactly as transmitted. Decrypt the signature with the public key, as provided in the \u201cpk\u201d tag. Verify that the decrypted signature matches the hash. The body is a single JSON* item that is terminated by a comma, which in practice is always a JSON* object. Thus, the plain text for the signature will be an object that is inclusive of the brace brackets. Example: {\"bo\":{\"n3\":\"WpTgdZooMD0=\"},\"pk\":[1,3,[257,\"AKgIjL \u2026 257 bytes of b64 ...5nCQRk=\", 3,\"AQAB\"]],\"sg\":[256,\"kuL2 ... 256 bytes of b64 \u2026 Ps/pfw==\"]} The plaintext to be signed is the string: {\"n3\":\"WpTgdZooMD0=\"}","title":"Signatures"},{"location":"protocol-specification/protocol-data-types/#device-attestation-signature-and-mechanism","text":"The Device Attestation signature is used by the Secure Device Onboard Device to prove its authenticity to the Secure Device Onboard Rendezvous and the Secure Device Onboard Owner. Various cryptographic signing mechanisms can be used for this purpose. In this specification, we present mechanisms based on Intel \u00ae Enhanced Privacy Identifier (Intel \u00ae EPID) signatures and Elliptical Curve Digital Signature Algorithm (ECDSA) signatures. In some cases, a signature cannot stand alone, but requires some protocol interaction to prepare for it. For example, a multi-application Trusted Execution Environment (TEE) may need to negotiate program instance parameters with the verifier before the signature can be trusted. In particular, Intel \u00ae EPID signers need to obtain revocation information and cooperatively sign \u201cproofs\u201d. For this reason, the Device Attestation mechanism exchanges the following three messages: eA -- from device to signature verifier, provides initial device based information eB -- from verifier to device, provides a response to eA sg -- from device to verifier, contains the actual signature The eA and eB messages are structured as \u201cSigInfo\u201d, and contain a field that identifies the signature type as defined in Table \u200e3\u20117. Table 7 - Signatures Types Encoding Type Name Type Description 13 ECDSA P-256 ECDSA P-256 signature with SHA-256 hash 14 ECDSA P-384 ECDSA P-384 signature with SHA-384 hash 90 EPID10 Intel \u00ae EPID 1.0 signature information for the Intel Client environment. Sufficient information to generate the Intel Client \u201cEPID provisioning\u201d call. 91 EPID11 Intel \u00ae EPID 1.1 signature information for the Intel Client environment. Sufficient information to generate the Client \u201cEPID provisioning\u201d call. 92 EPID20 Intel \u00ae EPID 2.0 signature information for non-Intel Client implementation.","title":"Device Attestation Signature and Mechanism"},{"location":"protocol-specification/protocol-data-types/#intel-enhanced-privacy-id-intel-epid-signatures-overview","text":"Intel \u00ae Enhanced Privacy ID (Intel \u00ae EPID) signatures are generated by Devices that support a Hardware Root of Trust based on Intel \u00ae EPID 1.0, Intel \u00ae EPID 1.1, or Intel \u00ae EPID 2.0. Intel \u00ae EPID 2.0 is implemented at Intel with both 32-bit and 128-bit group IDs. This specification assumes 128-bit group IDs for Intel \u00ae EPID. Intel \u00ae EPID 32-bit group IDs are supported by extending the 32-bit group ID to 128 bits by zero padding to the left (most significant bits), thus mapping the 32-bit group space into the 128-bit group space. In some cases, the Secure Device Onboard implementation must convert group IDs back and forth for platform software that requires 32-bit group IDs. To our knowledge, platforms where the Intel \u00ae EPID 2.0 software supports only 32-bit group IDs are matched by hardware provisioned with Intel \u00ae EPID keys with 32-bits. The EPID signer needs Intel \u00ae EPID revocation information in order to generate a valid Intel \u00ae EPID signature from an Intel \u00ae EPID private key. In particular, the signer needs the signature revocation list (SIGRL) for its group. The SIGRL may be obtained from Intel\u2019s iKGF web sites, but it is easiest to obtain using the Intel \u00ae EPID Verification Service. In some platforms, Intel \u00ae EPID revocation information is downloaded using other tools. However, for consistency, Secure Device Onboard allows the Device to download this information as part of the TO1 and TO2 Protocols. Intel \u00ae EPID information is encoded in the SigInfo structures eA, eB, and in the pkType and sg fields of the signature itself. Typically eA and eB are in subsequent messages, with the Intel \u00ae EPID signed message coming just afterwards.","title":"Intel\u00ae Enhanced Privacy ID (Intel\u00ae EPID) Signatures Overview"},{"location":"protocol-specification/protocol-data-types/#intel-enhanced-privacy-id-intel-epid-11-signatures-type-epid11","text":"Intel \u00ae EPID 1.1 signature information is encoded using the EPID11 signature type, using the \u201ceA\u201d, \u201ceB\u201d and \u201csg\u201d fields, each from separate messages. The contents of each field is as follows: eA encodes the EPID group ID as 4 bytes, in network byte order (MSB first): Table 8 - eA Encoding, type EPID11 Type Name Description BYTE[4] groupId EPID 1.1 group ID eB encodes the EPID certificate and other items needed by the Intel Client. The SIGRL is inside the group certificate. Length values (UInt16) are encoded in network order (MSB first): Table 9 - eB Encoding, type EPID11 Type Name Description UInt16 groupCertSigma10Size Size of data in groupCertSigma10 field BYTE[] groupCertSigma10 Legacy group certificate (binary format) UInt16 groupCertSigma11Size Size of data in groupCertSigma11 field BYTE[] groupCertSigma11 X.509 group certificate UInt16 sigRLSize Size of data in sigRL field (in bytes) BYTE[] sigRL SigRL as given below If there is no SIGRL, sigRLSize is zero, and sigRL is empty (not present). Note sigRL non-zero implies that n2 > 0 (below). The sigRL format is as follows (all fields are encoded in network order (MSB first)): Table 10 - SigRL Format Type Field Name Description UInt16 sver Intel \u00ae EPID version number. Must be 0x0001 for Intel \u00ae EPID1.1 UInt16 blobID ID of the data type. Must be 0x000e for SigRL UInt32 gid Group ID UInt32 RLver Revocation list version number UInt32 n2 Number of entries in SigRL BYTE[64] (n2 of them) B[i] for i in range [0; n2-1] Bi elements of G3 BYTE[64] (n2 of them) K[i] for i in range [0; n2-1] Ki elements of G3 BYTE[64] sig 512-bit ECDSA signature on the revocation list signed by the issuer using Intel Signing Key (ISK). **Contact Secure Device Onboard Enablement team for details.** sg encodes the signature, according to the Intel \u00ae EPID1.1 specification. The length is given in the message format: Table 11 - sg Encoding, type EPID11 Type Name Description BYTE[] signature Intel \u00ae EPID 1.1 signature according to the Intel \u00ae EPID 1.1 specification The data being signed is: Table 12 - Data Signatures, type EPID11 Type Name Description BYTE[48] Prefix All zeros, except: Prefix[4]=0x48 and Prefix[8]=0x8 BYTE[16] ID App-ID, same as in message body (\u201cai\u201d tag in messages: TO1.ProveToSDO and TO2.ProveDevice) BYTE[16] Zero-padding Zeros BYTE[16] Nonce Nonce value same as in message body (\u201cn4\u201d tag in messages: TO1.ProveToSDO and \u201cn6\u201d tag in TO2.ProveDevice) BYTE[16] Zero-padding Zeros (used to allow Nonce to be 32 bytes) BYTE[] Message body As in this protocol specification, from open to close brace bracket of JSON* text. Rendezvous Service and Owner must (logically) prefix the contents of the message with specific data (as above), before doing Intel \u00ae EPID verification.","title":"Intel\u00ae Enhanced Privacy ID (Intel\u00ae EPID) 1.1 Signatures (type EPID11)"},{"location":"protocol-specification/protocol-data-types/#intel-enhanced-privacy-id-intel-epid-20-signatures-non-intel-client-type-epid20","text":"Intel \u00ae EPID 2.0 signatures are encoded using \u201ceA\u201d, \u201ceB\u201d and the \u201csg\u201d fields, each from separate messages. The contents of each field is as follows: eA encodes the EPID group ID as 16 bytes, in network byte order (MSB first). Hosts which use Intel \u00ae EPID2.0 with 32-bit group IDs must zero pad the top 96 bits. Table 13 - eA Encoding, type EPID20 Type Name Description BYTE[16] groupId Intel \u00ae EPID 2.0 group ID eB encodes the signature revocation list (sigRL) and EPID group public key. Length values (UInt16) are encoded in network order (MSB first): Table 14 - eB Encoding, type EPID20 Type Name Description UInt16 sigRLSize Size of data in sigRL field BYTE[sigRLSize] sigRL SigRL according to Intel \u00ae EPID 2.0 specification UInt16 publicKeySize Size of data in publicKey field BYTE[publicKeySize] publicKey Group public key according to Intel \u00ae EPID 2.0 specification sg encodes the signature, according to the Intel \u00ae EPID 2.0 specification. The length is given in the message format. Table 15 - sg Encoding, type EPID20 Type Name Description BYTE[] signature Intel \u00ae EPID 2.0 signature according to Intel \u00ae EPID 2.0 specification","title":"Intel\u00ae Enhanced Privacy ID (Intel\u00ae EPID) 2.0 Signatures (non-Intel Client, type EPID20)"},{"location":"protocol-specification/protocol-data-types/#intel-enhanced-privacy-id-intel-epid-10-signatures-type-epid10","text":"Intel \u00ae EPID 1.0 signature information is encoded using the EPID10 signature type, using the \u201ceA\u201d, \u201ceB\u201d and \u201csg\u201d fields, each from separate messages. The contents of each field is as follows: eA encodes the EPID group ID as 4 bytes, in network byte order (MSB first): Table 16 - eA Encoding, type EPID10 Type Name Description BYTE[4] groupId Intel \u00ae EPID 1.0 group ID eB encodes the Intel \u00ae EPID certificate and other items needed by the Intel Client. The SIGRL is inside the group certificate. Length values (UInt16) are encoded in network order (MSB first): Table 17 - eB Encoding, type EPID10 Type Name Description UInt16 groupCertSigma10Size Size of data in groupCertSigma10 field BYTE[] groupCertSigma10 Legacy group certificate (binary format) sg encodes the signature, according to the Intel \u00ae EPID 1.0 specification. The length is given in the message format: Table 18 - sg Encoding, type EPID10 Type Name Description BYTE[] Signature Intel \u00ae EPID 1.0 signature according to Intel \u00ae EPID 1.0 specification The data being signed is: Table 19 - Data Signatures, type EPID10 Type Name Description BYTE ID-length Length of ID field BYTE[] ID App-ID, same as in message body (\u201cai\u201d tag in messages: TO1.ProveToSDO and TO2.ProveDevice) BYTE[16] Nonce Nonce value same as in message body (\u201cn4\u201d tag in messages: TO1.ProveToSDO and \u201cn6\u201d tag in TO2.ProveDevice) BYTE[] Message body As in this protocol specification, from open to close brace bracket of JSON text. Rendezvous Service and Owner must (logically) prefix the contents of the message with specific data (as above), before doing Intel \u00ae EPID verification.","title":"Intel\u00ae Enhanced Privacy ID (Intel\u00ae EPID) 1.0 Signatures (type EPID10)"},{"location":"protocol-specification/protocol-data-types/#ecdsa-nist-p-256-and-ecdsa-nist-p-384-signatures","text":"The ECDSA attestation is used for devices where the Intel \u00ae EPID privacy mechanisms are not needed. The Device contains an ECDSA private key, and the Ownership Voucher is enhanced to give the Owner access to the public key. The public key is typically encoded in an X.509 certificate, signed by one or more Certificate Authorities. The private key is used to sign the device attestation. The public key is used to verify the signature. For ECDSA attestation, the Length field in eA and eB encoding is set to 0 and Info field is not present (zero length). ECDSA NIST P-256 uses SHA-256 hash, and ECDSA NIST P-384 uses SHA-384 hash. For ECDSA, both the private key and the public key are Device identities. This means that the Secure Device Onboard Rendezvous Service and Secure Device Onboard Owner who verify the Device attestation signature receive a unique and permanent identity for the device, even before they verify the signature. This information can be used to trace the subsequent owners of the device. For this reason, we recommend careful administrative measures to ensure that this information is used securely and discarded appropriately.","title":"ECDSA NIST P-256 and ECDSA NIST P-384 Signatures"},{"location":"protocol-specification/protocol-data-types/#null-public-keys","text":"A public key in the \u201cpk\u201d tag may be left as null. This is done when the public key is already known to the verifying party, because it is a requirement that it know it, or because it was already transmitted earlier. Intel \u00ae EPID public keys encode only the group number in the \u201cpk\u201d tag, since this is sufficient to identify the public key to the Intel back end. Null public keys are used for some testing stubs.","title":"Null Public Keys"},{"location":"protocol-specification/protocol-data-types/#rendezvousinfo","text":"The RendezvousInfo type indicates the manner and order in which the Device and Owner find the Rendezvous Server. It is configured during manufacturing (For example, at an ODM), so the manufacturing entity has the choice of which Rendezvous Server to use and how to access it. RendezvousInfo consists of a sequence of rendezvous instructions which are interpreted in order during the TO0 and TO1 Protocols (JSON* sequence of object, such as [{t1:v1,\u2026},\u2026,{tn,\u2026}]). The tags are encoded in alphabetical/character encoding order. Unlike other Secure Device Onboard JSON* objects, JSON* tags appear only for instructions that differ from the default. Other variables assume default values. A default value of \u201cnone\u201d indicates that the variable is assumed not present in the instruction unless its tag appears explicitly. Each set of rendezvous instructions (that is, each element of the JSON* sequence) is interpreted as one set of instructions for reaching the Rendezvous Server, with differing conditions. For example, one set might indicate using the wireless interface, and another set might indicate using the wired interface. It is possible that a given set corresponds to multiple ways to access the Rendezvous Server (For example, multiple IP addresses that correspond to a single DNS name), and these must all be tried before the Device or Owner moves to the next element of the sequence. The Owner and Device process the RendezvousInfo, attempting to access the Rendezvous Server. The first successful connection may be used. The Device and Owner may avoid obviously redundant operations, such as contacting the same IP address twice when a DNS name maps to an IP address explicit in a separate rendezvous instruction. To execute each rendezvous instruction, the program defines a set of variables, one for each JSON* tag in the RendezvousInfo instructions. It initializes all variables to default values. Then the rendezvous instruction is interpreted, and updates each variable. If the user input variable is set to true, and user input is available, the user is allowed to update each variable. On constrained devices, some variables do not exist. The constrained implementation interprets each instruction as if this variable was not present. Some variables apply only to the Owner and some only to the Device. See the table below. When a variable does not apply, it is interpreted as if it had never been specified. This means that the Owner can only ever notice the tags: \u201conly\u201d, \u201cip\u201d, \u201cpow\u201d, \u201cdelaysec\u201d, and \u201cdn\u201d. This is because the Owner, as a cloud-based server, is expected to use normal Internet rules to access the Rendezvous Service. The Device, which may be in a specialized network and may be constrained, might need additional parameters. The \u201conly\u201d (Only for) and \"delaysec\" tags have side effects. When \"only\":\"dev\" appears in a set of instructions, an Owner must skip the entire set When \"only\":\"owner\" appears in a set of instructions, a Device must skip the entire set When \"delay\":UInt32 appears in a set of instructions, the set is followed by a delay for the number of seconds specified, increased or decreased by a random value up to 25%. An instruction that contains just a \u201cdelay\u201d, can be appended to the end of the RendezvousInfo to force a particular randomized delay before retrying the entire sequence. Table 20 - RendezvousInfo Variables Rendezvous Instruction Variable Default Value Variable Encoding Tag Variable Type Required Device Owner Only for None \"only\" \"dev\" or \"owner\" No Yes Yes IP address None \"ip\" IPAddress Yes Yes Yes Port, Device Based on protocol \"po\" UInt16 Yes Yes No Port, Owner Based on protocol \u201cpow\u201d UInt16 No No Yes DNS name None \"dn\" String Yes Yes Yes TLS Server cert hash None \"sch\" Hash No Yes No TLS CA cert hash None \"cch\" Hash No Yes No User input No \"ui\" UInt8 (0/1) No Yes No SSID None \"ss\" String If has Wi-Fi* Yes No Wireless Password None \"pw\" String If has Wi-Fi* Yes No Wireless Security Password Chosen Automatically \"wsp\" String If has Wi-Fi* Yes No Medium *Device dependent* \"me\" String Yes Yes No Protocol TLS \"pr\" String No Yes No Delay 0 \u201cdelaysec\u201d UInt32 Yes Yes Yes Rendezvous Instruction (RendezvousInstr) entries are specified as having the variables in alphabetical order. This does not affect the interpretation of these variables, but makes the computation of a signature that includes them simpler for some implementations. If the \u201conly\u201d element appears, and the value does not match the interpreting entity (Device/Owner), this instruction is terminated and control proceeds with the next set of instructions. Medium is selected (\u201cme\u201d). The Device uses the selected preferred medium, or terminates this instruction. When no medium is specified, the Device may establish its own preference, perhaps based on the other parameters (for example, TLS might be available on one medium, but not another). The protocol is chosen (\u201cpr\u201d), if it is supported. Otherwise, the instruction terminates. The Owner always chooses the protocol \u201chttps\u201d. The Device attempts to resolve the DNS address. If DNS query is successful, then the resolved IP addresses are tried one after another. Else, if DNS resolution fails or the Device fails to communicate with all of the resolved IP addresses, then the specified IP address is used as the target IP address. Else, the instruction terminates. If TLS is used on a Device (pr=https or pr=tls), the hash instructions are used as specified against server certificates appearing in the TLS handshake (or, for ps=https, the underlying TLS connection\u2019s handshake). This applies to the Device only. If the server certificate hash is specified (on a Device), the server\u2019s certificate is extracted from the certificate chain, SHA256 hash computed, and compared to the specified value. Failure to match causes the TLS authentication to fail. If the CA certificate hash is specified (on a Device), the other certificates in the server certificate chain are extracted one by one, SHA256 hash computed, and compared to the specified value. Any match allows TLS authentication to proceed. No match causes TLS authentication to fail. The Owner always applies usual CA trust to server certificates used in TLS for the TO0 Protocol. Attempt as many connections as are implied by the set of variables established and choices made, above. For example, try each of the addresses returned by a DNS query if there is a valid DNS name. If a \u201cdelaysec\u201d tag appears, delay as specified. If \u201cdelaysec\u201d does not appear and the last entry in RendezvousInfo has been processed, a delay of 120s \u00b1 random(30) is executed. Medium values: \"eth0\"..\"eth9\" mapped to first through 10th wired Ethernet interfaces. These interfaces may appear with different names in a given platform. \"eth\\*\" means to try as many wired interfaces as makes sense for this platform, in any order. For example, a device which has one or more wired interfaces that are configured to access the Internet (For example, \u201cwan0\u201d) might use this configuration to try any of them that has Ethernet link. \"wifi0\" .. \"wifi9\" mapped to first through 10th Wi-Fi* interfaces. These interfaces may appear with different names in a given platform. \"wifi\\*\" means to try as many Wi-Fi* interfaces as makes sense for this platform, in any order *Others* *device dependent.* Protocol Values: \"rest\": first supported protocol from: HTTPS HTTP CoAP/TCP \"tcp\": bare TCP, if supported \"tls\": bare TLS, if supported \"CoAP/tcp\": CoAP protocol over tcp, if supported \"http\": HTTP over TCP \"https\": HTTP over TLS, if supported","title":"RendezvousInfo"},{"location":"protocol-specification/protocol-data-types/#example-of-rendezvousinfo-different-ports-for-device-and-owner","text":"\u2026\"r\":[1,{\"dn\":\"mpservice.net\",\"po\":80,\"pow\":443}]\u2026 On both Device (TO1 Protocol) and Owner (TO0 Protocol), attempt to connect to all IP addresses returned by the DNS query for \u201cmpservice.net\u201d. The Owner queries TO0 Protocol on port 443 (Owner always uses TLS). The Device queries TO1 Protocol on port 80 (might be HTTP or HTTPS, or both, depending on the device default). In the following situation, the Device needs to try Wi-Fi* media, as many as it can connect to. The Owner just uses the DNS name without the Wi-Fi* media specification, because \u201cme\u201d applies only to Devices, and is thus ignored by the Owner. [1,{\"me\":\"wifi\\*\",\"dn\":\"mpservice.net\"}] The above is thus equivalent to: [2,[3, {\"only\":\"dev\",\"me\":\"wifi\\*\",\"dn\":\"mpservice.net\"}], [2{\"only\":\"owner\",\"dn\":\"mpservice.net\"}]] (Inserted newline for formatting purposes) In the above, \u201ceth \u201d could be used for wired interfaces that are purposed for Internet access, such as the outside* wired interface on a gateway or router.","title":"Example of RendezvousInfo: Different Ports for Device and Owner"},{"location":"protocol-specification/protocol-data-types/#serviceinfo-and-management-service-agent-interactions","text":"The ServiceInfo type is a collection of key-value pairs which allows an interaction between the Management Service (on the cloud side) and Management Agent functions (on the device side), using the Secure Device Onboard encrypted channel as a transport. Conceptually, each key-value pair is a message between a module in the Owner and a module on the Device that implements some primitive function. Messages have a name and a value. The ServiceInfo key is the module name and the message name, separated by a colon. ServiceInfo is constrained to a subset of printable ASCII, but base64 or other encoding may be used to encode any textual or binary formats. ServiceInfo Key ServiceInfo Value moduleName:messageName where both moduleName and messageName are printable ASCII characters containing no Unicode escapes (\\uXXXX) or the characters: {}[]&\"\\ (see Table 1 in section \u00a7 ). Where appropriate, the moduleName may contain a version of the module. By convention, the version is separated using a hyphen character (\u2018-\u2018), as in: tpm-1.2 or tpm-2. Printable ASCII characters containing no Unicode escapes (\\uXXXX) or the characters: {}[]&\"\\ (see Table 1 in section \u00a7 ) Individual or lists of Numbers and selectors (enum type strings) may be expressed directly in ASCII. Textual and binary data should be encoded in base64. Other encodings are permissible on a module-by-module basis, with the above limits. Messages sent to a module on the Secure Device Onboard Device may interact with the Device OS to install software components. Another message might use those components in combination with a cryptographic key, to establish communications. In some systems, the Management Agent might be installed by cooperating modules before it is active by others, allowing an \u201coff-the-shelf\u201d device to be customized by Secure Device Onboard. The intention is that modules will implement common or standardized IOT provisioning functions, and will be reused for different IOT solutions provisioned by Secure Device Onboard. In some cases, modules on the Secure Device Onboard Owner and Secure Device Onboard Device will be designed to cooperate directly with each other. For example, a module that implements a particular device management client on the Secure Device Onboard Device, and its counterpart that feeds it exactly the right credentials on the Secure Device Onboard Owner. In other cases, modules may implement IOT or OS primitives so that the Secure Device Onboard Owner or Secure Device Onboard Device picks and chooses among them. For example, allocating a key pair on the Secure Device Onboard Device; signing a certificate on the Secure Device Onboard Owner; transferring a file into the OS; upgrading software; and so on. The following set of examples is presented for illustrative purposes, and is not intended to constrain Secure Device Onboard implementations in any way: Example Key Example Value Comment firmware_update:active 1 Hypothetical firmware update module, sends \u201cactive\u201d message with value of 1 (true) firmware_update:codeSize 262144 Code size is 256k firmware_update:code001 Base64 data First 512 bytes of firmware update, encoded in base64 firmware_update:verify Base64 data SHA-384 of firmware image wget:hashSha384 Base64 data SHA-384 hash of data that is downloaded in the next message wget:CAfiles.dat http://myserver/CAfiles.dat Download CA database cmd-linux:\\#!/bin/sh exec /usr/local/bin/mydaemon -k mykeyfile.pkcs7 -ca CAfiles.dat Hypothetical module to execute Linux* scripting commands, message name gives interpreter, value gives shell code The API between the Management Agent / Device OS and the Secure Device Onboard Device, and between the Management Service and the Secure Device Onboard Owner, are outside the scope of this document. The requirements for this API are as follows: A mechanism to discover modules on the Secure Device Onboard Owner and to establish a preference among them (analogous to a preference for TPM2 over TPM1.2) A mechanism to connect modules on the Secure Device Onboard Device. A complex Secure Device Onboard Device might be able to discover modules, but a simpler device could have modules \u201chard\u201d coded A mechanism to generate Secure Device Onboard messages to modules. As above, modules can send messages to their counterparts or to other modules On constrained Secure Device Onboard Devices, common code for performing base64 decoding is desirable. Common code for modules to store and buffer state from messages is desirable. On complex Secure Device Onboard Devices, the ability of modules to send messages to each other may also be supported. For example, a file transfer module and a file storage module might be called as primitives for a \u201cfile transfer and store\u201d module. One special case of the above. We envision a \u201cTEE\u201d module, that encapsulates messages for other modules, but causes an error unless these modules are implemented at the same security level as the Secure Device Onboard implementation (For example, in the same Trusted Execution Environment). For example, TEE:tpm:createkey causes an error if the module called \u201ctpm\u201d is not at the same security level as Secure Device Onboard. This module might encrypt data to ensure that it can only be processed in a trusted environment. Implementations which support multiple security levels for code execution should allow for this function, since this capability cannot be simulated using other Secure Device Onboard mechanisms. Management Service - Agent Interactions via ServiceInfo","title":"ServiceInfo and Management Service \u2013 Agent Interactions"},{"location":"protocol-specification/protocol-data-types/#mapping-messages-to-serviceinfo","text":"A module may have an arbitrary number of messages. There are no arrays, but numbered message names can be used to simulate their effect (mod:key1, mod:key2). Since ServiceInfo messages are separated into one or more Secure Device Onboard messages, it is possible to use the same message over and over again. Whether this is has a cumulative or repetitive effect is up to the module that interprets the messages (For example, file:part might be repeated for successive parts, but tpm:certificate might be individual certificates). Messages are processed in the order they appear in ServiceInfo. The same message may also be repeated in a single ServiceInfo. ServiceInfo does not have to be interpreted as it is parsed from the message. It is legal to buffer the entire ServiceInfo and interpret it all later. However, the messages must be interpreted in the same order.","title":"Mapping Messages to ServiceInfo"},{"location":"protocol-specification/protocol-data-types/#the-sdo-device-module","text":"The \u201csdodev\u201d module implements a set of messages to the Secure Device Onboard Owner that identify the capabilities of the device. All Secure Device Onboard Owners must implement this module, and Secure Device Onboard Owner implementations must provide these messages to any module asks for them. The \u201csdodev\u201d messages must appear first in the Device ServiceInfo. The following messages are defined in the SDO Device Module: Table 21 - sdodev Module Device Service Info Keys Device Service Info Key Disposition Meaning / Action sdodev:os Required OS name (For example, Linux*) sdodev:arch Required Architecture name / instruction set (For example, X86_64) sdodev:version Required Version of OS (For example, \u201cUbuntu* 16.0.4LTS\u201d) sdodev:device Required Model specifier for this Secure Device Onboard Device, manufacturer specific sdodev:sn Optional Serial number for this Secure Device Onboard Device, manufacturer specific sdodev:pathsep Optional Filename path separator, between the directory and sub-directory (For example, \u2018/\u2019 or \u2018\\\u2019) sdodev:sep Required Filename separator, that works to make lists of file names (For example, \u2018:\u2019 or \u2018;\u2019) sdodev:nl Optional Newline sequence (For example, \u201c\\u000a\u201d or \u201c\\u000d\\u000a\u201d) sdodev:tmp Optional Location of temporary directory, including terminating file separator (For example, \u201c/tmp\u201d) sdodev:dir Optional Location of suggested installation directory, including terminating file separator (For example, \u201c.\u201d or \u201c/home/sdo\u201d or \u201cc:\\Program Files\\SDO\u201d) sdodev:progenv Optional Programming environment. See Table \u200e22 (For example, \u201cbin:java:py3:py2\u201d) sdodev:bin Required Either the same value as \u201carch\u201d, or a list of machine formats that can be interpreted by this device, in preference order, separated by the \u201csep\u201d value (For example, \u201cx86:X86_64\u201d) sdodev:mudurl Optional URL for the Manufacturer Usage Description file that relates to this device (See CR023) sdodev:modules Optional A list of module names supported by this Secure Device Onboard Device, separated by the separator specified in \u201csdodev:sep\u201d The \u201cprogenv\u201d key-value is used to indicate the Device\u2019 capabilities for running programs. This is a list of tags, separated by the \u201csep\u201d value, that indicates which programming environments are available and preferred on this platform. For example, bin;perl;cmd means use system binary format (preferred), but Perl* is also supported, and Windows* CMD shell is also supported, but Perl* is preferred over CMD. The following tags are supported at present. Version numbers may be appended to the tag (as in py2 and py3). Table 22 - sdodev Module \"progenv\" Key Tags \u201cprogenv\u201d tag Meaning bin System-dependent most common binary format (the \u201carch\u201d key-value may inform the format) java Java* class/jar (openJDK* compatible) js Node.js* (Javascript*) py2 Python* version 2 py3 Python* version 3 perl* Perl* 5 bash Bourne shell ksh KornShell* sh *NIX system shell (whichever one it is) cmd Windows* CMD psh Windows PowerShell* vbs Windows Visual Basic* Script \u2026 (Other specifiers may be defined on request. Contact the Secure Device Onboard Enablement team)","title":"The SDO Device Module"},{"location":"protocol-specification/protocol-data-types/#module-selection","text":"In some Secure Device Onboard implementations, multiple modules can perform overlapping functions. Some modules may implement legacy versions of others (For example, TPM versions) and some modules may implement alternative IOT control techniques (For example, MQTT versus CoAP). The Secure Device Onboard Owner and Secure Device Onboard Device need to negotiate to select the right set of modules. In this version of Secure Device Onboard, module selection is as follows: The [TO2.GetNextDeviceServiceInfo.psi] variable lists modules supported by the Secure Device Onboard Owner in order of Owner preference. The [Device ServiceInfo] indicates which modules are selected by including an \u201cactive\u201d message and provides device-side data for the modules from the Management Agent. The [Owner ServiceInfo] may deselect modules with its own \u201cactive\u201d messages, and provides messages containing owner-side data from the Management Service. If possible, all module functions should complete in time to allow the Secure Device Onboard operation to succeed or fail based on module operation, so that a module failure causes the entire Secure Device Onboard operation to fail and be retried later. In some cases, the module cannot determine success criteria before Secure Device Onboard completes (For example, a firmware update module must restart the system to invoke the new software), and Secure Device Onboard must complete \u201con faith\u201d that all is well. Any error in a module must cause the entire Secure Device Onboard session to fail with an error message.","title":"Module Selection"},{"location":"protocol-specification/protocol-data-types/#module-selection-using-the-pre-serviceinfo-psi-variable11","text":"The \u201cPre-ServiceInfo\u201d variable: TO2.GetNextDeviceServiceInfo.psi is a string that starts the ServiceInfo handshake. The Psi variable encodes a mini-ServiceInfo. The format of the \u201cpsi\u201d variable is: modName1 : modMsg1 \\~ modVal1 , modName2 : modMsg2 \\~ modVal2 \u2026 This is a comma-list of module-message-value triplets, where the module name is delimited with a colon (\u2018:\u2019), and the message is delimited from the value with a tilde (\u2018\\~\u2019). The moduleData is used when the Secure Device Onboard Device must perform specific Owner-driven operations before the Device ServiceInfo. For example, a TPM module might need the number of key pairs to allocate. The purpose of the Pre-ServiceInfo (PSI) variable is to allow the Secure Device Onboard Owner to require specific action from the Secure Device Onboard Device before it sends the Device ServiceInfo. This might be required, for example, if the Secure Device Onboard Owner needed the Secure Device Onboard Device to allocate a specific number of keys or other resources, then offer them to the Secure Device Onboard Owner. This choice might imply a preference from the Owner to the Device as well. If the Secure Device Onboard Owner has no such requirement, it need not generate the Pre-ServiceInfo. For example, a constrained Secure Device Onboard Device may always generate the same Device ServiceInfo. In this case, the Pre-ServiceInfo has no function. Module information in the PSI may be used to indicate a preference for one module over another. For example, the Secure Device Onboard Owner may indicate that a TPM2 module is preferred over a TPM1.2 module, even if both are supported by the Owner and the Device. Consider the following psi variable: tpm-1.2:pref\\~tpm-2;tpm-2:keys\\~3,tpm-2:type\\~ecc, tpm-1.2:keys\\~3,tpm-1.2:type\\~rsa This might indicate support for: a tpm module at version 2 that has an argument indicating 3 RSA key-pairs are needed, the same module at version 1.2 also needing 3 key-pairs (but ECC); and a preference for module tpm-2 over tpm-1.2 (the \u201cpref\u201d message). Following this example, an Secure Device Onboard Device that supports TPM 1.2 can enable the appropriate module and allocate 3 RSA key pairs, and another Secure Device Onboard Device with both TPM 1.2 and TPM 2.0 capability can select TPM 2.0 and allocate 3 ECC key pairs. In each case, the Device ServiceInfo is used to activate a particular module. Constrained Secure Device Onboard implementations do not need to parse Pre-ServiceInfo, unless they need to access moduleData. Specifically, a constrained Secure Device Onboard Device that always allocates one key pair does not need to scan the \u201cpsi\u201d variable.","title":"Module Selection Using the Pre-ServiceInfo (PSI) Variable11"},{"location":"protocol-specification/protocol-data-types/#module-activation-in-device-serviceinfo","text":"A module on the Secure Device Onboard Device indicates its availability to the Secure Device Onboard Owner by sending the active message with value 1 (true): In Device ServiceInfo: \u2026 \" modName :active \":\" 1 \", \u2026 The active message must precede all other messages sent by a given module. An Secure Device Onboard Owner may only send messages to a module that has sent an active message. Messages to non-existent or non-activated modules cause the Secure Device Onboard session to be terminated with an error message. An Secure Device Onboard Owner may refuse the activation of a module by sending a de-activating active message: In Owner ServiceInfo: \u2026 \" modName :active \":\" 0 \", \u2026 If the Secure Device Onboard Owner sends a de-activate message, it may not send any other messages to this module in this Secure Device Onboard session. The Secure Device Onboard Owner must de-activate all modules that it does not intend to use. For example, a constrained Secure Device Onboard Device may implement a management module and a firmware update module. It activates both modules, sending the current firmware version as a parameter of firmware update. The Secure Device Onboard Owner can decide either to accept this version of firmware and de-activate the firmware update module, or decide to update the firmware and de-activate the management module.","title":"Module Activation in Device ServiceInfo"},{"location":"protocol-specification/protocol-data-types/#secure-device-onboard-version-10-key-values","text":"Version 1.0 of Secure Device Onboard implemented a different set of key-value pairs. We have elected to replace this mechanism with the current one. Implementers who need to support the previous Device- and Owner-ServiceInfo key-value pairs should contact the Secure Device Onboard Enablement team at Intel.","title":"Secure Device Onboard Version 1.0 Key-Values"},{"location":"protocol-specification/protocol-data-types/#examples","text":"In the following examples, spaces are provided for clarity, and fragments of ServiceInfo are presented.","title":"Examples"},{"location":"protocol-specification/protocol-data-types/#expressing-values-in-different-encodings","text":"\u2026 \"mymod:options\",\"foo,bar\"\u2026 \u2026 \"mymod:options\",\"Zm9v,YmFy\" \u2026 \u2026 \"mymod:options\",\"Zm9vLGJhcg==\" \u2026 These 3 example each defines a message \u201coptions\u201d with value \u201cfoo,bar\u201d. The first gives the value in printable ASCII, the second in a list of base64 values, the third as a list completely encoded in base64. Which value is correct depends on the implementation of \u201cmymod\u201d.","title":"Expressing Values in Different Encodings"},{"location":"protocol-specification/protocol-data-types/#hypothetical-file-transfer-owner-serviceinfo","text":"\"binaryfile:name\",\"myfile.tmp\", \"binaryfile:length\",\"1234\", \"binaryfile:data001\",\"\u2014 base64-data-512-bytes \u2014\", \"binaryfile:data002\",\"\u2014 base64-data \u2014 512-bytes \u2014\", \"binaryfile:data003\",\"\u2014 base64-data-210-bytes \u2014\", \"binaryfile:sha-384\",\"\u2014 base64-data \u2014 48-bytes \u2014\" In this example, a \u201cbinary file\u201d module allows a file to be downloaded using the Secure Device Onboard secure channel. The data002 and data003 variables need to be in separate ServiceInfo messages to keep message sizes within spec. Base64 encoding is used to allow the module to generate a binary file. The last message allows the file transfer to be verified after it is stored in the filesystem, as an added integrity check. Another way to accomplish file transfer would be to use an external HTTP connection. For example: \"wget:filename\":\"myfile.tmp\", \"wget:url\":\"http://myhost/myfile.tmp\", \"wget:sha-384\":\"\u2014 base64-data \u2014 48-bytes \u2014\" In this case, the file is transferred using a separate connection, perhaps at OS level. If the file is confidential, \u2018https:\u2019 could be used instead of \u2018http:\u2019. Both these techniques are valid in Secure Device Onboard, and represent two sides of a trade-off. Using the Secure Device Onboard channel, a small file can be transferred without needing a parallel network connection (see section \u00a7 for limitations on the Secure Device Onboard channel size). However, the same file might be transferred much faster using an optimized HTTP implementation, and might not require the confidentiality built into Secure Device Onboard (For example, the file contents might be posted on a public Internet site). Table \u200e23 discusses the trade-off. Secure Device Onboard is tuned to provide access to the Secure Device Onboard server using HTTP or HTTPS. Since Secure Device Onboard may run in a proxy environment created by the Secure Device Onboard Installer Tool (see section \u00a7 ), other protocols should be used only when both the Secure Device Onboard Device, Secure Device Onboard Owner and the installation network are known to support them. Otherwise, stick with HTTP/HTTPS. Table 23 - Comparison of Transferring a File Using Secure Device Onboard Channel or Independent Channel File Transfer Using Secure Device Onboard Channel File Transfer Using HTTP Mechanism Performance based on Secure Device Onboard protocol (slow for file large data) Performance based on HTTP or HTTPS, designed for streaming large amounts of data. Second stream required. Can download large amounts of bulk data or programs (limited to the number of ServiceInfo iterations) Can download arbitrary amounts of bulk data or programs Data can be stored in a file Data can be stored in a file Data can be executed as a program Data can be executed as a program Data is encrypted using Secure Device Onboard channel Data is encrypted only if HTTPS is used. Data is verified using Secure Device Onboard channel Data can verified by the module if a hash of contents (For example, SHA-384) is included","title":"Hypothetical File transfer (Owner ServiceInfo)"},{"location":"protocol-specification/protocol-data-types/#hypothetical-direct-code-execution","text":"\"code:architecture\",\"x86_64\", \"code:length\":\"512\", \"code:machinecode001\",\"\u2014 base64-data-512-bytes \u2014\", In this example, a module permits loading and executing machine code (this might be needed on a MCU). Obviously, this requires a high degree of trust in the Secure Device Onboard implementation, and perhaps an ability to execute code in a sandbox.","title":"Hypothetical Direct Code Execution"},{"location":"protocol-specification/protocol-data-types/#implementation-notes","text":"This section is not logically part of the Secure Device Onboard specification. An Secure Device Onboard implementation may implement ServiceInfo in a variety of ways. It is recommended that Secure Device Onboard implementations create a ServiceInfo interface on both Device and Owner side, that allows an easy plug-in mechanism. On the Owner side, a dynamic plug-in mechanism may by easier to maintain. On the Device side, a statically linked or compiled mechanism may be required due to system constraints. However, a more capable Device that runs Linux OS might be able to implement a flexible scripted mechanism similar to init.d . As stated above, constrained Devices do not need to implement pre-ServiceInfo, unless they actually present choices of module, or except if they need to scan for a modData parameter. In a given implementation it is possible to process the ServiceInfo variables as they arrive or in a batch. However, the order of interpretation of messages must be preserved. To illustrate this, consider the following Python* script: import base64 s='abcdefghijklmnop' for n in range(0,5): print n, (((n+2)/3)*4), s[0:n], base64.encodestring(s[0:n]), Output is: 0 0 1 4 a YQ== 2 4 ab YWI= 3 4 abc YWJj 4 8 abcd YWJjZA== 5 8 abcde YWJjZGU= \u21a9 It is conceivable to specify a compressed data format, then define that it is encoded in a ByteArray. We do not currently have such a case in this document. \u21a9 Stream Message - Only the Message Body is transmitted for REST protocols. \u21a9 If pkBytes=0, then key is null. Please see section \u200e \u00a7 : Signatures. \u21a9 For more information, please see section \u200e \u00a7 : Public Key Types. \u21a9 For more information, please see section \u200e \u00a7 : RendezvousInfo. \u21a9 For more information, please see section \u00a7 : Key Exchange in the TO2 Protocol. Please see section \u00a7 : Data Transmission for more information. \u21a9 For more information, please see section \u200e \u00a7 : Public Key Encodings. \u21a9 For more information, please see section \u00a7 : RendezvousInfo. \u21a9 For more information, please see section \u200e \u00a7 : EPID 1.1 Signatures. \u21a9 We intend to replace the PreServiceInfo variable with a more general mechanism in future versions of Secure Device Onboard. \u21a9","title":"Implementation Notes"},{"location":"protocol-specification/protocol-description/","text":"Protocol Description \u00b6 Secure Device Onboard protocols pass JavaScript* Object Notation (JSON)-based messages between cooperating entities, which are listed in subsequent sections. The messages are defined independent of any transport protocol, permitting Secure Device Onboard to operate over multiple transport protocols with different properties, such as: RESTful HTTP/HTTPS (Current implementation of Secure Device Onboard) Constrained Application Protocol (CoAP) [[RFC7252]] TCP or TCP/TLS streams Non-Internet protocols, such as Bluetooth \u00ae specification or USB* specification Secure Device Onboard messages are encoded using a distinguished encoding of JSON*, and are intended to fit in the RESTful ecosystem. The encoding is read-compatible with JSON*, so that JSON* decoders and JSON* pretty-printers will work well with Secure Device Onboard messages. However, standard JSON* components may need to have their output adjusted to conform to this encoding. Signatures refer to the transmitted form of a message, so a standard JSON* parser may have reason to keep the original JSON* text around for verifying signatures. Other encodings of JSON* exist, and might be used with Secure Device Onboard in the future, such as the Concise Binary Object Representation (CBOR) encoding described in [[RFC7049]]. Message Passing Protocol \u00b6 Secure Device Onboard messages are defined in section \u00a7 . A message is logically encapsulated by a protocol-dependent header containing the message type, protocol version, and other transmission-dependent characteristics, such as the message URL and message length in bytes. The message header is transmitted differently for different transport protocols. For example, the message header may be encoded into the HTTP header fields for RESTful protocols. The message body is a JSON* object, encoded within the JSON* distinguished encoding, described in section \u00a7 : JSON* Distinguished Encoding. JSON* Distinguished Encoding \u00b6 The JSON* specification only describes a textual form of JSON*. Any time JSON* is transmitted, it must be encoded into a particular character set, bit order, and others. Secure Device Onboard uses a restrictive encoding for JSON* to make it easier for a constrained device to quickly and efficiently parse messages. We believe that this restricted encoding permits parsers with similar code size to parsing binary message formats. Since the encoding preserves many of the JSON* textual properties, standard JSON* components may also be used when available (for example, in non-constrained environments). However, the output of these components must be re-encoded before messages are transmitted to ensure compatibility with the distinguished encoding. The following table describes how JSON* is encoded into the JSON* distinguished encoding. Table 1 - JSON* Distinguished Encoding Encoding Rule Motivation Each message is a valid JSON* object Secure Device Onboard ecosystem can interpret message Messages are encoded only in printable ASCII (codes 0x20-0x7e). Non-ASCII characters in strings are encoded as Unicode: \\uXXXX (or \\uXXXX\\uYYYY for 32-bit Unicode) Simplicity of interpreter. Special characters: {}[]&\"\\ must be encoded as Unicode \\u\u2026 sequences when they appear in strings. Backslash escaping is not used. Simplicity of interpreter. Objects are stored in a distinguished order, as defined in this document. The object elements may not be reordered. Permits receiver to verify signatures without needing to sort the message\u2019 object tags; receiver can check expected object tags rather than parsing. No whitespace, newlines, carriage returns or tabs are permitted as padding. Spaces and tabs are permitted in JSON strings where not otherwise restricted. Simplicity of interpreter, verification of signatures. No JSON* comments are permitted. Simplifies verification of signatures. Object tags are chosen for brevity Decreases message size, important for constrained systems. When the same value appears multiple times in the Secure Device Onboard protocols, we use an object tag containing the object type and an integer giving the instance the object is used within this specification. For example, Nonces are tagged as \u201cn1\u201d, \u201cn2\u201d, and so on. Byte arrays (ByteArray) are stored as strings containing base64 data; the message structure gives a length field preceding the string to make parsing memory efficient. Decreases message size. Only positive integers are encoded; each integer is encoded in the shortest possible decimal representation (For example, \u201c01\u201d or \u201c0x33\u201d are not permitted). Negative integers and floating point numbers are not encoded. Simplicity of parser, compactness of representation, ability to sign messages. True is encoded as the number 1 False is encoded as the number 0 Simplicity of parser When messages are signed, hashed, or HMAC\u2019d the distinguished encoding of the message is used. Since this coding can only have one form for any message value (i.e., it is distinguished), this can be done directly on the encoded text. Conventional JSON* decoders might find it convenient to keep pointers into the original message text of a message for these operations, since their operation might introduce or remove parts of the plaintext. Note The message and data type descriptions in this document use JSON with comments and white space. This is for clarity only. JSON comments and white space are never transmitted. In protocol implementations, JSON* is usually parsed into a parse tree by a general purpose parser, then the protocol implementation reads the parsed data to verify all message components are there. Because of the distinguished encoding, JSON* messages can be parsed by code that is intended to recognize the expected message, data type, or object tag. For example, code to parse an object: {\"s1\":\"hello\",\"n\":25,\"b\":[4,\"KlMyRg==\"]} can recognize the object using straight line code as follows: Allocate variables s1, n, b[], bsize Verify begin object { Verify tag \u201cs1\u201d, then a string, then a comma Let s1 = string that is read Verify tag \u201cn\u201d, then a number, then a comma Let n = number that is read Verify tag \u201cb\u201d then a sequence. Let bsize = the first element of the sequence, then decode the base64 string into an array of bsize bytes (yielding 0x2a, 0x53, 0x2a, 0x66). Verify end object } Although this seems laborious on paper, it results in very small and efficient code that can be debugged easily. In addition, the distinguished subset removes the need for complex object escaping, such as embedding a double quote in a string (\"a \\\"b\\\" c\" must be encoded as: \"a \\u0022b\\u0022 c\"). POST body encoding and decoding is also avoided, as well as UTF escaping. This burden is placed instead on the client protocol. However, we do not believe this is a high burden for a Device implementation. Protocol Entities \u00b6 See Figure \u200e1. Secure Device Onboard Entities and Entity Interconnection for a diagram of Secure Device Onboard Entities and their protocol interconnections. Manufacturer (Mfg) : This is an Secure Device Onboard application running in the factory, which implements the initial communications with the Device TEE, as part of the Device Initialize Protocol (DI). Device : The device being manufactured, later the device being provisioned. This device has hardware and software configured on it, including a Device TEE and a Device to Manager Agent. In the following documentation, an Secure Device Onboard enabled Device is capitalized. Device TEE : The Trusted Execution Environment within the Device. In some Devices, this is a co-processor [For example Intel \u00ae Management Engine (Intel \u00ae ME)] or a special processor mode [For example, Intel \u00ae Software Guard Extensions (Intel \u00ae SGX)] that enables a small kernel of code to run, with credentials to prove its authenticity. Many Intel devices implement an Intel \u00ae DAL to allow new (signed) applications to be added to the Management Engine. Device TEE App : This is the application that is installed in the TEE of the device to provide the Secure Device Onboard capabilities on the device. When we informally refer to the Device TEE as an endpoint to a protocol, we always mean the Device TEE App. Device to Manager Agent : Software that runs on the device in normal operation that connects the device to its manager across the network. This entity\u2019s function is specific to the Manager, and outside the scope of this document, except for its first connection to the Manager. Our intention is that the Device to Manager Agent matches as closely as possible the existing agents that connection devices to remote network or cloud managers. Owner : This is an entity that is able to prove ownership to the Device using an Ownership Voucher and a private key for the last entry of the Ownership Voucher (the \u201cOwner Key\u201d). Various members of the supply chain may have bought and sold the device while it was still \u201cboxed,\u201d acting as owners, but without powering on the device. The final owner in the chain uses the Owner Client to provision the device, and then controls it across a network using a Manager. Manager : The entity that manages devices across a network. This can range from an application on a user\u2019s computer, phone or tablet, to an enterprise server, to a cloud service spanning multiple geographic regions. The Manager interacts with the device using the Device to Manager Agent . Commonly, the Manager is an existing management system or cloud management service that is provisioned using Secure Device Onboard, so that it operates the same as if it were manually provisioned. In some cases, the owner elects to subscribe to a cloud service and proxy his ownership, so that the Manager controls the ownership credentials of the owner. We believe this to be a growing trend for IoT devices. Owner Client : This is an entity constructed to perform Secure Device Onboard protocols on behalf of the Owner. The Owner Client is an application that executes on some platform already controlled by the owner. After the protocols are completed, the Owner Client transfers control of the device to the Owner\u2019s Manager, and never interacts with the device again. Rendezvous Server : A service on the Internet that acts as a rendezvous point between a newly powered on Device and the Owner Client. Management Service : The entity that uses the Secure Device Onboard Owner Client to take ownership of the Device, so that it can manage the device remotely using its own management techniques (protocols, and others). During Secure Device Onboard operation, the Management Service interacts with the Management Agent via the ServiceInfo (section \u00a7 ) key-value pairs. Management Agent : The entity that uses the Secure Device Onboard Device software to allow the device ownership to be transferred using Secure Device Onboard protocols. During Secure Device Onboard operation, the Management Agent interacts with the Management Service via the ServiceInfo key-value pairs. Entity Credentials \u00b6 Each of the entities above identifies itself in Secure Device Onboard protocols using cryptographic credentials. These are: Device Attestation Key : Secure Device Onboard uses cryptographic device attestation. The protocol can support many mechanisms for device attestation but this spec supports two basic capabilities: Intel \u00ae EPID and ECDSA. For each of the methods, there is a private key that is provisioned into the device, such as when the CPU is manufactured (chip manufacture time) for establishing the trust for a Trusted Execution Environment (TEE) that runs on the device. Applications in the TEE are identified by an application identifier. When signed by the device attestation key, this provides evidence of the code being executed in the TEE. Ownership Credential Key Pair: This is a key pair that serves temporarily to identify the current owner of the device. When the device is manufactured, the manufacturer uses a key pair to put in an initial ownership credential. Later, the protocols shall conspire specifically to replace this credential with a new ownership credential, effecting ownership transfer. The Ownership Credential does not identify the owner in general, it identifies the owner for the purposes of ownership transfer. The manufacturer\u2019s ownership credential, as stored in the device, must match the credential at one side of the ownership voucher. That is all. It is not intended that this key pair permanently identify the manufacturer or any of the parties in the ownership voucher. On the contrary, we expect that the manufacturer will use different keys over time and the owners will also use different keys over time, specifically to obscure their identity in the Secure Device Onboard protocols and increase of the robustness of Secure Device Onboard. Management Agent/Service interactions using ServiceInfo \u00b6 In the Transfer Ownership Protocol 2 (TO2), after mutual trust is proven, and a secure channel is established, key-value pairs are exchanged. This is a mechanism for interaction between the Management Agent and Management Service using the TO2 protocol as a secure transport. The amount of information transferred using this mechanism is not specifically constrained by the TO2 protocol, but some structure is imposed in the definition of ServiceInfo (Section \u00a7 \u200e). The intent is to allow the Management Service to provision sufficient keys, data and executables to the Management Agent so that they are enabled to interact securely for the life of the device. For example, a Management Agent may send a Public Key Cryptography Standards (PKCS#10) Certificate Signing Request (CSR) to the Management Service in a Device ServiceInfo key-value pair, which can use a certificate authority (CA) to provision a certificate trusted by itself and send that certificate back to the Management Agent in PKCS#7 format, using an Owner ServiceInfo key-value pair. The flows of ServiceInfo information between the Owner and the Management Service, and between the Device and the Management Agent, are outside the scope of this document. ServiceInfo provides a key-value pair mechanism. The namespace of keys is divided into module-specific spaces and key attributes allow for downloading of data files or executable code (For example, installation scripts) using the trust provided by Secure Device Onboard. Protocol Entity Interactions \u00b6 The following diagram shows the interaction between the protocol entities in the Secure Device Onboard Protocols: Figure 1 - Secure Device Onboard Entities and Entity Interconnection The following sections define these protocols. It is expected the \u201cfinal state\u201d protocol (bottom arrow in the diagram) may be a pre-existing protocol between a manager agent and manager service that exist independently of Secure Device Onboard. Secure Device Onboard serves, then, to provide credentials rapidly and securely so that the pre-existing software is able to take over and operate, as if it were manually configured. Secure Device Onboard is then not used by the device or owner unless the owner wishes to re-provision the device, such as to effect another ownership transfer. Some of the interactions between entities are not defined in the protocols: The manufacturer creates an Ownership Voucher based on the credentials in the Device Initialize Protocol (DI). The Ownership Voucher is a digital document that provides the Owner with the credentials to take ownership of the Device. It is extended with each owner while the device is offline (that is, boxed or shipped) between Manufacturer and Owner. The Ownership Voucher is defined in section \u00a7 . This specification does not indicate how the Ownership Voucher is transported from the Manufacturer to the Owner Client, where it is used in the Secure Device Onboard protocols. The interaction between the Device TEE App and the Device to Manager Agent is system dependent. The interaction between the Owner\u2019s Manager Service and the Owner Client is dependent on the implementation of these two components. Protocols \u00b6 The following protocols are defined as part of Secure Device Onboard. Each protocol is identified with an abbreviation, suitable to use as a programming prefix. The abbreviations are also used in this discussion. Table 2 - Secure Device Onboard Protocols Protocol Name Abbr. Function Device Initialize Protocol (DI) DI For insertion of Secure Device Onboard credentials into device during the manufacturing process. Transfer Ownership Protocol 0 (TO0) TO0 Secure Device Onboard Owner identifies itself to Rendezvous Server. Establishes the mapping of GUID to the Owner IP address. Transfer Ownership Protocol 1 (TO1) TO1 Device identifies itself to the Rendezvous Server. Obtains mapping to connect to the Owner\u2019s IP address. Transfer Ownership Protocol 2 (TO2) TO2 Device contacts Owner. Establishes trust and then performs Ownership Transfer. The following figure shows a graphical overview of these protocols. Graphical representations of each protocol are presented with the protocol details. Figure 2 - Graphical Representation of the Secure Device Onboard Protocols Device Initialize Protocol (DI) \u00b6 The Device Initialize Protocol (DI) runs within the factory when a new device is completed. The protocol\u2019s function is to embed the ownership and manufacturing credentials into the newly created device\u2019s TEE. This prepares the device and establishes the first in a chain for creating an Ownership Voucher with which to transfer ownership of the device. The Device Initialize Protocol assumes that the protocol will be run in a safe environment. The trust model is Trust on First Use (TOFU). When possible, the DI Protocol should use write-once memory to ensure the Device is not erased or reprogrammed after factory use. When no such hardware is available, it might be possible to reprogram the device, so as to create alternate Secure Device Onboard credentials. The Device Initialize Protocol starts with: The physical device and the Secure Device Onboard Manufacturing Component attached to a local network within the factory. The Secure Device Onboard Manufacturing Component has access to: A key pair for device ownership, which will be used to create ownership credentials in the device and the Ownership Voucher. This key pair does not specifically identify the manufacturer (For example, it is not in a certificate) and may be changed from time to time, so long as the ownership credentials refer to the same key pair as the Ownership Voucher for that device. Certificate for the device manufacturer, which is published at the Rendezvous Service URL. Device description string, configured by the manufacturer. Device TEE running the Secure Device Onboard application. The Device Initialize Protocol ends with: The Secure Device Onboard Manufacturing Component has information and credentials to create an Ownership Voucher for the device or has the Ownership Voucher itself. The Device has ownership and manufacturer credentials stored in its TEE. The Device should arrange to protect these credentials. Ideally: Only the Device TEE software should be able to access these credentials. The credentials are protected against modification by non-Secure Device Onboard programs. Any modification of the credentials by non-Secure Device Onboard programs (despite measures above) is detectable. The Device is ready to be powered off and boxed for shipment. No further network attachment is necessary. The Device has a GUID that can be used to identify it to its new owner. This GUID is also known to the Secure Device Onboard Manufacturing Component. The GUID is not a secret. Specifically, the GUID is intended to be visible to the Owner when the device shipped in a box, perhaps being on the box itself with a bar code, perhaps being on the bill of lading. The GUID is used for one Secure Device Onboard transfer of ownership only; after Transfer Ownership Protocol 2, the GUID is replaced, and the Device has no memory of the original GUID. Transfer Ownership Protocol 0 (TO0) \u00b6 Transfer Ownership Protocol 0 (TO0) serves to connect the Owner Client with the Rendezvous Server. In this protocol, the Owner Client indicates its intention and proves it is capable of taking control of a specific Device, based on the Device\u2019s current GUID. Transfer Ownership Protocol 0 starts with: A Device that has undergone the Device Initialize Protocol (DI) and thus has credentials in its TEE identifying the Manufacturer public key that is in the Ownership Voucher. The Owner Client has access to the following: An Ownership Voucher , whose last Public key belongs to the Owner, and the GUID of the device, which is also authorized by the Ownership Voucher. The private key that is associated with its public key in the Ownership Voucher. An IP address from which to operate. This IP address need bear no relationship to the service addresses that are used by the Owner. The Owner may take steps to hide its address, such as allocating it dynamically (For example, using DHCP) or using an IPv6 privacy address. The motivation for hiding this IP address is to maintain the privacy of the Owner from the Rendezvous Server or from anyone monitoring network traffic in the vicinity of the Rendezvous Server. This can never be done for sure; we think of it as raising the bar on an attacker. The Rendezvous Server has some way to trust at least one key in the Ownership Voucher. For example, the Manufacturer has selected the Rendezvous Server, then the Rendezvous Server might be aware of the Manufacturer\u2019s public key used in the Ownership Voucher. Transfer Ownership Protocol 0 ends with: The Rendezvous Server has an entry in a table that associates the Device GUID with the Owner Client\u2019s DNS name and/or IP address for some fixed amount of time. The Owner Client is waiting for a connection from the Device TEE at this DNS name and/or IP address for this same amount of time. If the Device TEE appears within the set time interval, it can complete Transfer Ownership Protocol 1 (TO1). Otherwise, the Rendezvous Server forgets the relationship between GUID, IP address, and the Owner Client must perform Transfer Ownership Protocol 0 again. In the case of a Device being connected to a cloud service, the Owner Client typically would repeatedly perform the TO0 Protocol until all devices known to it successfully complete the TO0 Protocol. In the case of a Device being connected using an application program implementation of the Owner Client, the Owner might arrange to turn on the Owner Client shortly before turning on the device, to expedite the protocol. The Rendezvous Server is only trusted to faithfully remember the GUID to Owner Secure Device Onboard Client IP/DNS mapping. The other checks performed protect the server from DoS attacks, but are not intended to imply a greater trust in the server. In particular, the Rendezvous Server is not trusted to authorize device transfer of ownership. Furthermore, the Rendezvous Server never directly learns the result of the device transfer of ownership. Transfer Ownership Protocol 1 (TO1) \u00b6 Transfer Ownership Protocol 1 (TO1) is an interaction between the Device TEE and the Rendezvous Server that points the Device TEE at its intended Owner Client, which has recently completed Transfer Ownership Protocol 0. The TO1 Protocol is thus the mirror image of the TO0 Protocol, on the Device side. The TO1 Protocol starts with: A Device that has undergone the Device Initialize Protocol (DI) and thus has credentials in its TEE identifying the particular Manufacturer Public Key that is in the Ownership Voucher. An Owner Client and Rendezvous Server that have successfully completed Transfer Ownership Protocol 0: The Rendezvous Server has a relationship between the GUID stored in the device TEE and an IP address. The Owner Client is waiting for a connection from the Device TEE on this same IP address. If these conditions are not met, the Device will fail to complete the TO1 Protocol. In this case, it must repeatedly try to complete the protocol with an interval of time between tries. The interval of time should be chosen with a random component to try to avoid congestion at the Rendezvous Server. After the TO1 Protocol completes successfully: The Device has rendezvous information sufficient to contact the Owner Client directly. The Owner Client is waiting for a connection from the Device TEE on this same IP address (still, since it is unaffected by the TO1 Protocol). Transfer Ownership Protocol 2 (TO2) \u00b6 Transfer Ownership Protocol 2 (TO2) is an interaction between the Device TEE and the Owner Client where the transfer of ownership to the new Owner actually happens. Before the TO2 Protocol begins: The Owner has received the Ownership Voucher, and run Transfer Ownership Protocol 0 to register its IP address against the Device GUID. It is waiting for a connection from the Device TEE on this same IP address. The Device has undergone the Device Initialize Protocol (DI) and thus has credentials in its TEE identifying the particular Manufacturer\u2019s Public Key that is (hashed) in the Ownership Voucher. The Device has completed Transfer Ownership Protocol 1 (TO1), and thus has the IP address to contact the Owner Client directly. After the TO2 Protocol completes successfully: The Owner Client has replaced all the device credentials with its own, except for the Device\u2019 attestation key. The Device TEE has allocated a new secret and given the Owner a HMAC to use in a new Ownership Voucher, which can be used for resale. Please see section \u00a7 : Resale Protocol for more information. The Owner Client has transferred new credentials to the Device TEE in the form of key-value pairs. These credentials include enough information for the Device TEE to invoke the correct user-mode-resident Device to Manager Agent and allow it to connect to the Owner\u2019s service. The exact set of parameters is given in the messages: TO2.SetupDevice (section \u00a7 : TO2.SetupDevice, Type 47 ) and TO2.OwnerServiceInfo (section \u00a7 : TO2.OwnerServiceInfo, Type 49 ), although additional parameters may be sent to customize the payload. The Owner Client has transferred these credentials to the Owner\u2019s Manager, which is now ready to receive a connection from the Device. The Device TEE has received these credentials, and has invoked the Device to Manager Agent and given it access to these credentials. The Device to Manager Agent has received these credentials is ready to connect to the Owner\u2019s Manager. There is a distinction between: the Device TEE and the Device to Manager Agent; and between the Owner Client and the Owner\u2019s Manager: The Device TEE performs the Secure Device Onboard protocols and manipulates and stores Secure Device Onboard credentials. The Device TEE is likely to store other credentials and perform other services (For example, cryptographic services) for the device. The Device itself runs its basic functions in user mode. Amongst these, is the Device to Manager Agent, a user-mode service process that connects it to its remote Manager. This software is often called an \u201cagent\u201d, or \u201cclient.\u201d We intend that this software can be a pre-existing agent for the Manager service chosen by the Owner. The Owner Client is a body of software that is dedicated specifically to run the Secure Device Onboard Protocol on behalf of the Manager. For example, this code might have its own IP addresses, so that the eventual Manager IP addresses (which may be well known) are hidden from prying eyes. The Owner Manager is an Internet-resident service that provides management services for the Owner on an ongoing basis. We intend that this software be a pre-existing Manager service. After Transfer Ownership Protocol 2, the Secure Device Onboard specific software is no longer needed until and unless a new ownership transfer is intended, such as when the device is re-sold or if trust needs to be established anew. Secure Device Onboard client software adjusts itself so that it does not attempt any new protocols after the TO2 Protocol. Implementation-specific configuration can be used to re-enable ownership transfer (For example, a CLI command). Key Exchange in the TO2 Protocol \u00b6 Alone among Secure Device Onboard protocols, the TO2 Protocol requires message-level encryption. The TO2 Protocol transmits potentially long-term credentials to the Device, and these credentials are confidential between the Device TEE and its new Owner. The purpose of key exchange is to allow the Device and its Owner to agree on two shared secrets. A session verification key (SVK) is used to perform a HMAC over each message to ensure message integrity. A session encryption key (SEK) is used to encipher each message to ensure message confidentiality. Key Exchange starts with a protocol to construct a shared secret between the Owner and the Device. This is accomplished using one of supported methods below, chosen by the device. Next, the Device and Owner each uses an identical Key Derivation Function on the shared secrets to compute the session verification key (SVK) and the session encryption key (SEK). The selection of a key exchange algorithm is denoted in the TO2.HelloDevice.kx variable. When the Owner Key is RSA: \u201c DHKEXid14 \u201d: (Secure Device Onboard 1.0 & Secure Device Onboard 1.1 protocol spec) The Diffie-Hellman key exchange method using a standard Diffie-Hellman mechanism with a standard NIST exponent and 2048-bit modulus. This is the preferred method for RSA2048RESTR Owner keys. \u201cDHKEXid15\u201d : The Diffie-Hellman key exchange method using a standard Diffie-Hellman mechanism with a standard National Institute of Standards and Technology (NIST) exponent and 3072-bit modulus. This is the preferred method for RSA 3072-bit Owner keys. \u201c ASYMKEX \u201d: The Asymmetric key exchange method uses the encryption by an Owner key based on RSA2048RESTR; this method is useful in Secure Device Onboard Client-Intel environments where Diffie-Hellman computation is slow or difficult to code. \u201c ASYMKEX3072 \u201d: The Asymmetric key exchange method uses the encryption by an Owner key based on RSA with 3072-bit key. DHKEXid14 and DHKEXid15 differ in the size of the Diffie-Hellman modulus, which is chosen to match the RSA key size in use. When the Owner key is ECDSA: \u201c ECDH \u201d: The ECDH method uses a standard Diffie-Hellman mechanism for ECDSA keys. The ECC keys follow NIST P-256. \u201cECDH384\u201d: Standard Diffie-Hellman mechanism ECC NIST P-384 (future crypto). The choice of key exchange algorithm follows the cryptography of the Owner key. See section \u00a7 . Subsequent messages are covered with an HMAC-SHA that uses the SVK, above, and encrypted using AES in CBC or CTR mode, as defined in NIST Special Publication 800-38A with the SEK key. In Secure Device Onboard, the sizes of the SVK and SEK are as follows: Table 3 - SEK and SVK Sizes Item Crypto in Secure Device Onboard 1.0 & Secure Device Onboard 1.1 Size in Secure Device Onboard 1.0 & Secure Device Onboard 1.1 Future Crypto Future Size SVK HMAC-SHA-256 256 bits HMAC-SHA-384 512 bits SEK AES-128 128 bits AES-256 256 bits See section \u00a7 for a description of how encrypted messages are encoded into JSON and transmitted. Diffie-Hellman Key Exchange Protocol \u00b6 The following steps describe the Diffie-Hellman key exchange protocol (DHKEXid15), as part of the verification of the Ownership Voucher: The Device and Owner each choose random numbers (Owner: a, Device: b), and encode these numbers into exchanged parameters A = ga mod p, and B = gb mod The values \u201cp\u201d and \u201cg\u201d are chosen from [[RFC3526]] , with sizes as follows: Secure Device Onboard1.0 & Secure Device Onboard1.1 DHKEXid14 Future Crypto DHKEXid15 Modulus (p) size Generator (g) size a & b Modulus (p) size Generator (g) size a & b size size DH 2048 2 256 bits 3072 2 768 bits The Owner sends A to the Device as parameter TO2.ProveOPHdr.bo.xA. Note that this parameter is signed by the Owner key from the Ownership Voucher, which is proved as trusted later in the TO2 Protocol, but before the key exchange completes. The Device sends B to the Owner as parameter TO2.ProveDevice.bo.xB. This parameter is signed with the device attestation key. The Owner computes shared secret ShSe = B a mod p. The Device computes shared secret ShSe = A b mod p. Asymmetric Key Exchange Protocol \u00b6 The following steps describe the Asymmetric key exchange protocol (ASYMKEX or ASYMKEX3072), as part of the verification of the Ownership Voucher (here || is used to indicate binary concatenation). Asymmetric key exchange applies only to devices that support a RSA-based Ownership Voucher (any of the listed RSA public key types from Table \u200e5 in section \u00a7 ). Sizes are as follows: Owner & Device Randoms MGF Hash Function ASYMKEX 256 bits each SHA256 ASYMKEX3072 (Future Crypto) 768 bits each SHA256 1 Owner allocates a random value called the Owner Random. Owner sends the Owner Random to the device as TO2.ProveOPHdr.bo.xA. This value is signed with the Owner key, but is not encrypted. Device allocates a random value called the Device Random. Device encrypts the Device Random with the Owner public key using RSA encrypt using Optimal Asymmetric Encryption Padding (OAEP) with Mask Generation Function (MGF) SHA256 (same for Secure Device Onboard 1.0, Secure Device Onboard 1.1 protocol spec and future crypto), as received in TO2.ProveOPHdr.pk. This key is also stored in the last entry of the Ownership Voucher; the implementation may obtain it from either place. The encrypted Device Random is sent to the Owner as TO2.ProveDevice.bo.xB. This parameter is signed with the Device attestation key. Owner decrypts TO2.ProveDevice.bo.xB using its Owner Private Key (the same private key it used to sign in the TO2.ProveOPHdr message). Note that the Owner Private Key must be RSA-based. The Owner & Device each compute shared secret ShSe = DeviceRandom || OwnerRandom ECDH Key Exchange Protocol \u00b6 The following steps describe the ECDH key exchange protocol (ECDH), as part of the verification of the Ownership Voucher. ECDH applies only to devices that support an ECDSA-based Ownership Voucher. Curve and Random parameters are as follows: Secure Device Onboard 1.0 & Secure Device Onboard 1.1 Future Crypto ECC Curve Owner & Device Randoms ECC Curve Owner & Device Randoms ECDH KEX NIST P-256 (Gx, Gy), p each 256 bits 128 bits NIST P-384 (Gx, Gy), p each 384 bits 384 bits ECDH KEX on Legacy hardware N/A NIST P-256 128 bits Curve parameters are taken from NIST P-series as above, including p and the base point (Gx, Gy). ECC curves allocated for key exchange must be used once only. In the rest of this section, symbol || is used to indicate binary concatenation, and blen(x) length of x in bytes. The output of blen(x) is a 16-bit unsigned integer (UInt16). The Device and Owner each choose random numbers (Owner: a, Device: b), and encode these numbers into exchanged parameters A = (G x , G y )*a mod p, and B = (G x , G y )*b mod p. A and B are points, and have components (A x , A y ) and (B x , B y ), respectively, with bit lengths same as (Gx, G y ). The Device and Owner each choose a random number (as per table above), to be supplied with their public keys, respectively DeviceRandom, and OwnerRandom. The Owner sends ByteArray[blen(A x ), A x , blen(A y ), A y , blen(OwnerRandom), OwnerRandom] to the Device as parameter TO2.ProveOPHdr.bo.xA. Note that this parameter is signed by the Owner key from the Ownership Voucher, which is proved as trusted later in the TO2 Protocol, but before the key exchange completes. The Device sends ByteArray[blen(B x ), B x , blen(B y ), B y , blen(DeviceRandom),DeviceRandom] to the Owner as parameter TO2.ProveDevice.bo.xB. This parameter is signed with the device attestation key. The Owner computes shared secret Sh = (B*a mod p), with components (Sh x , Sh y ). The Device computes shared secret Sh = (A*b mod p), with components (Sh x , Sh y ). The shared secret ShSe is formed as: Sh x ||DeviceRandom||OwnerRandom (Note that Sh y is not used to construct ShSe). Note The DeviceRandom and OwnerRandom values are used to increase the entropy in the generated keys, in order to reduce the possibility of certain related key weaknesses. The lengths of a, b, DeviceRandom and OwnerRandom are chosen to permit the shared secret to source SVK & SEK of appropriate lengths. In steps 3 and 4, the values of A, B, DeviceRandom and OwnerRandom are transmitted within a single ByteArray as length-preceding binary strings. In item 3, the first byte is 32[48 future crypto] (=blen(A x )), followed by the binary bytes of A x , followed by 32[48 future crypto] (=blen(A y )), followed by the binary bytes of A y , followed by a byte containing 16[32 future crypto] (blen(OwnerRandom)), followed by the binary bytes of OwnerRandom. The entire ByteArray is subsequently encoded in base64 for transmission, as is usual for ByteArrays. Compatibility Note: This mechanism is intended to be a standard implementation of NIST ECC P-256 or P-384, compatible with other software and hardware implementations. Please let us know of any compatibility issues. Note that some popular hardware supports NIST ECC P-256 only (For example, ATECC508a). Legacy hardware may also require larger Device and Owner randoms when used with larger SEK and SVK for future crypto. Please contact the Secure Device Onboard Enablement team for details. Shy is not used to compute the shared secret ShSe because it can be derived from Shx and the curve equation. Hence it provides no additional entropy. Key Derivation Function \u00b6 Owner and Device both have shared secret ShSe, computed by one of the above key exchange protocols. The shared secret ShSe is fed into the Key Derivation Function defined in NIST Special Publication 800-108, KDF in Counter Mode, section 5.1. Double vertical bar (||) means binary concatenation, so a||b||c means concatenate the bits of a,b,c together. Secure Device Onboard 1.0 and Secure Device Onboard 1.1 Protocol Specification \u00b6 The following steps 1-4, which continue from the key exchange steps 1-5 described above in ECDH Key Exchange Protocol , are based on ShSe for Secure Device Onboard 1.0 / Secure Device Onboard 1.1, and yield SVK of 256 bits and SEK of 128 bits (see Table \u200e3): KeyMaterial1 = HMAC-SHA-256[0,(byte)1||\"MarshalPointKDF\"||(byte)0||\"AutomaticProvisioning-cipher\"||ShSe] KeyMaterial2 = HMAC-SHA-256[0,(byte)2||\"MarshalPointKDF\"||(byte)0||\"AutomaticProvisioning-hmac\"||ShSe] SessionEncryptionKey = SEK = KeyMaterial1[0..15] (128 bits, to feed AES128) SessionVerificationKey = SVK = KeyMaterial2[0..31] (256 bits, to feed SHA256) 2 Note The operation is HMAC-SHA-256[key, value], so the zero argument above indicates a HMAC with key of zero (0). Since HMAC keys are zero padded (See ), this should be sufficient to generate a consistent HMAC operation. The above strings are ASCII with no terminator character (that is, C \u2018\\000\u2019 terminator is not included). Future Crypto \u00b6 The following steps 1-4, which continue from the Key Exchange steps 1-5 described above in ECDH Key Exchange Protocol , are based on ShSe for future crypto, and yield SVK of 512 bits and SEK of 256 bits (see Table \u200e3): KeyMaterial1 = HMAC-SHA-384[0,(byte)1||\"MarshalPointKDF\"||(byte)0||\"AutomaticProvisioning-cipher\"||ShSe] KeyMaterial2a = HMAC-SHA-384[0,(byte)2||\"MarshalPointKDF\"||(byte)0||\"AutomaticProvisioning-hmac\"||ShSe] KeyMaterial2b = HMAC-SHA-384[0,(byte)3||\"MarshalPointKDF\"||(byte)0||\"AutomaticProvisioning-hmac\"||ShSe] (Note the 0/1 byte in the middle of each expression) SessionEncryptionKey = SEK = KeyMaterial1[0..31] (256 bits, to feed AES256) SessionVerificationKey = SVK = KeyMaterial2a[0..47] || KeyMaterial2b[0..15] (512 bits to match 512 bit internal state of HMAC-SHA-384) Note The operation is HMAC-SHA-384[key, value], so the zero argument above indicates a HMAC with key of zero (0). Since HMAC keys are zero padded (See 8), this should be sufficient to generate a consistent HMAC operation. The above strings are ASCII with no terminator character (that is, C \u2018\\000\u2019 terminator is not included). Mapping of Key Exchange Protocol with Secure Device Onboard Crypto Options \u00b6 Table \u200e4 shows the valid choices for key exchange protocol based on choice of device attestation and owner attestation algorithms selected by the device manufacturer. The key exchange method may be configured in the device at the time of manufacturing and not dynamically selected during TO2 protocol. Note that asymmetric key exchange requires that owner key be RSA based. The choice of cryptography for the key exchange protocol follows the cryptography in the Ownership Voucher (Owner key, and other keys in the Ownership Voucher). Where the Device key and Owner key use different cryptography, the Device and Owner may need to support additional algorithms to allow verification and key exchange. We encourage a choice that limits the software or hardware required in the Device. Note that the difference in signature verification performance between ECDSA and RSA algorithms might favor a hybrid approach for some devices. Table 4 - Key Exchange and Secure Device Onboard Crypto Mapping Device Attestation Owner Attestation Key Exchange EPID RSA2048RESTR DHKEXid14/ASYMKEX ECDSA NIST P-256 RSA2048RESTR DHKEXid14/ASYMKEX ECDSA NIST P-384 RSA2048RESTR DHKEXid14/ASYMKEX (Not a recommended configuration, see note) EPID RSA 3072-bit key DHKEXid15/ASYMKEX3072 ECDSA NIST P-256 RSA 3072-bit key DHKEXid15/ASYMKEX3072 (Not a recommended configuration, see note) ECDSA NIST P-384 RSA 3072-bit key DHKEXid15/ASYMKEX3072 EPID ECDSA NIST P-256 ECDH ECDSA NIST P-256 ECDSA NIST P-256 ECDH ECDSA NIST P-384 ECDSA NIST P-256 ECDH (Not a recommended configuration)* EPID ECDSA NIST P-384 ECDH384 ECDSA NIST P-256 ECDSA NIST P-384 ECDH384 (Not a recommended configuration, see note) ECDSA NIST P-384 ECDSA NIST P-384 ECDH384 Note on not recommended configurations, above These configurations have different cryptographic strength between the Ownership Voucher (Owner key) and the Device key. It is recommended to have the strongest cryptographic methods that device is capable of for efficiently verifying both the device key and the Owner key. The Ownership Voucher \u00b6 The Ownership Voucher is a structured digital document that links the Manufacturer with the Owner. It is formed as a chain of signed public keys, each signature of a public key authorizing the possessor of the corresponding private key to take ownership of the Device or pass ownership through another link in the chain. The voucher artifact described in IETF RFC8366 is different both in form and function from the Secure Device Onboard Ownership Voucher described here. The following diagram illustrates an Ownership Voucher with 3 entries. In the first entry, Manufacturer A, signs the public key of Distributor B. In the second entry, Distributor B signs the public key of Retailer C. In the third entry, Retailer C signs the public key of Owner D. The entries also contain a description of the GUID or GUIDs to which they apply, and a description of the make and model of the device. Figure 3 - Ownership Voucher Chain The signatures in the Ownership Voucher create a chain of trust from the manufacturer to the owner. The Device is pre-provisioned (in the Device Initialize Protocol (DI)) with a crypto-hash of A.PublicKey, which it can verify against A.PublicKey in the Ownership Voucher. The owner can prove his connection with the Ownership Voucher (and thus his right to take ownership of the Device) by proving its ownership of D.PrivateKey. It can do this by signing a nonce or other ephemeral object, which signature may be verified using D.PublicKey from the Ownership Voucher. The last entry in the Ownership Voucher belongs to the current owner. The public key signed in that entry is the owner\u2019s public key, signed by the previous owner. We can reasonably call this public key the \u201cOwner Key.\u201d In the TO2 Protocol, the Owner proves his ownership to the device using a signature (as above) and an Ownership Voucher that is rooted in A.PublicKey. The device verifies the hash of A.PublicKey stored in its TEE matches A.PublicKey in the Ownership Voucher, then verifies the signatures of the Ownership Voucher in sequence, until it comes to D.PublicKey. The Owner provides the Device separate proof of D.PublicKey (the \u201cowner key\u201d), completing the chain of trust. Note, that the only private key needed to prove ownership is that of the Owner. The public keys in the Ownership Voucher (and the public key hash in the Device) are sufficient to verify the chain of signatures. The public keys in the Ownership Voucher are just public keys. They do not include other ownership info, such as the name of the entity that owns the public key, what other keys they might own, where they are, and others. In fact, the Ownership Voucher is maintained only for the purposes of connecting a particular device with its particular first owner. The entities involved can and should switch the key pairs they use to sign the Ownership Voucher from time to time, to ensure that potential attackers cannot use Ownership Vouchers as a means to map out the flow of devices from factory to implementation. The Secure Device Onboard protocols also help to mask this information, but refreshing public keys is a useful additional step. Conversely, if it is desired to have specific knowledge of each of the parties contributing to the Ownership Voucher, this information might be provided by hosting X.509 certificates with the same public keys as the Ownership Voucher at a specific (public or private) site known to the transacting parties. In this case, the Ownership Voucher can be used as a record of the supply chain. Other, external, guarantees might be needed to ensure that the Ownership Voucher contains all the parties in the supply chain. Note The Ownership Voucher-signing operation is not related to the device attestation operation \u2013 that is, a device can use RSA or ECDSA for Ownership Voucher chain signing, independent of whether it uses Intel EPID or ECDSA for device attestation. Building the Ownership Credential & Ownership Voucher \u00b6 Secure Device Onboard Ownership Proxies contain information needed by the Owner: Rendezvous information sufficient to contact the Rendezvous Server The GUID of the device A Device Info string from the manufacturer that identifies the device model The Ownership Voucher is linked to the Ownership Credential, so the first part of the \u201ctool chain\u201d to build an Ownership Voucher builds the Ownership Credential. As shown in sections \u200e \u00a7 & \u00a7 , the Ownership Credential and Ownership Voucher are formatted as persisted messages using the distinguished JSON encoding. It is allowed to reformat them for storage and transmission. Since the Ownership Credentials are not signed or otherwise protected, it is required that they be suitably protected when stored or transmitted. For example, they might be signed using an available asymmetric key and sealed with an available secret key. Based on the Ownership Credential and a public key (B.PublicKey in the example above), an Ownership Voucher of 1 segment may be created. The signing key for the Ownership Voucher is a private key whose public key matches the hash in the Ownership Credential (A.PrivateKey, above). The GUID and DeviceInfo in the Ownership Voucher header must also match the hash in the Ownership Voucher entry. A secret is created in the Device TEE in the DI Protocol. This secret is used to create a HMAC of the Ownership Voucher header. The HMAC can only be verified in the same Device TEE, and is used to detect a device that has been reprogrammed after it left the factory. The HMAC size is given in Table \u200e5. Table 5 - Cryptographic Sizes for Ownership Voucher Item in Ownership Voucher Secure Device Onboard 1.0 & Secure Device Onboard 1.1 Future Cryptography HMAC in Ownership Voucher HMAC-SHA-256, based on 256-bit randomly allocated secret stored in Device HMAC-SHA-384, based on 512-bit randomly allocated secret stored in Device Public keys in Ownership Voucher (all must have same size and type) RSA-2048 with restricted exponent (type RSA2048RESTR) Or ECDSA NIST P-256 RSA with 3072-bit key (type RSA_UR) Or ECDSA NIST P-384 The key pair used for the Ownership Voucher may be chosen based on the available cryptography in the Device in question at manufacturing initialization time. The cryptographic strength is given in Table \u200e5. Legacy devices may be permitted to use smaller cryptographic sizes. Contact the Secure Device Onboard Enablement team for more details. Subsequently the Ownership Voucher may extend as follows: Required: Ownership Voucher with N segments, N \u2265 1 Owner Key Pair - private and public key This is the public key in segment N, and its corresponding private key. Keys for earlier segments are not needed. The GUID of the Device The DeviceInfo String, \u201cd\u201d in the Ownership Voucher header (OwnershipProxy.oh.d) The Public Key for the new segment - the next owner\u2019s key The private key corresponding to this public key is used either to provision the device using the protocols described in this document, or to extend the Ownership Voucher further. Procedure All hashes are computed as per Table \u200e5, except for legacy hardware, as informed by contacting the Secure Device Onboard Enablement team. Hash is computed of segment N For segment 1, the hash covers the Ownership Voucher header and the HMAC that protects it (\u201coh\u201d tag value || \u201chmac\u201d tag value) A new segment is created, containing: The public key for the new segment Hash[GUID || DeviceInfo] (the two values concatenated) The hash of segment N The new segment is then signed using the Owner key from Segment N, and appended to the ownership voucher, to become segment N+1; its signed public key becomes the new (next) Owner key. Note that the public key signed in segment N verifies the signature in segment N+1. The public key in the Ownership Voucher header verifies the signature in the first segment, segment 0. Each key in the Ownership Voucher must have the same public key type (see Table 5 in section \u00a7 ) and encoding (see Table 6 in section \u00a7 ) as appears in the Ownership Voucher\u2019s header (For example, all RSA2048RESTR, all RSA_UR, all ECDSA P-256 or all ECDSA P-384). This ensures that a Device with limited crypto capabilities can verify all the signatures. Verifying the Ownership Credential \u00b6 The Ownership Credential in the Device TEE must be stored securely in a manner that prevents and/or detects modification. Write-once memory, where available, is a useful assistive technology. The HMAC secret stored in the Device TEE is used as a fall-back where such technologies are not available. To the extent possible, the HMAC secret should be linked to the other credentials, so that modifying any credential invalidates the HMAC secret. The HMAC secret is the only Device credential that requires confidentiality. Validation of Device Certificate Chain \u00b6 In case of ECDSA device attestation, device certificate chain is included in the Ownership Voucher. The device certificate chain is a hierarchical list of certificates, starting from device certificate to intermediate CAs to root CA, where each certificate is signed by the next certificate in the list until the root CA which is self signed. The device certificate contains the public key corresponding to the ECDSA private key that is in the device TEE, and is used by the device to attest its identity in TO1 and TO2 protocols. When the Owner receives an Ownership Voucher, it may validate the device certificate chain to determine if it can trust the device certificate. If the validation fails, the Owner may decide to reject the device. Since a problem in device certificate chain may result in a large batch of devices to be rejected by the Owner, the manufacturing tool must perform some basic validation during the DI protocol per the following requirements: All certificates in the chain must be in X.509 format. Certificate path validation as per RFC 5280, Section 6.1 (Basic Path Validation) must be successful. For this, the tool may use standard APIs such as Java Class CertPathValidation (PKIX algorithm). For device certificate (leaf certificate in the chain), the following must be validated: Public Key Algorithm must be ECDSA (id-ecPublicKey). Length of Public Key must be either 256-bit or 384-bit. The ECDSA curve parameters for the Public Key must be set to either secp256r1 (NIST P-256) or secp384r1 (NIST P-384), based on the public key length. See RFC 5480 for more details. If Key Usage extension is present in the device certificate, then it must allow Digital Signature. Verifying the Ownership Voucher \u00b6 The Ownership Voucher is stored as a persisted message to be used in the TO0 and TO2 Protocols. It must be verified several ways: When being read from storage or inside a protocol transmission, the Ownership Voucher must be internally verified to make sure it has not been tampered with. If the Ownership Voucher is extended or transmitted, the owner must prove that he controls the Owner private key. The Device receiving the Ownership Voucher must verify it against the ownership credential and verify the HMAC in the Ownership Voucher using the secret stored in the device. Ownership Voucher Internal Verification \u00b6 Internal verification should be performed whenever the Ownership Voucher is read from its persisted storage or received in a protocol transmission (for more information on these messages, please see section \u00a7 and sections \u00a7 through section \u00a7 ). To verify the internal consistency of the ownership voucher, the following steps are performed: The device spec is verified to match in all segments. The GUID is verified to match in all segments. The signature of each segment is verified against the signed public key of the previous segment. The first segment is verified against the public key Ownership Voucher header (oh.pk). When verifying an encoded version of the Ownership Voucher, the hash stored in each entry can be verified to match the hash of the previous entry\u2019s encoding. The first entry matches the hash of the encoding of the Ownership Voucher header as described in section \u00a7 : Composite Types. Owner Verification against the Owner Key \u00b6 When the Owner reads the Ownership Voucher from storage, it must verify that its Owner key pair corresponds to the signed key in the last segment. This is accomplished using one of these methods: If the Owner has assurance that its stored public and private key are a pair, 3 the stored public key may be compared against the signed public key in the last segment of the Ownership Voucher. The Owner may sign a nonce using the stored private key, and verify the signature twice, using both the stored public key and the signed public key in the last segment of the Ownership Voucher. Owner Verification of Device Certificate Chain \u00b6 When an Owner receives the Ownership Voucher, the Owner must decide whether to trust or to distrust the device certificate chain. This decision is typically based on an external trust relationship with the device\u2019s supply chain. It can also be aided by cryptographic verification, but such verification cannot replace external trust. The following cryptographic steps are recommended: The certificates and signature chain of OwnershipProxy.dc are verified. OCSP information is obtained from each certificate, and where present, the OCSP protocol is run to determine whether the Device key is revoked. If so, the Ownership Voucher (and the Device) are rejected, and Secure Device Onboard is not possible without re-programming the Device (For example, using manual or automatic TCB recovery). If possible, one or more of the certificate chain CA\u2019s should be previously trusted by the Owner. If not, the Owner uses its own judgement as to whether to accept the Ownership Voucher based on other business criteria, such as the trust of supply chain partners. Receiver Verification of Owner \u00b6 When the Owner transmits the Ownership Voucher to the Rendezvous Server or to the Device, the receiver must verify the internal structure of the Ownership Voucher, and also verify the signature that the Owner provides in TO0.OwnerSign (section \u00a7 ) and the last transmission of TO2.ProveOpHdr (section \u00a7 ) against the Owner key (the public key signed in the last entry of the Ownership Voucher). In the case of the Device, the Ownership Credential key must also verify the signature in the first entry of the Ownership Voucher. In this last situation, the public key to verify the signature appears as the first entry of the Ownership Voucher, and a hash of this public key is in the Ownership Credential. The signature must be checked by the public key, and the public key\u2019s hash must be checked against the Ownership Credential. The TO2 Protocol transmits the Ownership Voucher in pieces. As an aid to constrained Devices, the receiver can process the Ownership Voucher pieces in order, without needing to ever store the entire Ownership Voucher. Pseudo code for this is provided in section \u00a7 . Service Verification of the Ownership Voucher \u00b6 The Secure Device Onboard protocols do not supply the Rendezvous Service with a mechanism for determining the trust of the Ownership Voucher. It is desirable for the Rendezvous Service to be able to trust one or more of the keys in the Ownership Voucher. This can be accomplished using a back channel to supply public keys (or public key hashes) to the Rendezvous Service as they are created by cooperating supply-chain entities. It is imperative, for security reasons, that these keys be stripped of any associated data that identify the key holder before they are configured into the Rendezvous Service. 2017-12-06 update: SHA256 may be used with RSA-OAEP under the new crypto guidelines \u21a9 The SHA256 function takes 256 bits, so we use the KDF to derive 256 bits. However, the strength of the SVK is assumed to be no more than 128 bits, because of the entropy used. \u21a9 Alternately, owner can prove that the stored public and private key are a pair by signing a nonce with the private key and verifying it using the public key. \u21a9","title":"Protocol Description"},{"location":"protocol-specification/protocol-description/#protocol-description","text":"Secure Device Onboard protocols pass JavaScript* Object Notation (JSON)-based messages between cooperating entities, which are listed in subsequent sections. The messages are defined independent of any transport protocol, permitting Secure Device Onboard to operate over multiple transport protocols with different properties, such as: RESTful HTTP/HTTPS (Current implementation of Secure Device Onboard) Constrained Application Protocol (CoAP) [[RFC7252]] TCP or TCP/TLS streams Non-Internet protocols, such as Bluetooth \u00ae specification or USB* specification Secure Device Onboard messages are encoded using a distinguished encoding of JSON*, and are intended to fit in the RESTful ecosystem. The encoding is read-compatible with JSON*, so that JSON* decoders and JSON* pretty-printers will work well with Secure Device Onboard messages. However, standard JSON* components may need to have their output adjusted to conform to this encoding. Signatures refer to the transmitted form of a message, so a standard JSON* parser may have reason to keep the original JSON* text around for verifying signatures. Other encodings of JSON* exist, and might be used with Secure Device Onboard in the future, such as the Concise Binary Object Representation (CBOR) encoding described in [[RFC7049]].","title":"Protocol Description"},{"location":"protocol-specification/protocol-description/#message-passing-protocol","text":"Secure Device Onboard messages are defined in section \u00a7 . A message is logically encapsulated by a protocol-dependent header containing the message type, protocol version, and other transmission-dependent characteristics, such as the message URL and message length in bytes. The message header is transmitted differently for different transport protocols. For example, the message header may be encoded into the HTTP header fields for RESTful protocols. The message body is a JSON* object, encoded within the JSON* distinguished encoding, described in section \u00a7 : JSON* Distinguished Encoding.","title":"Message Passing Protocol"},{"location":"protocol-specification/protocol-description/#json-distinguished-encoding","text":"The JSON* specification only describes a textual form of JSON*. Any time JSON* is transmitted, it must be encoded into a particular character set, bit order, and others. Secure Device Onboard uses a restrictive encoding for JSON* to make it easier for a constrained device to quickly and efficiently parse messages. We believe that this restricted encoding permits parsers with similar code size to parsing binary message formats. Since the encoding preserves many of the JSON* textual properties, standard JSON* components may also be used when available (for example, in non-constrained environments). However, the output of these components must be re-encoded before messages are transmitted to ensure compatibility with the distinguished encoding. The following table describes how JSON* is encoded into the JSON* distinguished encoding. Table 1 - JSON* Distinguished Encoding Encoding Rule Motivation Each message is a valid JSON* object Secure Device Onboard ecosystem can interpret message Messages are encoded only in printable ASCII (codes 0x20-0x7e). Non-ASCII characters in strings are encoded as Unicode: \\uXXXX (or \\uXXXX\\uYYYY for 32-bit Unicode) Simplicity of interpreter. Special characters: {}[]&\"\\ must be encoded as Unicode \\u\u2026 sequences when they appear in strings. Backslash escaping is not used. Simplicity of interpreter. Objects are stored in a distinguished order, as defined in this document. The object elements may not be reordered. Permits receiver to verify signatures without needing to sort the message\u2019 object tags; receiver can check expected object tags rather than parsing. No whitespace, newlines, carriage returns or tabs are permitted as padding. Spaces and tabs are permitted in JSON strings where not otherwise restricted. Simplicity of interpreter, verification of signatures. No JSON* comments are permitted. Simplifies verification of signatures. Object tags are chosen for brevity Decreases message size, important for constrained systems. When the same value appears multiple times in the Secure Device Onboard protocols, we use an object tag containing the object type and an integer giving the instance the object is used within this specification. For example, Nonces are tagged as \u201cn1\u201d, \u201cn2\u201d, and so on. Byte arrays (ByteArray) are stored as strings containing base64 data; the message structure gives a length field preceding the string to make parsing memory efficient. Decreases message size. Only positive integers are encoded; each integer is encoded in the shortest possible decimal representation (For example, \u201c01\u201d or \u201c0x33\u201d are not permitted). Negative integers and floating point numbers are not encoded. Simplicity of parser, compactness of representation, ability to sign messages. True is encoded as the number 1 False is encoded as the number 0 Simplicity of parser When messages are signed, hashed, or HMAC\u2019d the distinguished encoding of the message is used. Since this coding can only have one form for any message value (i.e., it is distinguished), this can be done directly on the encoded text. Conventional JSON* decoders might find it convenient to keep pointers into the original message text of a message for these operations, since their operation might introduce or remove parts of the plaintext. Note The message and data type descriptions in this document use JSON with comments and white space. This is for clarity only. JSON comments and white space are never transmitted. In protocol implementations, JSON* is usually parsed into a parse tree by a general purpose parser, then the protocol implementation reads the parsed data to verify all message components are there. Because of the distinguished encoding, JSON* messages can be parsed by code that is intended to recognize the expected message, data type, or object tag. For example, code to parse an object: {\"s1\":\"hello\",\"n\":25,\"b\":[4,\"KlMyRg==\"]} can recognize the object using straight line code as follows: Allocate variables s1, n, b[], bsize Verify begin object { Verify tag \u201cs1\u201d, then a string, then a comma Let s1 = string that is read Verify tag \u201cn\u201d, then a number, then a comma Let n = number that is read Verify tag \u201cb\u201d then a sequence. Let bsize = the first element of the sequence, then decode the base64 string into an array of bsize bytes (yielding 0x2a, 0x53, 0x2a, 0x66). Verify end object } Although this seems laborious on paper, it results in very small and efficient code that can be debugged easily. In addition, the distinguished subset removes the need for complex object escaping, such as embedding a double quote in a string (\"a \\\"b\\\" c\" must be encoded as: \"a \\u0022b\\u0022 c\"). POST body encoding and decoding is also avoided, as well as UTF escaping. This burden is placed instead on the client protocol. However, we do not believe this is a high burden for a Device implementation.","title":"JSON* Distinguished Encoding"},{"location":"protocol-specification/protocol-description/#protocol-entities","text":"See Figure \u200e1. Secure Device Onboard Entities and Entity Interconnection for a diagram of Secure Device Onboard Entities and their protocol interconnections. Manufacturer (Mfg) : This is an Secure Device Onboard application running in the factory, which implements the initial communications with the Device TEE, as part of the Device Initialize Protocol (DI). Device : The device being manufactured, later the device being provisioned. This device has hardware and software configured on it, including a Device TEE and a Device to Manager Agent. In the following documentation, an Secure Device Onboard enabled Device is capitalized. Device TEE : The Trusted Execution Environment within the Device. In some Devices, this is a co-processor [For example Intel \u00ae Management Engine (Intel \u00ae ME)] or a special processor mode [For example, Intel \u00ae Software Guard Extensions (Intel \u00ae SGX)] that enables a small kernel of code to run, with credentials to prove its authenticity. Many Intel devices implement an Intel \u00ae DAL to allow new (signed) applications to be added to the Management Engine. Device TEE App : This is the application that is installed in the TEE of the device to provide the Secure Device Onboard capabilities on the device. When we informally refer to the Device TEE as an endpoint to a protocol, we always mean the Device TEE App. Device to Manager Agent : Software that runs on the device in normal operation that connects the device to its manager across the network. This entity\u2019s function is specific to the Manager, and outside the scope of this document, except for its first connection to the Manager. Our intention is that the Device to Manager Agent matches as closely as possible the existing agents that connection devices to remote network or cloud managers. Owner : This is an entity that is able to prove ownership to the Device using an Ownership Voucher and a private key for the last entry of the Ownership Voucher (the \u201cOwner Key\u201d). Various members of the supply chain may have bought and sold the device while it was still \u201cboxed,\u201d acting as owners, but without powering on the device. The final owner in the chain uses the Owner Client to provision the device, and then controls it across a network using a Manager. Manager : The entity that manages devices across a network. This can range from an application on a user\u2019s computer, phone or tablet, to an enterprise server, to a cloud service spanning multiple geographic regions. The Manager interacts with the device using the Device to Manager Agent . Commonly, the Manager is an existing management system or cloud management service that is provisioned using Secure Device Onboard, so that it operates the same as if it were manually provisioned. In some cases, the owner elects to subscribe to a cloud service and proxy his ownership, so that the Manager controls the ownership credentials of the owner. We believe this to be a growing trend for IoT devices. Owner Client : This is an entity constructed to perform Secure Device Onboard protocols on behalf of the Owner. The Owner Client is an application that executes on some platform already controlled by the owner. After the protocols are completed, the Owner Client transfers control of the device to the Owner\u2019s Manager, and never interacts with the device again. Rendezvous Server : A service on the Internet that acts as a rendezvous point between a newly powered on Device and the Owner Client. Management Service : The entity that uses the Secure Device Onboard Owner Client to take ownership of the Device, so that it can manage the device remotely using its own management techniques (protocols, and others). During Secure Device Onboard operation, the Management Service interacts with the Management Agent via the ServiceInfo (section \u00a7 ) key-value pairs. Management Agent : The entity that uses the Secure Device Onboard Device software to allow the device ownership to be transferred using Secure Device Onboard protocols. During Secure Device Onboard operation, the Management Agent interacts with the Management Service via the ServiceInfo key-value pairs.","title":"Protocol Entities"},{"location":"protocol-specification/protocol-description/#entity-credentials","text":"Each of the entities above identifies itself in Secure Device Onboard protocols using cryptographic credentials. These are: Device Attestation Key : Secure Device Onboard uses cryptographic device attestation. The protocol can support many mechanisms for device attestation but this spec supports two basic capabilities: Intel \u00ae EPID and ECDSA. For each of the methods, there is a private key that is provisioned into the device, such as when the CPU is manufactured (chip manufacture time) for establishing the trust for a Trusted Execution Environment (TEE) that runs on the device. Applications in the TEE are identified by an application identifier. When signed by the device attestation key, this provides evidence of the code being executed in the TEE. Ownership Credential Key Pair: This is a key pair that serves temporarily to identify the current owner of the device. When the device is manufactured, the manufacturer uses a key pair to put in an initial ownership credential. Later, the protocols shall conspire specifically to replace this credential with a new ownership credential, effecting ownership transfer. The Ownership Credential does not identify the owner in general, it identifies the owner for the purposes of ownership transfer. The manufacturer\u2019s ownership credential, as stored in the device, must match the credential at one side of the ownership voucher. That is all. It is not intended that this key pair permanently identify the manufacturer or any of the parties in the ownership voucher. On the contrary, we expect that the manufacturer will use different keys over time and the owners will also use different keys over time, specifically to obscure their identity in the Secure Device Onboard protocols and increase of the robustness of Secure Device Onboard.","title":"Entity Credentials"},{"location":"protocol-specification/protocol-description/#management-agentservice-interactions-using-serviceinfo","text":"In the Transfer Ownership Protocol 2 (TO2), after mutual trust is proven, and a secure channel is established, key-value pairs are exchanged. This is a mechanism for interaction between the Management Agent and Management Service using the TO2 protocol as a secure transport. The amount of information transferred using this mechanism is not specifically constrained by the TO2 protocol, but some structure is imposed in the definition of ServiceInfo (Section \u00a7 \u200e). The intent is to allow the Management Service to provision sufficient keys, data and executables to the Management Agent so that they are enabled to interact securely for the life of the device. For example, a Management Agent may send a Public Key Cryptography Standards (PKCS#10) Certificate Signing Request (CSR) to the Management Service in a Device ServiceInfo key-value pair, which can use a certificate authority (CA) to provision a certificate trusted by itself and send that certificate back to the Management Agent in PKCS#7 format, using an Owner ServiceInfo key-value pair. The flows of ServiceInfo information between the Owner and the Management Service, and between the Device and the Management Agent, are outside the scope of this document. ServiceInfo provides a key-value pair mechanism. The namespace of keys is divided into module-specific spaces and key attributes allow for downloading of data files or executable code (For example, installation scripts) using the trust provided by Secure Device Onboard.","title":"Management Agent/Service interactions using ServiceInfo"},{"location":"protocol-specification/protocol-description/#protocol-entity-interactions","text":"The following diagram shows the interaction between the protocol entities in the Secure Device Onboard Protocols: Figure 1 - Secure Device Onboard Entities and Entity Interconnection The following sections define these protocols. It is expected the \u201cfinal state\u201d protocol (bottom arrow in the diagram) may be a pre-existing protocol between a manager agent and manager service that exist independently of Secure Device Onboard. Secure Device Onboard serves, then, to provide credentials rapidly and securely so that the pre-existing software is able to take over and operate, as if it were manually configured. Secure Device Onboard is then not used by the device or owner unless the owner wishes to re-provision the device, such as to effect another ownership transfer. Some of the interactions between entities are not defined in the protocols: The manufacturer creates an Ownership Voucher based on the credentials in the Device Initialize Protocol (DI). The Ownership Voucher is a digital document that provides the Owner with the credentials to take ownership of the Device. It is extended with each owner while the device is offline (that is, boxed or shipped) between Manufacturer and Owner. The Ownership Voucher is defined in section \u00a7 . This specification does not indicate how the Ownership Voucher is transported from the Manufacturer to the Owner Client, where it is used in the Secure Device Onboard protocols. The interaction between the Device TEE App and the Device to Manager Agent is system dependent. The interaction between the Owner\u2019s Manager Service and the Owner Client is dependent on the implementation of these two components.","title":"Protocol Entity Interactions"},{"location":"protocol-specification/protocol-description/#protocols","text":"The following protocols are defined as part of Secure Device Onboard. Each protocol is identified with an abbreviation, suitable to use as a programming prefix. The abbreviations are also used in this discussion. Table 2 - Secure Device Onboard Protocols Protocol Name Abbr. Function Device Initialize Protocol (DI) DI For insertion of Secure Device Onboard credentials into device during the manufacturing process. Transfer Ownership Protocol 0 (TO0) TO0 Secure Device Onboard Owner identifies itself to Rendezvous Server. Establishes the mapping of GUID to the Owner IP address. Transfer Ownership Protocol 1 (TO1) TO1 Device identifies itself to the Rendezvous Server. Obtains mapping to connect to the Owner\u2019s IP address. Transfer Ownership Protocol 2 (TO2) TO2 Device contacts Owner. Establishes trust and then performs Ownership Transfer. The following figure shows a graphical overview of these protocols. Graphical representations of each protocol are presented with the protocol details. Figure 2 - Graphical Representation of the Secure Device Onboard Protocols","title":"Protocols"},{"location":"protocol-specification/protocol-description/#device-initialize-protocol-di","text":"The Device Initialize Protocol (DI) runs within the factory when a new device is completed. The protocol\u2019s function is to embed the ownership and manufacturing credentials into the newly created device\u2019s TEE. This prepares the device and establishes the first in a chain for creating an Ownership Voucher with which to transfer ownership of the device. The Device Initialize Protocol assumes that the protocol will be run in a safe environment. The trust model is Trust on First Use (TOFU). When possible, the DI Protocol should use write-once memory to ensure the Device is not erased or reprogrammed after factory use. When no such hardware is available, it might be possible to reprogram the device, so as to create alternate Secure Device Onboard credentials. The Device Initialize Protocol starts with: The physical device and the Secure Device Onboard Manufacturing Component attached to a local network within the factory. The Secure Device Onboard Manufacturing Component has access to: A key pair for device ownership, which will be used to create ownership credentials in the device and the Ownership Voucher. This key pair does not specifically identify the manufacturer (For example, it is not in a certificate) and may be changed from time to time, so long as the ownership credentials refer to the same key pair as the Ownership Voucher for that device. Certificate for the device manufacturer, which is published at the Rendezvous Service URL. Device description string, configured by the manufacturer. Device TEE running the Secure Device Onboard application. The Device Initialize Protocol ends with: The Secure Device Onboard Manufacturing Component has information and credentials to create an Ownership Voucher for the device or has the Ownership Voucher itself. The Device has ownership and manufacturer credentials stored in its TEE. The Device should arrange to protect these credentials. Ideally: Only the Device TEE software should be able to access these credentials. The credentials are protected against modification by non-Secure Device Onboard programs. Any modification of the credentials by non-Secure Device Onboard programs (despite measures above) is detectable. The Device is ready to be powered off and boxed for shipment. No further network attachment is necessary. The Device has a GUID that can be used to identify it to its new owner. This GUID is also known to the Secure Device Onboard Manufacturing Component. The GUID is not a secret. Specifically, the GUID is intended to be visible to the Owner when the device shipped in a box, perhaps being on the box itself with a bar code, perhaps being on the bill of lading. The GUID is used for one Secure Device Onboard transfer of ownership only; after Transfer Ownership Protocol 2, the GUID is replaced, and the Device has no memory of the original GUID.","title":"Device Initialize Protocol (DI)"},{"location":"protocol-specification/protocol-description/#transfer-ownership-protocol-0-to0","text":"Transfer Ownership Protocol 0 (TO0) serves to connect the Owner Client with the Rendezvous Server. In this protocol, the Owner Client indicates its intention and proves it is capable of taking control of a specific Device, based on the Device\u2019s current GUID. Transfer Ownership Protocol 0 starts with: A Device that has undergone the Device Initialize Protocol (DI) and thus has credentials in its TEE identifying the Manufacturer public key that is in the Ownership Voucher. The Owner Client has access to the following: An Ownership Voucher , whose last Public key belongs to the Owner, and the GUID of the device, which is also authorized by the Ownership Voucher. The private key that is associated with its public key in the Ownership Voucher. An IP address from which to operate. This IP address need bear no relationship to the service addresses that are used by the Owner. The Owner may take steps to hide its address, such as allocating it dynamically (For example, using DHCP) or using an IPv6 privacy address. The motivation for hiding this IP address is to maintain the privacy of the Owner from the Rendezvous Server or from anyone monitoring network traffic in the vicinity of the Rendezvous Server. This can never be done for sure; we think of it as raising the bar on an attacker. The Rendezvous Server has some way to trust at least one key in the Ownership Voucher. For example, the Manufacturer has selected the Rendezvous Server, then the Rendezvous Server might be aware of the Manufacturer\u2019s public key used in the Ownership Voucher. Transfer Ownership Protocol 0 ends with: The Rendezvous Server has an entry in a table that associates the Device GUID with the Owner Client\u2019s DNS name and/or IP address for some fixed amount of time. The Owner Client is waiting for a connection from the Device TEE at this DNS name and/or IP address for this same amount of time. If the Device TEE appears within the set time interval, it can complete Transfer Ownership Protocol 1 (TO1). Otherwise, the Rendezvous Server forgets the relationship between GUID, IP address, and the Owner Client must perform Transfer Ownership Protocol 0 again. In the case of a Device being connected to a cloud service, the Owner Client typically would repeatedly perform the TO0 Protocol until all devices known to it successfully complete the TO0 Protocol. In the case of a Device being connected using an application program implementation of the Owner Client, the Owner might arrange to turn on the Owner Client shortly before turning on the device, to expedite the protocol. The Rendezvous Server is only trusted to faithfully remember the GUID to Owner Secure Device Onboard Client IP/DNS mapping. The other checks performed protect the server from DoS attacks, but are not intended to imply a greater trust in the server. In particular, the Rendezvous Server is not trusted to authorize device transfer of ownership. Furthermore, the Rendezvous Server never directly learns the result of the device transfer of ownership.","title":"Transfer Ownership Protocol 0 (TO0)"},{"location":"protocol-specification/protocol-description/#transfer-ownership-protocol-1-to1","text":"Transfer Ownership Protocol 1 (TO1) is an interaction between the Device TEE and the Rendezvous Server that points the Device TEE at its intended Owner Client, which has recently completed Transfer Ownership Protocol 0. The TO1 Protocol is thus the mirror image of the TO0 Protocol, on the Device side. The TO1 Protocol starts with: A Device that has undergone the Device Initialize Protocol (DI) and thus has credentials in its TEE identifying the particular Manufacturer Public Key that is in the Ownership Voucher. An Owner Client and Rendezvous Server that have successfully completed Transfer Ownership Protocol 0: The Rendezvous Server has a relationship between the GUID stored in the device TEE and an IP address. The Owner Client is waiting for a connection from the Device TEE on this same IP address. If these conditions are not met, the Device will fail to complete the TO1 Protocol. In this case, it must repeatedly try to complete the protocol with an interval of time between tries. The interval of time should be chosen with a random component to try to avoid congestion at the Rendezvous Server. After the TO1 Protocol completes successfully: The Device has rendezvous information sufficient to contact the Owner Client directly. The Owner Client is waiting for a connection from the Device TEE on this same IP address (still, since it is unaffected by the TO1 Protocol).","title":"Transfer Ownership Protocol 1 (TO1)"},{"location":"protocol-specification/protocol-description/#transfer-ownership-protocol-2-to2","text":"Transfer Ownership Protocol 2 (TO2) is an interaction between the Device TEE and the Owner Client where the transfer of ownership to the new Owner actually happens. Before the TO2 Protocol begins: The Owner has received the Ownership Voucher, and run Transfer Ownership Protocol 0 to register its IP address against the Device GUID. It is waiting for a connection from the Device TEE on this same IP address. The Device has undergone the Device Initialize Protocol (DI) and thus has credentials in its TEE identifying the particular Manufacturer\u2019s Public Key that is (hashed) in the Ownership Voucher. The Device has completed Transfer Ownership Protocol 1 (TO1), and thus has the IP address to contact the Owner Client directly. After the TO2 Protocol completes successfully: The Owner Client has replaced all the device credentials with its own, except for the Device\u2019 attestation key. The Device TEE has allocated a new secret and given the Owner a HMAC to use in a new Ownership Voucher, which can be used for resale. Please see section \u00a7 : Resale Protocol for more information. The Owner Client has transferred new credentials to the Device TEE in the form of key-value pairs. These credentials include enough information for the Device TEE to invoke the correct user-mode-resident Device to Manager Agent and allow it to connect to the Owner\u2019s service. The exact set of parameters is given in the messages: TO2.SetupDevice (section \u00a7 : TO2.SetupDevice, Type 47 ) and TO2.OwnerServiceInfo (section \u00a7 : TO2.OwnerServiceInfo, Type 49 ), although additional parameters may be sent to customize the payload. The Owner Client has transferred these credentials to the Owner\u2019s Manager, which is now ready to receive a connection from the Device. The Device TEE has received these credentials, and has invoked the Device to Manager Agent and given it access to these credentials. The Device to Manager Agent has received these credentials is ready to connect to the Owner\u2019s Manager. There is a distinction between: the Device TEE and the Device to Manager Agent; and between the Owner Client and the Owner\u2019s Manager: The Device TEE performs the Secure Device Onboard protocols and manipulates and stores Secure Device Onboard credentials. The Device TEE is likely to store other credentials and perform other services (For example, cryptographic services) for the device. The Device itself runs its basic functions in user mode. Amongst these, is the Device to Manager Agent, a user-mode service process that connects it to its remote Manager. This software is often called an \u201cagent\u201d, or \u201cclient.\u201d We intend that this software can be a pre-existing agent for the Manager service chosen by the Owner. The Owner Client is a body of software that is dedicated specifically to run the Secure Device Onboard Protocol on behalf of the Manager. For example, this code might have its own IP addresses, so that the eventual Manager IP addresses (which may be well known) are hidden from prying eyes. The Owner Manager is an Internet-resident service that provides management services for the Owner on an ongoing basis. We intend that this software be a pre-existing Manager service. After Transfer Ownership Protocol 2, the Secure Device Onboard specific software is no longer needed until and unless a new ownership transfer is intended, such as when the device is re-sold or if trust needs to be established anew. Secure Device Onboard client software adjusts itself so that it does not attempt any new protocols after the TO2 Protocol. Implementation-specific configuration can be used to re-enable ownership transfer (For example, a CLI command).","title":"Transfer Ownership Protocol 2 (TO2)"},{"location":"protocol-specification/protocol-description/#key-exchange-in-the-to2-protocol","text":"Alone among Secure Device Onboard protocols, the TO2 Protocol requires message-level encryption. The TO2 Protocol transmits potentially long-term credentials to the Device, and these credentials are confidential between the Device TEE and its new Owner. The purpose of key exchange is to allow the Device and its Owner to agree on two shared secrets. A session verification key (SVK) is used to perform a HMAC over each message to ensure message integrity. A session encryption key (SEK) is used to encipher each message to ensure message confidentiality. Key Exchange starts with a protocol to construct a shared secret between the Owner and the Device. This is accomplished using one of supported methods below, chosen by the device. Next, the Device and Owner each uses an identical Key Derivation Function on the shared secrets to compute the session verification key (SVK) and the session encryption key (SEK). The selection of a key exchange algorithm is denoted in the TO2.HelloDevice.kx variable. When the Owner Key is RSA: \u201c DHKEXid14 \u201d: (Secure Device Onboard 1.0 & Secure Device Onboard 1.1 protocol spec) The Diffie-Hellman key exchange method using a standard Diffie-Hellman mechanism with a standard NIST exponent and 2048-bit modulus. This is the preferred method for RSA2048RESTR Owner keys. \u201cDHKEXid15\u201d : The Diffie-Hellman key exchange method using a standard Diffie-Hellman mechanism with a standard National Institute of Standards and Technology (NIST) exponent and 3072-bit modulus. This is the preferred method for RSA 3072-bit Owner keys. \u201c ASYMKEX \u201d: The Asymmetric key exchange method uses the encryption by an Owner key based on RSA2048RESTR; this method is useful in Secure Device Onboard Client-Intel environments where Diffie-Hellman computation is slow or difficult to code. \u201c ASYMKEX3072 \u201d: The Asymmetric key exchange method uses the encryption by an Owner key based on RSA with 3072-bit key. DHKEXid14 and DHKEXid15 differ in the size of the Diffie-Hellman modulus, which is chosen to match the RSA key size in use. When the Owner key is ECDSA: \u201c ECDH \u201d: The ECDH method uses a standard Diffie-Hellman mechanism for ECDSA keys. The ECC keys follow NIST P-256. \u201cECDH384\u201d: Standard Diffie-Hellman mechanism ECC NIST P-384 (future crypto). The choice of key exchange algorithm follows the cryptography of the Owner key. See section \u00a7 . Subsequent messages are covered with an HMAC-SHA that uses the SVK, above, and encrypted using AES in CBC or CTR mode, as defined in NIST Special Publication 800-38A with the SEK key. In Secure Device Onboard, the sizes of the SVK and SEK are as follows: Table 3 - SEK and SVK Sizes Item Crypto in Secure Device Onboard 1.0 & Secure Device Onboard 1.1 Size in Secure Device Onboard 1.0 & Secure Device Onboard 1.1 Future Crypto Future Size SVK HMAC-SHA-256 256 bits HMAC-SHA-384 512 bits SEK AES-128 128 bits AES-256 256 bits See section \u00a7 for a description of how encrypted messages are encoded into JSON and transmitted.","title":"Key Exchange in the TO2 Protocol"},{"location":"protocol-specification/protocol-description/#diffie-hellman-key-exchange-protocol","text":"The following steps describe the Diffie-Hellman key exchange protocol (DHKEXid15), as part of the verification of the Ownership Voucher: The Device and Owner each choose random numbers (Owner: a, Device: b), and encode these numbers into exchanged parameters A = ga mod p, and B = gb mod The values \u201cp\u201d and \u201cg\u201d are chosen from [[RFC3526]] , with sizes as follows: Secure Device Onboard1.0 & Secure Device Onboard1.1 DHKEXid14 Future Crypto DHKEXid15 Modulus (p) size Generator (g) size a & b Modulus (p) size Generator (g) size a & b size size DH 2048 2 256 bits 3072 2 768 bits The Owner sends A to the Device as parameter TO2.ProveOPHdr.bo.xA. Note that this parameter is signed by the Owner key from the Ownership Voucher, which is proved as trusted later in the TO2 Protocol, but before the key exchange completes. The Device sends B to the Owner as parameter TO2.ProveDevice.bo.xB. This parameter is signed with the device attestation key. The Owner computes shared secret ShSe = B a mod p. The Device computes shared secret ShSe = A b mod p.","title":"Diffie-Hellman Key Exchange Protocol"},{"location":"protocol-specification/protocol-description/#asymmetric-key-exchange-protocol","text":"The following steps describe the Asymmetric key exchange protocol (ASYMKEX or ASYMKEX3072), as part of the verification of the Ownership Voucher (here || is used to indicate binary concatenation). Asymmetric key exchange applies only to devices that support a RSA-based Ownership Voucher (any of the listed RSA public key types from Table \u200e5 in section \u00a7 ). Sizes are as follows: Owner & Device Randoms MGF Hash Function ASYMKEX 256 bits each SHA256 ASYMKEX3072 (Future Crypto) 768 bits each SHA256 1 Owner allocates a random value called the Owner Random. Owner sends the Owner Random to the device as TO2.ProveOPHdr.bo.xA. This value is signed with the Owner key, but is not encrypted. Device allocates a random value called the Device Random. Device encrypts the Device Random with the Owner public key using RSA encrypt using Optimal Asymmetric Encryption Padding (OAEP) with Mask Generation Function (MGF) SHA256 (same for Secure Device Onboard 1.0, Secure Device Onboard 1.1 protocol spec and future crypto), as received in TO2.ProveOPHdr.pk. This key is also stored in the last entry of the Ownership Voucher; the implementation may obtain it from either place. The encrypted Device Random is sent to the Owner as TO2.ProveDevice.bo.xB. This parameter is signed with the Device attestation key. Owner decrypts TO2.ProveDevice.bo.xB using its Owner Private Key (the same private key it used to sign in the TO2.ProveOPHdr message). Note that the Owner Private Key must be RSA-based. The Owner & Device each compute shared secret ShSe = DeviceRandom || OwnerRandom","title":"Asymmetric Key Exchange Protocol"},{"location":"protocol-specification/protocol-description/#ecdh-key-exchange-protocol","text":"The following steps describe the ECDH key exchange protocol (ECDH), as part of the verification of the Ownership Voucher. ECDH applies only to devices that support an ECDSA-based Ownership Voucher. Curve and Random parameters are as follows: Secure Device Onboard 1.0 & Secure Device Onboard 1.1 Future Crypto ECC Curve Owner & Device Randoms ECC Curve Owner & Device Randoms ECDH KEX NIST P-256 (Gx, Gy), p each 256 bits 128 bits NIST P-384 (Gx, Gy), p each 384 bits 384 bits ECDH KEX on Legacy hardware N/A NIST P-256 128 bits Curve parameters are taken from NIST P-series as above, including p and the base point (Gx, Gy). ECC curves allocated for key exchange must be used once only. In the rest of this section, symbol || is used to indicate binary concatenation, and blen(x) length of x in bytes. The output of blen(x) is a 16-bit unsigned integer (UInt16). The Device and Owner each choose random numbers (Owner: a, Device: b), and encode these numbers into exchanged parameters A = (G x , G y )*a mod p, and B = (G x , G y )*b mod p. A and B are points, and have components (A x , A y ) and (B x , B y ), respectively, with bit lengths same as (Gx, G y ). The Device and Owner each choose a random number (as per table above), to be supplied with their public keys, respectively DeviceRandom, and OwnerRandom. The Owner sends ByteArray[blen(A x ), A x , blen(A y ), A y , blen(OwnerRandom), OwnerRandom] to the Device as parameter TO2.ProveOPHdr.bo.xA. Note that this parameter is signed by the Owner key from the Ownership Voucher, which is proved as trusted later in the TO2 Protocol, but before the key exchange completes. The Device sends ByteArray[blen(B x ), B x , blen(B y ), B y , blen(DeviceRandom),DeviceRandom] to the Owner as parameter TO2.ProveDevice.bo.xB. This parameter is signed with the device attestation key. The Owner computes shared secret Sh = (B*a mod p), with components (Sh x , Sh y ). The Device computes shared secret Sh = (A*b mod p), with components (Sh x , Sh y ). The shared secret ShSe is formed as: Sh x ||DeviceRandom||OwnerRandom (Note that Sh y is not used to construct ShSe). Note The DeviceRandom and OwnerRandom values are used to increase the entropy in the generated keys, in order to reduce the possibility of certain related key weaknesses. The lengths of a, b, DeviceRandom and OwnerRandom are chosen to permit the shared secret to source SVK & SEK of appropriate lengths. In steps 3 and 4, the values of A, B, DeviceRandom and OwnerRandom are transmitted within a single ByteArray as length-preceding binary strings. In item 3, the first byte is 32[48 future crypto] (=blen(A x )), followed by the binary bytes of A x , followed by 32[48 future crypto] (=blen(A y )), followed by the binary bytes of A y , followed by a byte containing 16[32 future crypto] (blen(OwnerRandom)), followed by the binary bytes of OwnerRandom. The entire ByteArray is subsequently encoded in base64 for transmission, as is usual for ByteArrays. Compatibility Note: This mechanism is intended to be a standard implementation of NIST ECC P-256 or P-384, compatible with other software and hardware implementations. Please let us know of any compatibility issues. Note that some popular hardware supports NIST ECC P-256 only (For example, ATECC508a). Legacy hardware may also require larger Device and Owner randoms when used with larger SEK and SVK for future crypto. Please contact the Secure Device Onboard Enablement team for details. Shy is not used to compute the shared secret ShSe because it can be derived from Shx and the curve equation. Hence it provides no additional entropy.","title":"ECDH Key Exchange Protocol"},{"location":"protocol-specification/protocol-description/#key-derivation-function","text":"Owner and Device both have shared secret ShSe, computed by one of the above key exchange protocols. The shared secret ShSe is fed into the Key Derivation Function defined in NIST Special Publication 800-108, KDF in Counter Mode, section 5.1. Double vertical bar (||) means binary concatenation, so a||b||c means concatenate the bits of a,b,c together.","title":"Key Derivation Function"},{"location":"protocol-specification/protocol-description/#secure-device-onboard-10-and-secure-device-onboard-11-protocol-specification","text":"The following steps 1-4, which continue from the key exchange steps 1-5 described above in ECDH Key Exchange Protocol , are based on ShSe for Secure Device Onboard 1.0 / Secure Device Onboard 1.1, and yield SVK of 256 bits and SEK of 128 bits (see Table \u200e3): KeyMaterial1 = HMAC-SHA-256[0,(byte)1||\"MarshalPointKDF\"||(byte)0||\"AutomaticProvisioning-cipher\"||ShSe] KeyMaterial2 = HMAC-SHA-256[0,(byte)2||\"MarshalPointKDF\"||(byte)0||\"AutomaticProvisioning-hmac\"||ShSe] SessionEncryptionKey = SEK = KeyMaterial1[0..15] (128 bits, to feed AES128) SessionVerificationKey = SVK = KeyMaterial2[0..31] (256 bits, to feed SHA256) 2 Note The operation is HMAC-SHA-256[key, value], so the zero argument above indicates a HMAC with key of zero (0). Since HMAC keys are zero padded (See ), this should be sufficient to generate a consistent HMAC operation. The above strings are ASCII with no terminator character (that is, C \u2018\\000\u2019 terminator is not included).","title":"Secure Device Onboard 1.0 and Secure Device Onboard 1.1 Protocol Specification"},{"location":"protocol-specification/protocol-description/#future-crypto","text":"The following steps 1-4, which continue from the Key Exchange steps 1-5 described above in ECDH Key Exchange Protocol , are based on ShSe for future crypto, and yield SVK of 512 bits and SEK of 256 bits (see Table \u200e3): KeyMaterial1 = HMAC-SHA-384[0,(byte)1||\"MarshalPointKDF\"||(byte)0||\"AutomaticProvisioning-cipher\"||ShSe] KeyMaterial2a = HMAC-SHA-384[0,(byte)2||\"MarshalPointKDF\"||(byte)0||\"AutomaticProvisioning-hmac\"||ShSe] KeyMaterial2b = HMAC-SHA-384[0,(byte)3||\"MarshalPointKDF\"||(byte)0||\"AutomaticProvisioning-hmac\"||ShSe] (Note the 0/1 byte in the middle of each expression) SessionEncryptionKey = SEK = KeyMaterial1[0..31] (256 bits, to feed AES256) SessionVerificationKey = SVK = KeyMaterial2a[0..47] || KeyMaterial2b[0..15] (512 bits to match 512 bit internal state of HMAC-SHA-384) Note The operation is HMAC-SHA-384[key, value], so the zero argument above indicates a HMAC with key of zero (0). Since HMAC keys are zero padded (See 8), this should be sufficient to generate a consistent HMAC operation. The above strings are ASCII with no terminator character (that is, C \u2018\\000\u2019 terminator is not included).","title":"Future Crypto"},{"location":"protocol-specification/protocol-description/#mapping-of-key-exchange-protocol-with-secure-device-onboard-crypto-options","text":"Table \u200e4 shows the valid choices for key exchange protocol based on choice of device attestation and owner attestation algorithms selected by the device manufacturer. The key exchange method may be configured in the device at the time of manufacturing and not dynamically selected during TO2 protocol. Note that asymmetric key exchange requires that owner key be RSA based. The choice of cryptography for the key exchange protocol follows the cryptography in the Ownership Voucher (Owner key, and other keys in the Ownership Voucher). Where the Device key and Owner key use different cryptography, the Device and Owner may need to support additional algorithms to allow verification and key exchange. We encourage a choice that limits the software or hardware required in the Device. Note that the difference in signature verification performance between ECDSA and RSA algorithms might favor a hybrid approach for some devices. Table 4 - Key Exchange and Secure Device Onboard Crypto Mapping Device Attestation Owner Attestation Key Exchange EPID RSA2048RESTR DHKEXid14/ASYMKEX ECDSA NIST P-256 RSA2048RESTR DHKEXid14/ASYMKEX ECDSA NIST P-384 RSA2048RESTR DHKEXid14/ASYMKEX (Not a recommended configuration, see note) EPID RSA 3072-bit key DHKEXid15/ASYMKEX3072 ECDSA NIST P-256 RSA 3072-bit key DHKEXid15/ASYMKEX3072 (Not a recommended configuration, see note) ECDSA NIST P-384 RSA 3072-bit key DHKEXid15/ASYMKEX3072 EPID ECDSA NIST P-256 ECDH ECDSA NIST P-256 ECDSA NIST P-256 ECDH ECDSA NIST P-384 ECDSA NIST P-256 ECDH (Not a recommended configuration)* EPID ECDSA NIST P-384 ECDH384 ECDSA NIST P-256 ECDSA NIST P-384 ECDH384 (Not a recommended configuration, see note) ECDSA NIST P-384 ECDSA NIST P-384 ECDH384 Note on not recommended configurations, above These configurations have different cryptographic strength between the Ownership Voucher (Owner key) and the Device key. It is recommended to have the strongest cryptographic methods that device is capable of for efficiently verifying both the device key and the Owner key.","title":"Mapping of Key Exchange Protocol with Secure Device Onboard Crypto Options"},{"location":"protocol-specification/protocol-description/#the-ownership-voucher","text":"The Ownership Voucher is a structured digital document that links the Manufacturer with the Owner. It is formed as a chain of signed public keys, each signature of a public key authorizing the possessor of the corresponding private key to take ownership of the Device or pass ownership through another link in the chain. The voucher artifact described in IETF RFC8366 is different both in form and function from the Secure Device Onboard Ownership Voucher described here. The following diagram illustrates an Ownership Voucher with 3 entries. In the first entry, Manufacturer A, signs the public key of Distributor B. In the second entry, Distributor B signs the public key of Retailer C. In the third entry, Retailer C signs the public key of Owner D. The entries also contain a description of the GUID or GUIDs to which they apply, and a description of the make and model of the device. Figure 3 - Ownership Voucher Chain The signatures in the Ownership Voucher create a chain of trust from the manufacturer to the owner. The Device is pre-provisioned (in the Device Initialize Protocol (DI)) with a crypto-hash of A.PublicKey, which it can verify against A.PublicKey in the Ownership Voucher. The owner can prove his connection with the Ownership Voucher (and thus his right to take ownership of the Device) by proving its ownership of D.PrivateKey. It can do this by signing a nonce or other ephemeral object, which signature may be verified using D.PublicKey from the Ownership Voucher. The last entry in the Ownership Voucher belongs to the current owner. The public key signed in that entry is the owner\u2019s public key, signed by the previous owner. We can reasonably call this public key the \u201cOwner Key.\u201d In the TO2 Protocol, the Owner proves his ownership to the device using a signature (as above) and an Ownership Voucher that is rooted in A.PublicKey. The device verifies the hash of A.PublicKey stored in its TEE matches A.PublicKey in the Ownership Voucher, then verifies the signatures of the Ownership Voucher in sequence, until it comes to D.PublicKey. The Owner provides the Device separate proof of D.PublicKey (the \u201cowner key\u201d), completing the chain of trust. Note, that the only private key needed to prove ownership is that of the Owner. The public keys in the Ownership Voucher (and the public key hash in the Device) are sufficient to verify the chain of signatures. The public keys in the Ownership Voucher are just public keys. They do not include other ownership info, such as the name of the entity that owns the public key, what other keys they might own, where they are, and others. In fact, the Ownership Voucher is maintained only for the purposes of connecting a particular device with its particular first owner. The entities involved can and should switch the key pairs they use to sign the Ownership Voucher from time to time, to ensure that potential attackers cannot use Ownership Vouchers as a means to map out the flow of devices from factory to implementation. The Secure Device Onboard protocols also help to mask this information, but refreshing public keys is a useful additional step. Conversely, if it is desired to have specific knowledge of each of the parties contributing to the Ownership Voucher, this information might be provided by hosting X.509 certificates with the same public keys as the Ownership Voucher at a specific (public or private) site known to the transacting parties. In this case, the Ownership Voucher can be used as a record of the supply chain. Other, external, guarantees might be needed to ensure that the Ownership Voucher contains all the parties in the supply chain. Note The Ownership Voucher-signing operation is not related to the device attestation operation \u2013 that is, a device can use RSA or ECDSA for Ownership Voucher chain signing, independent of whether it uses Intel EPID or ECDSA for device attestation.","title":"The Ownership Voucher"},{"location":"protocol-specification/protocol-description/#building-the-ownership-credential-ownership-voucher","text":"Secure Device Onboard Ownership Proxies contain information needed by the Owner: Rendezvous information sufficient to contact the Rendezvous Server The GUID of the device A Device Info string from the manufacturer that identifies the device model The Ownership Voucher is linked to the Ownership Credential, so the first part of the \u201ctool chain\u201d to build an Ownership Voucher builds the Ownership Credential. As shown in sections \u200e \u00a7 & \u00a7 , the Ownership Credential and Ownership Voucher are formatted as persisted messages using the distinguished JSON encoding. It is allowed to reformat them for storage and transmission. Since the Ownership Credentials are not signed or otherwise protected, it is required that they be suitably protected when stored or transmitted. For example, they might be signed using an available asymmetric key and sealed with an available secret key. Based on the Ownership Credential and a public key (B.PublicKey in the example above), an Ownership Voucher of 1 segment may be created. The signing key for the Ownership Voucher is a private key whose public key matches the hash in the Ownership Credential (A.PrivateKey, above). The GUID and DeviceInfo in the Ownership Voucher header must also match the hash in the Ownership Voucher entry. A secret is created in the Device TEE in the DI Protocol. This secret is used to create a HMAC of the Ownership Voucher header. The HMAC can only be verified in the same Device TEE, and is used to detect a device that has been reprogrammed after it left the factory. The HMAC size is given in Table \u200e5. Table 5 - Cryptographic Sizes for Ownership Voucher Item in Ownership Voucher Secure Device Onboard 1.0 & Secure Device Onboard 1.1 Future Cryptography HMAC in Ownership Voucher HMAC-SHA-256, based on 256-bit randomly allocated secret stored in Device HMAC-SHA-384, based on 512-bit randomly allocated secret stored in Device Public keys in Ownership Voucher (all must have same size and type) RSA-2048 with restricted exponent (type RSA2048RESTR) Or ECDSA NIST P-256 RSA with 3072-bit key (type RSA_UR) Or ECDSA NIST P-384 The key pair used for the Ownership Voucher may be chosen based on the available cryptography in the Device in question at manufacturing initialization time. The cryptographic strength is given in Table \u200e5. Legacy devices may be permitted to use smaller cryptographic sizes. Contact the Secure Device Onboard Enablement team for more details. Subsequently the Ownership Voucher may extend as follows: Required: Ownership Voucher with N segments, N \u2265 1 Owner Key Pair - private and public key This is the public key in segment N, and its corresponding private key. Keys for earlier segments are not needed. The GUID of the Device The DeviceInfo String, \u201cd\u201d in the Ownership Voucher header (OwnershipProxy.oh.d) The Public Key for the new segment - the next owner\u2019s key The private key corresponding to this public key is used either to provision the device using the protocols described in this document, or to extend the Ownership Voucher further. Procedure All hashes are computed as per Table \u200e5, except for legacy hardware, as informed by contacting the Secure Device Onboard Enablement team. Hash is computed of segment N For segment 1, the hash covers the Ownership Voucher header and the HMAC that protects it (\u201coh\u201d tag value || \u201chmac\u201d tag value) A new segment is created, containing: The public key for the new segment Hash[GUID || DeviceInfo] (the two values concatenated) The hash of segment N The new segment is then signed using the Owner key from Segment N, and appended to the ownership voucher, to become segment N+1; its signed public key becomes the new (next) Owner key. Note that the public key signed in segment N verifies the signature in segment N+1. The public key in the Ownership Voucher header verifies the signature in the first segment, segment 0. Each key in the Ownership Voucher must have the same public key type (see Table 5 in section \u00a7 ) and encoding (see Table 6 in section \u00a7 ) as appears in the Ownership Voucher\u2019s header (For example, all RSA2048RESTR, all RSA_UR, all ECDSA P-256 or all ECDSA P-384). This ensures that a Device with limited crypto capabilities can verify all the signatures.","title":"Building the Ownership Credential &amp; Ownership Voucher"},{"location":"protocol-specification/protocol-description/#verifying-the-ownership-credential","text":"The Ownership Credential in the Device TEE must be stored securely in a manner that prevents and/or detects modification. Write-once memory, where available, is a useful assistive technology. The HMAC secret stored in the Device TEE is used as a fall-back where such technologies are not available. To the extent possible, the HMAC secret should be linked to the other credentials, so that modifying any credential invalidates the HMAC secret. The HMAC secret is the only Device credential that requires confidentiality.","title":"Verifying the Ownership Credential"},{"location":"protocol-specification/protocol-description/#validation-of-device-certificate-chain","text":"In case of ECDSA device attestation, device certificate chain is included in the Ownership Voucher. The device certificate chain is a hierarchical list of certificates, starting from device certificate to intermediate CAs to root CA, where each certificate is signed by the next certificate in the list until the root CA which is self signed. The device certificate contains the public key corresponding to the ECDSA private key that is in the device TEE, and is used by the device to attest its identity in TO1 and TO2 protocols. When the Owner receives an Ownership Voucher, it may validate the device certificate chain to determine if it can trust the device certificate. If the validation fails, the Owner may decide to reject the device. Since a problem in device certificate chain may result in a large batch of devices to be rejected by the Owner, the manufacturing tool must perform some basic validation during the DI protocol per the following requirements: All certificates in the chain must be in X.509 format. Certificate path validation as per RFC 5280, Section 6.1 (Basic Path Validation) must be successful. For this, the tool may use standard APIs such as Java Class CertPathValidation (PKIX algorithm). For device certificate (leaf certificate in the chain), the following must be validated: Public Key Algorithm must be ECDSA (id-ecPublicKey). Length of Public Key must be either 256-bit or 384-bit. The ECDSA curve parameters for the Public Key must be set to either secp256r1 (NIST P-256) or secp384r1 (NIST P-384), based on the public key length. See RFC 5480 for more details. If Key Usage extension is present in the device certificate, then it must allow Digital Signature.","title":"Validation of Device Certificate Chain"},{"location":"protocol-specification/protocol-description/#verifying-the-ownership-voucher","text":"The Ownership Voucher is stored as a persisted message to be used in the TO0 and TO2 Protocols. It must be verified several ways: When being read from storage or inside a protocol transmission, the Ownership Voucher must be internally verified to make sure it has not been tampered with. If the Ownership Voucher is extended or transmitted, the owner must prove that he controls the Owner private key. The Device receiving the Ownership Voucher must verify it against the ownership credential and verify the HMAC in the Ownership Voucher using the secret stored in the device.","title":"Verifying the Ownership Voucher"},{"location":"protocol-specification/protocol-description/#ownership-voucher-internal-verification","text":"Internal verification should be performed whenever the Ownership Voucher is read from its persisted storage or received in a protocol transmission (for more information on these messages, please see section \u00a7 and sections \u00a7 through section \u00a7 ). To verify the internal consistency of the ownership voucher, the following steps are performed: The device spec is verified to match in all segments. The GUID is verified to match in all segments. The signature of each segment is verified against the signed public key of the previous segment. The first segment is verified against the public key Ownership Voucher header (oh.pk). When verifying an encoded version of the Ownership Voucher, the hash stored in each entry can be verified to match the hash of the previous entry\u2019s encoding. The first entry matches the hash of the encoding of the Ownership Voucher header as described in section \u00a7 : Composite Types.","title":"Ownership Voucher Internal Verification"},{"location":"protocol-specification/protocol-description/#owner-verification-against-the-owner-key","text":"When the Owner reads the Ownership Voucher from storage, it must verify that its Owner key pair corresponds to the signed key in the last segment. This is accomplished using one of these methods: If the Owner has assurance that its stored public and private key are a pair, 3 the stored public key may be compared against the signed public key in the last segment of the Ownership Voucher. The Owner may sign a nonce using the stored private key, and verify the signature twice, using both the stored public key and the signed public key in the last segment of the Ownership Voucher.","title":"Owner Verification against the Owner Key"},{"location":"protocol-specification/protocol-description/#owner-verification-of-device-certificate-chain","text":"When an Owner receives the Ownership Voucher, the Owner must decide whether to trust or to distrust the device certificate chain. This decision is typically based on an external trust relationship with the device\u2019s supply chain. It can also be aided by cryptographic verification, but such verification cannot replace external trust. The following cryptographic steps are recommended: The certificates and signature chain of OwnershipProxy.dc are verified. OCSP information is obtained from each certificate, and where present, the OCSP protocol is run to determine whether the Device key is revoked. If so, the Ownership Voucher (and the Device) are rejected, and Secure Device Onboard is not possible without re-programming the Device (For example, using manual or automatic TCB recovery). If possible, one or more of the certificate chain CA\u2019s should be previously trusted by the Owner. If not, the Owner uses its own judgement as to whether to accept the Ownership Voucher based on other business criteria, such as the trust of supply chain partners.","title":"Owner Verification of Device Certificate Chain"},{"location":"protocol-specification/protocol-description/#receiver-verification-of-owner","text":"When the Owner transmits the Ownership Voucher to the Rendezvous Server or to the Device, the receiver must verify the internal structure of the Ownership Voucher, and also verify the signature that the Owner provides in TO0.OwnerSign (section \u00a7 ) and the last transmission of TO2.ProveOpHdr (section \u00a7 ) against the Owner key (the public key signed in the last entry of the Ownership Voucher). In the case of the Device, the Ownership Credential key must also verify the signature in the first entry of the Ownership Voucher. In this last situation, the public key to verify the signature appears as the first entry of the Ownership Voucher, and a hash of this public key is in the Ownership Credential. The signature must be checked by the public key, and the public key\u2019s hash must be checked against the Ownership Credential. The TO2 Protocol transmits the Ownership Voucher in pieces. As an aid to constrained Devices, the receiver can process the Ownership Voucher pieces in order, without needing to ever store the entire Ownership Voucher. Pseudo code for this is provided in section \u00a7 .","title":"Receiver Verification of Owner"},{"location":"protocol-specification/protocol-description/#service-verification-of-the-ownership-voucher","text":"The Secure Device Onboard protocols do not supply the Rendezvous Service with a mechanism for determining the trust of the Ownership Voucher. It is desirable for the Rendezvous Service to be able to trust one or more of the keys in the Ownership Voucher. This can be accomplished using a back channel to supply public keys (or public key hashes) to the Rendezvous Service as they are created by cooperating supply-chain entities. It is imperative, for security reasons, that these keys be stripped of any associated data that identify the key holder before they are configured into the Rendezvous Service. 2017-12-06 update: SHA256 may be used with RSA-OAEP under the new crypto guidelines \u21a9 The SHA256 function takes 256 bits, so we use the KDF to derive 256 bits. However, the strength of the SVK is assumed to be no more than 128 bits, because of the entropy used. \u21a9 Alternately, owner can prove that the stored public and private key are a pair by signing a nonce with the private key and verifying it using the public key. \u21a9","title":"Service Verification of the Ownership Voucher"},{"location":"protocol-specification/resale-protocol/","text":"Resale Protocol \u00b6 After the transfer of ownership completes (For example, the TO2 Protocol finishes), the Device switches to an idle state (Device Secure Device Onboard State = IDLE), which inhibits the device\u2019s software from running Secure Device Onboard. See the Secure Device Onboard Architectural Specification for a description of Secure Device Onboard Device States. A device implementation might also stop a thread or process from running to achieve the same effect, perhaps freeing resources for Device operation. In the case of a MCU-based implementation, the Secure Device Onboard code might only be able to run when external software calls a specific entry point for it. The Owner may use System or OS level commands to re-enable Secure Device Onboard for a new transfer of Ownership. In complex operating systems, this can be done by setting the device to the ReadyN (Transfer Ready) state; other system level measures must be arranged on a per-implementation basis. In the TO2 Protocol (section \u00a7 ), the Secure Device Onboard software in the Device TEE stores new credentials that are only known to the Owner. How the device info is updated is described in section \u00a7 , which describes the TO2.SetupDevice message. Please note that the public key stored in the device is updated to the \u201cOwner2\u201d key, a key that is separate from the Owner key in the original Ownership Voucher. This is to prevent any way of correlating the original Ownership Voucher from the one being generated for resale in the TO2 Protocol. Subsequently, in the TO2.Done message, the Device transfers to the Owner the HMAC of the stored device credentials. This HMAC is used by the Owner exactly as the HMAC supplied to the ODM in the DI.SetHMAC message is used, to create a new Ownership Voucher. Resale, then, involves the following steps: The Device is reconditioned to remove all run-time changes and brought back to a factory state. This includes removing any secrets, except for the Secure Device Onboard credentials from the TO2 Protocol. The Device is instructed to transition to a ReadyN state, and any other actions needed to enable to Secure Device Onboard Device software to run are performed. At this point, the Device is ready to transfer ownership. It may be powered down, shipped, and re-installed in a new location. Note that the GUID in the Device has changed since it was manufactured. The Owner transfers the Ownership Voucher to the Manufacturing tool. The Manufacturing tool signs the Ownership Voucher to the next Owner and sends the updated Ownership Voucher on. Eventually, the new Owner receives the new Ownership Voucher, with a signature chain of one or more signatures. The new Owner initiates the TO0 Protocol. Eventually, the Device is installed in its new location. The Device starts to run the TO1 Protocol to determine the new Owner\u2019s Internet location. The Device segues from TO1 to TO2 Protocol to transfer ownership to the new Owner. As a side effect, yet another Ownership Voucher is created for the new Owner, and so on. It may be that, when resale time comes, the Owner wishes to change the rendezvous information that is stored in the Device TEE. This may be accomplished by performing a transfer of ownership (using the TO2 Protocol) from the Owner to itself, allowing replacement of the credentials in the TO2.SetupDevice message. Secure Device Onboard Devices that Do Not Support Resale \u00b6 A device may, at its option, implement only a limited number of Secure Device Onboard transfers of ownership. There are various reasons for this: Each transfer might consume some OTP memory, and the total amount is limited. A device is intended to be discarded after its first Ownership Transfer. The ability to use Secure Device Onboard again on a Device might be thought of as an attack vector to disable or even steal the device as the latter requires compromising both the Device and its current Owner. In this case, the Device must be careful to disable Secure Device Onboard software after the initial transfer of ownership succeeds. This can be accomplished using the Device State: PD (Permanently Disabled). If Secure Device Onboard is disabled for security reasons, it is best also to destroy any credentials in the Device or to prevent the code from running using ad hoc mechanisms, such as uninstalling the application code. As described in section \u00a7 , the TO2.Done message can also inform the Owner of the Device\u2019s inability to perform resale by transmitting zero length HMAC. Secure Device Onboard Owner that Does Not Support Resale \u00b6 An Owner may elect not to support the resale capability, even if the underlying Device is capable of doing so. The Owner is still required to provide new credentials for the Device in the [TO2.SetupDevice] message. The Owner should then discard the credentials in a manner that will ensure that neither the Owner itself nor any malicious party can ever obtain them. This involves: The Owner must ensure the security of the Owner2 private key such as discarding the key. The Owner must delete the HMAC received from the Device. The Owner must not extend the Ownership Voucher before deciding to discard the key or HMAC.","title":"Resale Protocol"},{"location":"protocol-specification/resale-protocol/#resale-protocol","text":"After the transfer of ownership completes (For example, the TO2 Protocol finishes), the Device switches to an idle state (Device Secure Device Onboard State = IDLE), which inhibits the device\u2019s software from running Secure Device Onboard. See the Secure Device Onboard Architectural Specification for a description of Secure Device Onboard Device States. A device implementation might also stop a thread or process from running to achieve the same effect, perhaps freeing resources for Device operation. In the case of a MCU-based implementation, the Secure Device Onboard code might only be able to run when external software calls a specific entry point for it. The Owner may use System or OS level commands to re-enable Secure Device Onboard for a new transfer of Ownership. In complex operating systems, this can be done by setting the device to the ReadyN (Transfer Ready) state; other system level measures must be arranged on a per-implementation basis. In the TO2 Protocol (section \u00a7 ), the Secure Device Onboard software in the Device TEE stores new credentials that are only known to the Owner. How the device info is updated is described in section \u00a7 , which describes the TO2.SetupDevice message. Please note that the public key stored in the device is updated to the \u201cOwner2\u201d key, a key that is separate from the Owner key in the original Ownership Voucher. This is to prevent any way of correlating the original Ownership Voucher from the one being generated for resale in the TO2 Protocol. Subsequently, in the TO2.Done message, the Device transfers to the Owner the HMAC of the stored device credentials. This HMAC is used by the Owner exactly as the HMAC supplied to the ODM in the DI.SetHMAC message is used, to create a new Ownership Voucher. Resale, then, involves the following steps: The Device is reconditioned to remove all run-time changes and brought back to a factory state. This includes removing any secrets, except for the Secure Device Onboard credentials from the TO2 Protocol. The Device is instructed to transition to a ReadyN state, and any other actions needed to enable to Secure Device Onboard Device software to run are performed. At this point, the Device is ready to transfer ownership. It may be powered down, shipped, and re-installed in a new location. Note that the GUID in the Device has changed since it was manufactured. The Owner transfers the Ownership Voucher to the Manufacturing tool. The Manufacturing tool signs the Ownership Voucher to the next Owner and sends the updated Ownership Voucher on. Eventually, the new Owner receives the new Ownership Voucher, with a signature chain of one or more signatures. The new Owner initiates the TO0 Protocol. Eventually, the Device is installed in its new location. The Device starts to run the TO1 Protocol to determine the new Owner\u2019s Internet location. The Device segues from TO1 to TO2 Protocol to transfer ownership to the new Owner. As a side effect, yet another Ownership Voucher is created for the new Owner, and so on. It may be that, when resale time comes, the Owner wishes to change the rendezvous information that is stored in the Device TEE. This may be accomplished by performing a transfer of ownership (using the TO2 Protocol) from the Owner to itself, allowing replacement of the credentials in the TO2.SetupDevice message.","title":"Resale Protocol"},{"location":"protocol-specification/resale-protocol/#secure-device-onboard-devices-that-do-not-support-resale","text":"A device may, at its option, implement only a limited number of Secure Device Onboard transfers of ownership. There are various reasons for this: Each transfer might consume some OTP memory, and the total amount is limited. A device is intended to be discarded after its first Ownership Transfer. The ability to use Secure Device Onboard again on a Device might be thought of as an attack vector to disable or even steal the device as the latter requires compromising both the Device and its current Owner. In this case, the Device must be careful to disable Secure Device Onboard software after the initial transfer of ownership succeeds. This can be accomplished using the Device State: PD (Permanently Disabled). If Secure Device Onboard is disabled for security reasons, it is best also to destroy any credentials in the Device or to prevent the code from running using ad hoc mechanisms, such as uninstalling the application code. As described in section \u00a7 , the TO2.Done message can also inform the Owner of the Device\u2019s inability to perform resale by transmitting zero length HMAC.","title":"Secure Device Onboard Devices that Do Not Support Resale"},{"location":"protocol-specification/resale-protocol/#secure-device-onboard-owner-that-does-not-support-resale","text":"An Owner may elect not to support the resale capability, even if the underlying Device is capable of doing so. The Owner is still required to provide new credentials for the Device in the [TO2.SetupDevice] message. The Owner should then discard the credentials in a manner that will ensure that neither the Owner itself nor any malicious party can ever obtain them. This involves: The Owner must ensure the security of the Owner2 private key such as discarding the key. The Owner must delete the HMAC received from the Device. The Owner must not extend the Ownership Voucher before deciding to discard the key or HMAC.","title":"Secure Device Onboard Owner that Does Not Support Resale"},{"location":"rendezvous-service/introduction/","text":"Rendezvous Service Introduction \u00b6 The Rendezvous Service README provides a quick start guide for building and running the Secure Device Onboard Rendezvous Service.","title":"Introduction"},{"location":"rendezvous-service/introduction/#rendezvous-service-introduction","text":"The Rendezvous Service README provides a quick start guide for building and running the Secure Device Onboard Rendezvous Service.","title":"Rendezvous Service Introduction"},{"location":"security-best-practices/security-best-practices/","text":"Introduction \u00b6 This document provides recommendations and best practices for all components of Secure Device Onboard. The intended audience includes anyone enabling Secure Device Onboard, such as device manufacturers, distributors, system integrators, IoT platform management service providers, and installers. Chapter\u202f2.0 describes security requirements and best practices that should be applied throughout the entire supply chain. Subsequent chapters describe security requirements and best practices that impact only the functionality or role of the titled chapter. Requirements that affect more than one but not all roles are listed in the chapter for each role. Document Terminology \u00b6 The document uses terminology from IETF requirements language (see RFC2119). \"SHALL\" means that the definition is an absolute requirement of the specification. \"SHALL NOT\" means that the definition is an absolute prohibition of the specification. \u201cSHOULD\u201d or the adjective \"RECOMMENDED\" means that there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course. \u201cSHOULD NOT\u201d or the phrase \"NOT RECOMMENDED\" mean that there may exist valid reasons in particular circumstances when the particular behavior is acceptable or even useful, but the full implications should be understood and the case carefully weighed before implementing any behavior described with this label. \u201cMAY\u201d or the adjective \"OPTIONAL\" means that an item is truly optional. One vendor may choose to include the item because a particular marketplace requires it or because the vendor feels that it enhances the product while another vendor may omit the same item. An implementation which does not include a particular option SHALL be prepared to interoperate with another implementation which does include the option, though perhaps with reduced functionality. In the same vein an implementation which does include a particular option SHALL be prepared to interoperate with another implementation which does not include the option (except, of course, for the feature the option provides). The terms MUST and MUST NOT are not used throughout this document. Terminology and Assets \u00b6 Secure Device Onboard functions to cause a Secure Device Onboard Device to be onboarded to a Secure Device Onboard Owner. The Secure Device Onboard Device is typically a headless computer, such as an Internet of Things (IoT) gateway, a small computer (MCU or MCP) with sensors, sometimes called an IoT Sensor, a small computer with an actuator, or some combination of the three. The Secure Device Onboard Owner is a controlling computer, typically in a cloud or operations center, that controls many such devices, checking their function, turning them on or off, collecting their data, or supplying them with instructions. The \u201conboard\u201d process is to take a device and provision into it secret information and associated information, so that the device can accept the remote control of the Secure Device Onboard Owner\u2019s computer. Examples of secret information are cryptographic keys, tokens, or passwords. Examples of associated information are: cryptographic certificates, IP addresses, software data or modules. Secure Device Onboard allows many different kinds of provisioning to happen between Secure Device Onboard Owners and Secure Device Onboard Devices. We use the term \u201conboard\u201d to denote a process where Secure Device Onboard assists a customer site to provision devices for itself, rather than mandating a specific \u201cone size fits all\u201d provisioning process. Indeed, Secure Device Onboard permits the customer to change provisioning mechanisms while a product is in the field, allowing security measures to be tuned continuously. The Ownership Voucher acts as a \u201cticket\u201d to allow the Secure Device Onboard Owner to run Secure Device Onboard successfully. It contains digital signatures that are generated by the Device Manufacturer and Supply Chain Stakeholders. The Secure Device Onboard Owner, Device, Device Manufacturer, and Supply Chain Stakeholders must protect specific assets to perform the onboarding task. It is the task of the Secure Device Onboard Device manufacturer and the Secure Device Onboard Owner to protect their own assets. The following table lists common assets, what they are used for, and why they should be protected. Protections are: Confidentiality: this asset is a secret, and revealing it to an attacker can cause Secure Device Onboard to fail. Availability: this asset must be available to allow Secure Device Onboard to function. Integrity: this asset must not be modified, or Secure Device Onboard will not function properly. Asset Where Used For Protection Required (Confidentiality, Availability, Integrity) Why to Protect GUID Device, Owner Identifying an Secure Device Onboard Device before it is onboarded. A, I The GUID allows a given Device to align with a given Owner, via the Ownership Voucher Intel \u00ae EPID signing key Device Proof from Device to Owner that the Device has a particular GUID. Often used as hardware root of trust. C, A, I Device is rejected unless the EPID signature is correct and the EPID group is trusted Intel \u00ae EPID Group ID Device, Owner A (large) number that identifies EPID keys within a specific product A, I Device proves it is a member of the group using the EPID signature; Owner must confirm that the group\u2019s associated product is acceptable Ownership Voucher Extension (OVE) key pair, private key Device Manufacturer, Supply Chain Stakeholders Intermediate signatures in OVE C, A, I Used to create a chain of signatures from manufacture to onboarding Secure Device Onboard Owner \u2013 Signing key pair, private key Owner Signing protocol operations with Rendezvous Service and Device C, A, I Used to prove Owner identity (see Secure Device Onboard Owner private key) Network between Manufacturing Station and device being initialized Manufacturer Preparing the device for Secure Device Onboard C, A, I Secure Device Onboard provisioning of initial credentials requires a trusted network environment. Attacker can steal or modify credentials and interfere with Secure Device Onboard. Ownership Credential (contains GUID, HMAC secret and other credentials) Device GUID and other credentials that allow a Device to perform Secure Device Onboard A, I (HMAC secret: C) Removing or invalidating these credentials will prevent a Device from performing Secure Device Onboard successfully Ownership Credential: HMAC Secret Device Secret value used to ensure that that Ownership Voucher is bound to the Device. Stored in the Device during manufacturing, and never revealed. C, A, I Removing or invalidating these credentials will prevent a Device from performing Secure Device Onboard successfully Manufacturing Credential Device Additional credentials that identify the manufacturer of the Device A, I Do not affect Secure Device Onboard performance, but cause a customer confusion if modified. Ownership Voucher (contains GUID) Manufacturer \u00e0 Supply Chain Stakeholders \u00e0 Owner Identifies the Secure Device Onboard Owner to the Secure Device Onboard Device. Created during manufacturing, augmented by Supply Chain Stakeholders, and finally used by the Secure Device Onboard Owner A, I Acts as a \u201cticket\u201d for the Secure Device Onboard Owner to take Ownership. Secure Device Onboard will not function properly if it is lost or corrupted. End-to-End Flow \u00b6 The Secure Device Onboard end-to-end flow is illustrated in the picture below. Figure\u202f1.End-to-End Flow Player Contributions Secure Device Onboard-Specific Function Security Responsibilities ODM / OEM Manufactures Devices Enable each device with Secure Device Onboard by executing Device Initialization (DI). DI creates the initial Ownership Voucher. Create correct Secure Device Onboard credentials and store securely in Device. Associate Device with correct Ownership Voucher (For example, via the GUID) Supply Chain Stakeholders: ODM / OEM, Distributor, Reseller, System Integrator Ownership Voucher Extension Receive the Ownership Voucher from the previous supply chain stakeholder. Extend the Ownership Voucher to the next stakeholder as the device is shipped. Send the extended Ownership Voucher to the next stakeholder. Maintain its own Owner key pair (private key must be a secret!) Receive and verify the public key for the Owner key pair of the next Supply Chain Stakeholder1 Extend the Ownership Voucher to the correct public key Deliver the correct Ownership Voucher for the Device shipped Supply Chain Stakeholders: ODM / OEM, Distributor, Reseller, System Integrator Ensure integrity of physical device. This is needed because automatic provisioning mechanisms (Secure Device Onboard or other) make it easier for a rogue device that is substituted to be accepted in the network No Secure Device Onboard specific function Take measures to ensure that the correct devices are installed. Ensure that the devices have not been tampered with (open boxes, broken seals). IoT Platform Service Provider Ownership Voucher Registration Receive the Ownership Voucher from the previous supply chain stakeholder. Register the Ownership Voucher with the Intel Rendezvous Service. Verify that the Device Certificate (in case of ECDSA based device keys) in Ownership Voucher comes from a trusted source (system distributor or manufacturer). The Root CA or intermediate CA in the Device certificate should be trusted Register to the correct Rendezvous Service and provide the right host/IP address for IoT Platform during registration (TO0 protocol) Use the private key corresponding to the last public key in Ownership Voucher to sign the messages in TO0 protocol As a supply chain stakeholder: Maintain the Secure Device Onboard Owner signing key pair (private key must be a secret!) System Installer Install Device, Power On Provide Internet connectivity (natively or via helper device). Identify the deployment physical location specifics to the Owner, so the Device can be operated usefully Avoid DoS attacks on the network during Secure Device Onboard IoT Platform Service Provider Device onboarding Runs Secure Device Onboard TO2 protocol Aids in authentication with device by signing the messages with its Owner private key Sends the IoT application specific agents, data and credentials to the device using Secure Device Onboard Provision the device with the right set of application specific credentials for the IoT agent on the device to securely connect and communicate with the IoT platform Configure the firewall and other security properties of the device during onboarding Reconfigure the device with the new Owner key, GUID and Rendezvous Info Maintain the new Owner key for the device and keep the private key a secret Cryptographic Strength \u00b6 Progress in the fields of computing and cryptography have caused cryptographic strength requirements to increase over time. A cryptographic key that was deployed securely some years ago can be broken today, based on faster and more computers and better techniques. In particular, the emerging field of quantum cryptography provides new tools that can compromise cryptographic keys. Cryptography deployed in Secure Device Onboard meets or exceeds current security requirements expected for the life of this product. Customers are encouraged to track developments in quantum cryptography in order to make intelligent assessments as to their cryptographic requirements on an ongoing basis. Customers are also encouraged to watch for security notifications that indicate new emerging risks. End-to-End Security Requirements \u00b6 This chapter addresses security requirements that are NOT specific to a particular component or role in the entire supply chain. Key Pair\u2019s Private Key Protection \u00b6 The private keys of all key pairs shall be protected throughout the entire supply chain, from the ODM to Cloud Service Provider. At a minimum, all private keys shall be protected at rest, for example, by storing them only on an encrypted file system, hardware security modules (HSM) or a distributed storage vault. Cryptographic keys require strong security at runtime, because they may be exposed to use by software. The Secure Device Onboard Reseller Tool is specifically designed so that it can be deployed with sufficient security for supply chain stakeholders to protect key pair private keys. However, the deployment must still ensure that the hardware and software are deployed safely, as below. At-Rest Protection \u00b6 At-rest protection means private keys are protected on disk or in the database but held in clear text in memory to perform signing operations. Storing the key in a file system of a machine requires careful procedural controls to ensure that the entire machine is protected from physical and virtual access. When backup procedures of the file system or database are in place, the same procedural controls shall be applied to the backup medium, especially when the medium is Internet accessible (for example, AWS S3 buckets, Google Drive ). Backup of systems through cloud services (for example, Carbonite , BackBlaze ) need additional considerations that might require case-by-case negotiations with the service provider. Memory isolation is therefore important to prevent leakage of keys across applications, containers, or virtual machines. Private key shall never be stored in plaintext Private key shall only be stored on encrypted disk or databases, or in hardware security based storages such as HSM or TPM If the private key is stored in a file or database, its encryption should be anchored in a hardware-based root of trust, such as a trusted platform module (TPM) or crypto tokens, to prevent theft of keys not in use. Applications performing the signing operations should only run on dedicated systems that are not being used for general compute to reduce the risk of side-channel attacks to obtain the keys. The system on which the private key is stored should be physically protected from theft. Runtime Protection \u00b6 To prevent private key exposure even at runtime, it is recommended to use hardware to isolate and protect keys and key operations from other parts of the system. Crypto tokens, hardware security modules (HSMs), trusted platform modules (TPMs), or processor-assisted technologies, such as Intel \u00ae Platform Trust Technology (Intel \u00ae PTT) or Intel \u00ae Software Guard Extensions (Intel \u00ae SGX), can provide these capabilities. A secure element that is physically affixed to the platform ties keys and the platform together and makes key theft visually evident since the platform will be missing. Runtime environment (including the applications and UI) that is used to access the private key for signing operation shall be restricted to only trusted users and applications. It is highly recommended to log the usage of the key such that it can be audited later in time. Customers must take care, that such cryptographic hardware is only as secure as its deployment. Even a security token that can never export a private key can be exploited if it is physically stolen from the workplace. ODM/OEM \u2014 Device Manufacturing \u00b6 This chapter addresses the manufacturing of devices, such as gateways or hardware appliances. Manufacturing Station \u00b6 The execution of the device initialization handshake is a security sensitive operation. Due to the nature of the handshake process, trust must be provided through physical isolation such as running the manufacturing station environment on a dedicated system and connecting the device over a dedicated network. This is also common best practice for other manufacturing operations such as initial flashing of the BIOS. Manufacturer\u2019s Public Key \u00b6 The Manufacturing Station requires holding the manufacturer\u2019s public key. The hash of this key is provisioned in the device during manufacturing and represents the private key that is trusted by the device as an Owner (first owner). This key is also associated with the private key residing in the first instance of the Reseller Tool, typically deployed in the manufacturer\u2019s data center. The public key shall be protected from malicious modification or replacement. During device initialization, an Ownership Voucher containing the first owner\u2019s public key is created by the Manufacturing Station and sent to manufacturer\u2019s Reseller Tool \u2014 the first Reseller Tool in the supply chain. The Manufacturing Station must be protected to prevent an adversary from performing a man-in-the-middle attack and obtaining the device\u2019s true ownership voucher while the Manufacturing Station sends an incorrect but valid ownership voucher to Reseller Tool. The figure above illustrates the relationship between the Reseller Tool and Manufacturing Station. Secure Device Onboard Database \u00b6 Secure Device Onboard database contains critical information such as the Device GUID and Rendezvous Info that is provisioned by the Manufacturer\u2019s tool in the device during DI. In addition, it contains the Ownership Vouchers produced during manufacturing. This is not confidential information from Secure Device Onboard security perspective but have business significance. The Secure Device Onboard database shall be protected from access from unauthorized personnel and applications. Device Initialization Network (DI Network) \u00b6 The data that is exchanged between the device and manufacturing station during DI protocol shall be protected from modification. Otherwise the device and Ownership Voucher may have incorrect Secure Device Onboard data, which can cause Secure Device Onboard to fail or device to malfunction during installation. Therefore, the DI network between devices and the Manufacturing Station should be used for the sole purpose of providing the device with the software necessary to perform DI (for example, PXE boot) and the DI protocol handshake. Device Manufacturing with Intel \u00ae DAL \u00ae -based Platforms \u00b6 Hardware platforms using Intel processors such as Intel Atom \u00ae or Intel \u00ae Core\u2122 have a secure DAL \u00ae (Dynamic Application Loader) environment which are all Intel \u00ae EPID enabled and do not require special steps to provision EPID signing keys. As they are also able to run generic operating systems such as Linux*, the device is capable of running a complete application that triggers the device initialization handshake procedure between the to-be-initialized device and a manufacturing station over a network connection. During the DI protocol, the HMAC secret is allocated within the DAL environment of the device. The HMAC used in the Ownership Voucher is generated by the device and transmitted to the Manufacturing Station. The HMAC secret is never revealed, and automatically maintained securely in the device. Other credentials on such as GUID, manufacturer\u2019s public key hash, Rendezvous Info are also protected in a secure storage and runtime environment provided by DAL \u00ae . This is all handled by the Secure Device Onboard DAL applet provided by Intel. Device Manufacturing with Non-Intel or Non-DAL \u00ae Platforms \u00b6 Protection (C, A, I) of Device ECDSA key \u00b6 The ECDSA key must be protected within the Device so that it can be used by the Device, but not revealed outside the Device. Various kinds of devices have different mechanisms for performing this. These include: A secure element or TPM might store the key and perform ECDSA operations The device may have a secure storage area (such as RPMB protected by secure TrustZone) that is only readable on chip. Sometimes this requires that JTAG be disabled The device may have a secure boot with an individual secure boot key, known only to the device. Device secrets, such as the ECDSA key can be encrypted using the secure boot key or its derivation. Some combination of these concepts Encryption alone does not protect the integrity of the ECDSA key. A signature or HMAC mechanism is also needed. Again, specific mechanisms vary by hardware design. Protection (C, A, I) of HMAC secret \u00b6 HMAC secret should be protected in the same way as the Device key. Protection (AI) of other Secure Device Onboard Credentials \u00b6 Other Secure Device Onboard credentials provisioned on the device such as Manufacturer\u2019s Public Key Hash, GUID and Rendezvous Info do not need to be confidential. However, to ensure their integrity, a signature or HMAC (with a protected secret) is needed. Encryption of the credentials may be used if convenient, but encryption by itself does not ensure integrity. These credentials must be available to the device or Secure Device Onboard will fail. Some devices have internal flash regions that cannot be reprogrammed by an attacker, which can improve availability. Secure elements may also have this property in their key protection areas. An OTP memory can contribute to availability and/or integrity of Secure Device Onboard credentials. However, since OTP memory is limited in size, this might limit the ability to use Secure Device Onboard in its \u201cresale\u201d mode. It is acceptable for a Secure Device Onboard Device to be limited in the number of times it can run Secure Device Onboard. In some cases, this might be done to improve device security, by removing the Secure Device Onboard credentials as an attack surface. Supply Chain \u2014 Ownership Voucher Extension \u00b6 Supply chain members extend Ownership Vouchers. Extension means that the next logical owner\u2019s public key is appended to the current ownership voucher and then signed with the current owner\u2019s private key. For a chain of keys to be valid, the private key\u2019s associated public key was appended in the same fashion by the previous owner. Each key pair in the chain is called an Ownership Voucher Extension (OVE) key pair. Ownership Voucher Extension (OVE) Environment \u00b6 The OVE environment shall be considered sensitive and part of the business-critical infrastructure. Adequate protection such as data-center access controls, firewalling, multi-tier deployment, and DMZ isolation techniques shall be applied. All RESTful API access SHALL be secured using TLS 1.2 and above. All RESTful API access SHOULD be secured using TLS 1.3 and above. All RESTful API access SHOULD be firewalled and load-balanced. Too many subsequent erroneous requests SHOULD lead to request throttling to reduce DoS attacks. Database backends SHOULD be deployed on separate servers in separate zones. Database connections SHOULD be secured using TLS (have \u201cuseSSL=true&requireSSL=true\" in the connection string). All implementation should use the Secure Device Onboard Reseller Tool to manage Ownership Vouchers, so that rules for Ownership Vouchers are maintained automatically: Ownership Voucher should be extended using the same key type and size as the original Owner public key in the Ownership Voucher header Supply chain stakeholders shall use Ownership Vouchers only to extend for the next Owner and shall not use them to run Secure Device Onboard TO protocols. Key Lifetime Agreement \u00b6 The lifetime of the OVE key pair used for extending an Ownership Voucher SHALL be limited to a reasonable duration or number of ownership extensions. From a supply chain perspective, sending the OVE\u2019s public key to the supplier (along with the order) and receiving one extended Ownership Voucher per ordered device is tightly coupled to the purchase order. The supplier knows how many Ownership Vouchers will be extended for a particular purchase order. The private key shall be kept until the device is purchased by the next owner or the device is retired. The key is needed to extend the Ownership Voucher to the next Owner. Service Provider \u2014 Owner Implementation \u00b6 The Secure Device Onboard Owner Implementation is responsible for receiving the final Ownership Voucher in the supply chain and issuing the TO0 protocol to the Rendezvous Server. The owner implementation is typically tightly integrated into the IoT Platform Management service provider\u2019s environment, therefore developed, built, and managed by the provider. It is also the point where the device is logically associated with a particular Management service account. The owner implementation runs in a secured facility such as a data center. Owner Key Pair Usage \u00b6 The Management service administrator provides the public key to the previous entity in the supply chain. The associated private key is used during the TO0 protocol phase with the Rendezvous Server. Each service account should have individual key pairs. This allows the Management Service to differentiate incoming ownership vouchers by account and to refuse vouchers extended to the wrong account. Private keys shall be protected as mentioned in Section 2.1. If the private key is exposed, (a) adversary devices can be added to an account without authorization, (b) legitimate devices can be added to adversary accounts. Key pair retirement: Private keys have to be available for signing operations until all the associated Ownership Vouchers have been consumed using the TO2 protocol. The Owner may cycle keys so that new Ownership Vouchers use the newer keys, but the old keys are still needed for signing (in the TO0 and TO2 protocols) until all Ownership Vouchers that reference them are processed. Runtime Protection of Owner Signing Keys \u00b6 The recommendation is to protect owner signing keys using security hardware. However, in large-scale operations with a significant number of accounts, the number of available hardware-protected keys might be limited. In this case, a two-step process should be deployed. The private key corresponding to the public key exposed to the account owner for ownership extension is protected only at rest. The ownership vouchers extended to that public key are then extended to a second public key where the corresponding private key is located in an HSM. The HSM is used to perform the signing operation for the final TO0 process. Since steps 1 and 2 are performed in temporal proximity, it is exactly known how long the private key is needed since Ownership Vouchers are never extended to the associated public key without performing TO0. The two-step process allows simplified key management and rolling the HSM key pair at a regular basis. Installer Notes \u00b6 Secure Device Onboard simplifies the onboarding process by eliminating cumbersome manual provisioning. Such form of automation, however, also creates risks of attacks based on social engineering that should be mitigated by proper installation and verification practices. Verification of Authenticity of Devices \u00b6 Installers shall verify the origin of the devices to be installed. If a device\u2019s origin is not known and the device was exchanged, or tampered with between manufacturing and installation, an adversary can onboard a malicious Secure Device Onboard-enabled device in a target environment without much inside knowledge of the environment. After power-up, the Secure Device Onboard-enabled device would connect to the adversary\u2019s device management service and be under its control. Installation Complete Test \u00b6 The danger of introducing a rogue device into the customer\u2019s network is higher when automatic provisioning (including Secure Device Onboard) is used than when each device is manually configured. Under manual configuration, an attacker needs to compromise a device and a person to install it. Under automatic provisioning, the attacker needs only to compromise the device and fool a trusted person to install it. For example, the attacker can switch boxes. After the onboarding process has completed, the installer should verify that the device is under the control of the expected device management service. For example, by evaluating that the device\u2019s serial number shows up in the management console. Keeping a count of systems physically installed and systems newly seen at the management console is also useful. If the device does not report an onboarding error but cannot be verified in the Management service console, the device should not be left connected. Network Restrictions at Installation \u00b6 The following additional measures are useful to prevent a rogue device from successfully operating in a customer environment, and should be implemented whenever feasible: Network authentication for IoT devices. Secure Device Onboard itself may be used to configure the network authentication into trusted (\u201cnon-rogue\u201d) devices. When all devices must be authenticated to the local network in order to function, a rogue device may be unable to connect to its intended (rogue) manager and thus fail to exfiltrate data. Network security for IoT devices that prevents them from arbitrary connection to the Internet. In many cases, IoT devices need only connect to a few sites on the Internet (for example, for software update, device management, data upload). If network access can be restricted to these sites, a rogue device may be restricted from exfiltrating data. These measures overlap in their effectiveness. In some cases, one may be easier to implement than the other. For security measures, the best policy is to implement both; a belt and suspenders back each other up from embarrassing failures. IoT Security Practices, Implementation Notes \u00b6 Secure Device Onboard does not guarantee the security of an IoT device; it just gives a good start. For most of the lifetime of the device, it must secure itself. Indeed, a failure in device security may also allow Secure Device Onboard security to fail. The following best practices are needed to ensure that an IoT device securely implements Secure Device Onboard. In general, these are good security practices that are always recommended. Secure or Verified boot. Ensure that only the desired operating system will load, so expected OS protections are implemented as predicted. Secure the OS and the file system, using one of the many best practices guides available. Secure the Secure Device Onboard programs and data stored on the OS. Deploy the Secure Device Onboard Owner in a protected data-center type environment, where physical and login access is strictly controlled. Protect the keys for the Secure Device Onboard Owner using hardware security (HSM, TPM, and others). Use secure protocols to communicate with IoT devices, and using two-way authentication (from manager to IoT device and IoT device to manager). Use standard protocols (For example, TLS 1.3) and standard implementations, to benefit from the additional security reviews done on them Use the latest versions of these implementations and update them as new ones appear Secure programming practices must be used when implementing Secure Device Onboard components Care must be taken when implementing Secure Device Onboard only to implement the Secure Device Onboard protocols that are needed for this implementation. For example, do not enable the Secure Device Onboard Device protocols for an Secure Device Onboard Owner implementation. Never enable the Secure Device Onboard Device Initialize implementation other than on a Device in manufacturing. EPID revocation information must be updated in a timely manner by Secure Device Onboard Owners. When the Intel\u00ae EPID verification service is used (this is the default), this happens automatically. Secure Device Onboard Devices with a single Trusted Computing Base (no Trusted Execution Environment) must have all the EPID keys in EPID groups only associated with the same product (for example, all keys in EPID groups for a given toaster product, or a given industrial actuator, but no groups with products mixed inside of them). This security practice is useful because Secure Device Onboard EPID authentication is by group membership. If groups contain mixed products, an attacker who penetrates a less valued target (for example, the toaster) may leverage this effort toward a more valued target (for example, a factory with industrial controllers in it). The exception is when Secure Device Onboard is implemented in a trusted execution environment with hardware protection of its own, that is, a separate Trusted Compute Base. In this case, the EPID group may follow the Trusted Compute Base (TCB) for the Secure Device Onboard implementation, and the main execution environment (outside the Trusted Execution Environment) may span many products.","title":"Security Best Practices"},{"location":"security-best-practices/security-best-practices/#introduction","text":"This document provides recommendations and best practices for all components of Secure Device Onboard. The intended audience includes anyone enabling Secure Device Onboard, such as device manufacturers, distributors, system integrators, IoT platform management service providers, and installers. Chapter\u202f2.0 describes security requirements and best practices that should be applied throughout the entire supply chain. Subsequent chapters describe security requirements and best practices that impact only the functionality or role of the titled chapter. Requirements that affect more than one but not all roles are listed in the chapter for each role.","title":"Introduction"},{"location":"security-best-practices/security-best-practices/#document-terminology","text":"The document uses terminology from IETF requirements language (see RFC2119). \"SHALL\" means that the definition is an absolute requirement of the specification. \"SHALL NOT\" means that the definition is an absolute prohibition of the specification. \u201cSHOULD\u201d or the adjective \"RECOMMENDED\" means that there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course. \u201cSHOULD NOT\u201d or the phrase \"NOT RECOMMENDED\" mean that there may exist valid reasons in particular circumstances when the particular behavior is acceptable or even useful, but the full implications should be understood and the case carefully weighed before implementing any behavior described with this label. \u201cMAY\u201d or the adjective \"OPTIONAL\" means that an item is truly optional. One vendor may choose to include the item because a particular marketplace requires it or because the vendor feels that it enhances the product while another vendor may omit the same item. An implementation which does not include a particular option SHALL be prepared to interoperate with another implementation which does include the option, though perhaps with reduced functionality. In the same vein an implementation which does include a particular option SHALL be prepared to interoperate with another implementation which does not include the option (except, of course, for the feature the option provides). The terms MUST and MUST NOT are not used throughout this document.","title":"Document Terminology"},{"location":"security-best-practices/security-best-practices/#terminology-and-assets","text":"Secure Device Onboard functions to cause a Secure Device Onboard Device to be onboarded to a Secure Device Onboard Owner. The Secure Device Onboard Device is typically a headless computer, such as an Internet of Things (IoT) gateway, a small computer (MCU or MCP) with sensors, sometimes called an IoT Sensor, a small computer with an actuator, or some combination of the three. The Secure Device Onboard Owner is a controlling computer, typically in a cloud or operations center, that controls many such devices, checking their function, turning them on or off, collecting their data, or supplying them with instructions. The \u201conboard\u201d process is to take a device and provision into it secret information and associated information, so that the device can accept the remote control of the Secure Device Onboard Owner\u2019s computer. Examples of secret information are cryptographic keys, tokens, or passwords. Examples of associated information are: cryptographic certificates, IP addresses, software data or modules. Secure Device Onboard allows many different kinds of provisioning to happen between Secure Device Onboard Owners and Secure Device Onboard Devices. We use the term \u201conboard\u201d to denote a process where Secure Device Onboard assists a customer site to provision devices for itself, rather than mandating a specific \u201cone size fits all\u201d provisioning process. Indeed, Secure Device Onboard permits the customer to change provisioning mechanisms while a product is in the field, allowing security measures to be tuned continuously. The Ownership Voucher acts as a \u201cticket\u201d to allow the Secure Device Onboard Owner to run Secure Device Onboard successfully. It contains digital signatures that are generated by the Device Manufacturer and Supply Chain Stakeholders. The Secure Device Onboard Owner, Device, Device Manufacturer, and Supply Chain Stakeholders must protect specific assets to perform the onboarding task. It is the task of the Secure Device Onboard Device manufacturer and the Secure Device Onboard Owner to protect their own assets. The following table lists common assets, what they are used for, and why they should be protected. Protections are: Confidentiality: this asset is a secret, and revealing it to an attacker can cause Secure Device Onboard to fail. Availability: this asset must be available to allow Secure Device Onboard to function. Integrity: this asset must not be modified, or Secure Device Onboard will not function properly. Asset Where Used For Protection Required (Confidentiality, Availability, Integrity) Why to Protect GUID Device, Owner Identifying an Secure Device Onboard Device before it is onboarded. A, I The GUID allows a given Device to align with a given Owner, via the Ownership Voucher Intel \u00ae EPID signing key Device Proof from Device to Owner that the Device has a particular GUID. Often used as hardware root of trust. C, A, I Device is rejected unless the EPID signature is correct and the EPID group is trusted Intel \u00ae EPID Group ID Device, Owner A (large) number that identifies EPID keys within a specific product A, I Device proves it is a member of the group using the EPID signature; Owner must confirm that the group\u2019s associated product is acceptable Ownership Voucher Extension (OVE) key pair, private key Device Manufacturer, Supply Chain Stakeholders Intermediate signatures in OVE C, A, I Used to create a chain of signatures from manufacture to onboarding Secure Device Onboard Owner \u2013 Signing key pair, private key Owner Signing protocol operations with Rendezvous Service and Device C, A, I Used to prove Owner identity (see Secure Device Onboard Owner private key) Network between Manufacturing Station and device being initialized Manufacturer Preparing the device for Secure Device Onboard C, A, I Secure Device Onboard provisioning of initial credentials requires a trusted network environment. Attacker can steal or modify credentials and interfere with Secure Device Onboard. Ownership Credential (contains GUID, HMAC secret and other credentials) Device GUID and other credentials that allow a Device to perform Secure Device Onboard A, I (HMAC secret: C) Removing or invalidating these credentials will prevent a Device from performing Secure Device Onboard successfully Ownership Credential: HMAC Secret Device Secret value used to ensure that that Ownership Voucher is bound to the Device. Stored in the Device during manufacturing, and never revealed. C, A, I Removing or invalidating these credentials will prevent a Device from performing Secure Device Onboard successfully Manufacturing Credential Device Additional credentials that identify the manufacturer of the Device A, I Do not affect Secure Device Onboard performance, but cause a customer confusion if modified. Ownership Voucher (contains GUID) Manufacturer \u00e0 Supply Chain Stakeholders \u00e0 Owner Identifies the Secure Device Onboard Owner to the Secure Device Onboard Device. Created during manufacturing, augmented by Supply Chain Stakeholders, and finally used by the Secure Device Onboard Owner A, I Acts as a \u201cticket\u201d for the Secure Device Onboard Owner to take Ownership. Secure Device Onboard will not function properly if it is lost or corrupted.","title":"Terminology and Assets"},{"location":"security-best-practices/security-best-practices/#end-to-end-flow","text":"The Secure Device Onboard end-to-end flow is illustrated in the picture below. Figure\u202f1.End-to-End Flow Player Contributions Secure Device Onboard-Specific Function Security Responsibilities ODM / OEM Manufactures Devices Enable each device with Secure Device Onboard by executing Device Initialization (DI). DI creates the initial Ownership Voucher. Create correct Secure Device Onboard credentials and store securely in Device. Associate Device with correct Ownership Voucher (For example, via the GUID) Supply Chain Stakeholders: ODM / OEM, Distributor, Reseller, System Integrator Ownership Voucher Extension Receive the Ownership Voucher from the previous supply chain stakeholder. Extend the Ownership Voucher to the next stakeholder as the device is shipped. Send the extended Ownership Voucher to the next stakeholder. Maintain its own Owner key pair (private key must be a secret!) Receive and verify the public key for the Owner key pair of the next Supply Chain Stakeholder1 Extend the Ownership Voucher to the correct public key Deliver the correct Ownership Voucher for the Device shipped Supply Chain Stakeholders: ODM / OEM, Distributor, Reseller, System Integrator Ensure integrity of physical device. This is needed because automatic provisioning mechanisms (Secure Device Onboard or other) make it easier for a rogue device that is substituted to be accepted in the network No Secure Device Onboard specific function Take measures to ensure that the correct devices are installed. Ensure that the devices have not been tampered with (open boxes, broken seals). IoT Platform Service Provider Ownership Voucher Registration Receive the Ownership Voucher from the previous supply chain stakeholder. Register the Ownership Voucher with the Intel Rendezvous Service. Verify that the Device Certificate (in case of ECDSA based device keys) in Ownership Voucher comes from a trusted source (system distributor or manufacturer). The Root CA or intermediate CA in the Device certificate should be trusted Register to the correct Rendezvous Service and provide the right host/IP address for IoT Platform during registration (TO0 protocol) Use the private key corresponding to the last public key in Ownership Voucher to sign the messages in TO0 protocol As a supply chain stakeholder: Maintain the Secure Device Onboard Owner signing key pair (private key must be a secret!) System Installer Install Device, Power On Provide Internet connectivity (natively or via helper device). Identify the deployment physical location specifics to the Owner, so the Device can be operated usefully Avoid DoS attacks on the network during Secure Device Onboard IoT Platform Service Provider Device onboarding Runs Secure Device Onboard TO2 protocol Aids in authentication with device by signing the messages with its Owner private key Sends the IoT application specific agents, data and credentials to the device using Secure Device Onboard Provision the device with the right set of application specific credentials for the IoT agent on the device to securely connect and communicate with the IoT platform Configure the firewall and other security properties of the device during onboarding Reconfigure the device with the new Owner key, GUID and Rendezvous Info Maintain the new Owner key for the device and keep the private key a secret","title":"End-to-End Flow"},{"location":"security-best-practices/security-best-practices/#cryptographic-strength","text":"Progress in the fields of computing and cryptography have caused cryptographic strength requirements to increase over time. A cryptographic key that was deployed securely some years ago can be broken today, based on faster and more computers and better techniques. In particular, the emerging field of quantum cryptography provides new tools that can compromise cryptographic keys. Cryptography deployed in Secure Device Onboard meets or exceeds current security requirements expected for the life of this product. Customers are encouraged to track developments in quantum cryptography in order to make intelligent assessments as to their cryptographic requirements on an ongoing basis. Customers are also encouraged to watch for security notifications that indicate new emerging risks.","title":"Cryptographic Strength"},{"location":"security-best-practices/security-best-practices/#end-to-end-security-requirements","text":"This chapter addresses security requirements that are NOT specific to a particular component or role in the entire supply chain.","title":"End-to-End Security Requirements"},{"location":"security-best-practices/security-best-practices/#key-pairs-private-key-protection","text":"The private keys of all key pairs shall be protected throughout the entire supply chain, from the ODM to Cloud Service Provider. At a minimum, all private keys shall be protected at rest, for example, by storing them only on an encrypted file system, hardware security modules (HSM) or a distributed storage vault. Cryptographic keys require strong security at runtime, because they may be exposed to use by software. The Secure Device Onboard Reseller Tool is specifically designed so that it can be deployed with sufficient security for supply chain stakeholders to protect key pair private keys. However, the deployment must still ensure that the hardware and software are deployed safely, as below.","title":"Key Pair\u2019s Private Key Protection"},{"location":"security-best-practices/security-best-practices/#at-rest-protection","text":"At-rest protection means private keys are protected on disk or in the database but held in clear text in memory to perform signing operations. Storing the key in a file system of a machine requires careful procedural controls to ensure that the entire machine is protected from physical and virtual access. When backup procedures of the file system or database are in place, the same procedural controls shall be applied to the backup medium, especially when the medium is Internet accessible (for example, AWS S3 buckets, Google Drive ). Backup of systems through cloud services (for example, Carbonite , BackBlaze ) need additional considerations that might require case-by-case negotiations with the service provider. Memory isolation is therefore important to prevent leakage of keys across applications, containers, or virtual machines. Private key shall never be stored in plaintext Private key shall only be stored on encrypted disk or databases, or in hardware security based storages such as HSM or TPM If the private key is stored in a file or database, its encryption should be anchored in a hardware-based root of trust, such as a trusted platform module (TPM) or crypto tokens, to prevent theft of keys not in use. Applications performing the signing operations should only run on dedicated systems that are not being used for general compute to reduce the risk of side-channel attacks to obtain the keys. The system on which the private key is stored should be physically protected from theft.","title":"At-Rest Protection"},{"location":"security-best-practices/security-best-practices/#runtime-protection","text":"To prevent private key exposure even at runtime, it is recommended to use hardware to isolate and protect keys and key operations from other parts of the system. Crypto tokens, hardware security modules (HSMs), trusted platform modules (TPMs), or processor-assisted technologies, such as Intel \u00ae Platform Trust Technology (Intel \u00ae PTT) or Intel \u00ae Software Guard Extensions (Intel \u00ae SGX), can provide these capabilities. A secure element that is physically affixed to the platform ties keys and the platform together and makes key theft visually evident since the platform will be missing. Runtime environment (including the applications and UI) that is used to access the private key for signing operation shall be restricted to only trusted users and applications. It is highly recommended to log the usage of the key such that it can be audited later in time. Customers must take care, that such cryptographic hardware is only as secure as its deployment. Even a security token that can never export a private key can be exploited if it is physically stolen from the workplace.","title":"Runtime Protection"},{"location":"security-best-practices/security-best-practices/#odmoem-device-manufacturing","text":"This chapter addresses the manufacturing of devices, such as gateways or hardware appliances.","title":"ODM/OEM \u2014 Device Manufacturing"},{"location":"security-best-practices/security-best-practices/#manufacturing-station","text":"The execution of the device initialization handshake is a security sensitive operation. Due to the nature of the handshake process, trust must be provided through physical isolation such as running the manufacturing station environment on a dedicated system and connecting the device over a dedicated network. This is also common best practice for other manufacturing operations such as initial flashing of the BIOS.","title":"Manufacturing Station"},{"location":"security-best-practices/security-best-practices/#manufacturers-public-key","text":"The Manufacturing Station requires holding the manufacturer\u2019s public key. The hash of this key is provisioned in the device during manufacturing and represents the private key that is trusted by the device as an Owner (first owner). This key is also associated with the private key residing in the first instance of the Reseller Tool, typically deployed in the manufacturer\u2019s data center. The public key shall be protected from malicious modification or replacement. During device initialization, an Ownership Voucher containing the first owner\u2019s public key is created by the Manufacturing Station and sent to manufacturer\u2019s Reseller Tool \u2014 the first Reseller Tool in the supply chain. The Manufacturing Station must be protected to prevent an adversary from performing a man-in-the-middle attack and obtaining the device\u2019s true ownership voucher while the Manufacturing Station sends an incorrect but valid ownership voucher to Reseller Tool. The figure above illustrates the relationship between the Reseller Tool and Manufacturing Station.","title":"Manufacturer\u2019s Public Key"},{"location":"security-best-practices/security-best-practices/#secure-device-onboard-database","text":"Secure Device Onboard database contains critical information such as the Device GUID and Rendezvous Info that is provisioned by the Manufacturer\u2019s tool in the device during DI. In addition, it contains the Ownership Vouchers produced during manufacturing. This is not confidential information from Secure Device Onboard security perspective but have business significance. The Secure Device Onboard database shall be protected from access from unauthorized personnel and applications.","title":"Secure Device Onboard Database"},{"location":"security-best-practices/security-best-practices/#device-initialization-network-di-network","text":"The data that is exchanged between the device and manufacturing station during DI protocol shall be protected from modification. Otherwise the device and Ownership Voucher may have incorrect Secure Device Onboard data, which can cause Secure Device Onboard to fail or device to malfunction during installation. Therefore, the DI network between devices and the Manufacturing Station should be used for the sole purpose of providing the device with the software necessary to perform DI (for example, PXE boot) and the DI protocol handshake.","title":"Device Initialization Network (DI Network)"},{"location":"security-best-practices/security-best-practices/#device-manufacturing-with-intel-dal-based-platforms","text":"Hardware platforms using Intel processors such as Intel Atom \u00ae or Intel \u00ae Core\u2122 have a secure DAL \u00ae (Dynamic Application Loader) environment which are all Intel \u00ae EPID enabled and do not require special steps to provision EPID signing keys. As they are also able to run generic operating systems such as Linux*, the device is capable of running a complete application that triggers the device initialization handshake procedure between the to-be-initialized device and a manufacturing station over a network connection. During the DI protocol, the HMAC secret is allocated within the DAL environment of the device. The HMAC used in the Ownership Voucher is generated by the device and transmitted to the Manufacturing Station. The HMAC secret is never revealed, and automatically maintained securely in the device. Other credentials on such as GUID, manufacturer\u2019s public key hash, Rendezvous Info are also protected in a secure storage and runtime environment provided by DAL \u00ae . This is all handled by the Secure Device Onboard DAL applet provided by Intel.","title":"Device Manufacturing with Intel\u00ae DAL\u00ae-based Platforms"},{"location":"security-best-practices/security-best-practices/#device-manufacturing-with-non-intel-or-non-dal-platforms","text":"","title":"Device Manufacturing with Non-Intel or Non-DAL\u00ae Platforms"},{"location":"security-best-practices/security-best-practices/#protection-c-a-i-of-device-ecdsa-key","text":"The ECDSA key must be protected within the Device so that it can be used by the Device, but not revealed outside the Device. Various kinds of devices have different mechanisms for performing this. These include: A secure element or TPM might store the key and perform ECDSA operations The device may have a secure storage area (such as RPMB protected by secure TrustZone) that is only readable on chip. Sometimes this requires that JTAG be disabled The device may have a secure boot with an individual secure boot key, known only to the device. Device secrets, such as the ECDSA key can be encrypted using the secure boot key or its derivation. Some combination of these concepts Encryption alone does not protect the integrity of the ECDSA key. A signature or HMAC mechanism is also needed. Again, specific mechanisms vary by hardware design.","title":"Protection (C, A, I) of Device ECDSA key"},{"location":"security-best-practices/security-best-practices/#protection-c-a-i-of-hmac-secret","text":"HMAC secret should be protected in the same way as the Device key.","title":"Protection (C, A, I) of HMAC secret"},{"location":"security-best-practices/security-best-practices/#protection-ai-of-other-secure-device-onboard-credentials","text":"Other Secure Device Onboard credentials provisioned on the device such as Manufacturer\u2019s Public Key Hash, GUID and Rendezvous Info do not need to be confidential. However, to ensure their integrity, a signature or HMAC (with a protected secret) is needed. Encryption of the credentials may be used if convenient, but encryption by itself does not ensure integrity. These credentials must be available to the device or Secure Device Onboard will fail. Some devices have internal flash regions that cannot be reprogrammed by an attacker, which can improve availability. Secure elements may also have this property in their key protection areas. An OTP memory can contribute to availability and/or integrity of Secure Device Onboard credentials. However, since OTP memory is limited in size, this might limit the ability to use Secure Device Onboard in its \u201cresale\u201d mode. It is acceptable for a Secure Device Onboard Device to be limited in the number of times it can run Secure Device Onboard. In some cases, this might be done to improve device security, by removing the Secure Device Onboard credentials as an attack surface.","title":"Protection (AI) of other Secure Device Onboard Credentials"},{"location":"security-best-practices/security-best-practices/#supply-chain-ownership-voucher-extension","text":"Supply chain members extend Ownership Vouchers. Extension means that the next logical owner\u2019s public key is appended to the current ownership voucher and then signed with the current owner\u2019s private key. For a chain of keys to be valid, the private key\u2019s associated public key was appended in the same fashion by the previous owner. Each key pair in the chain is called an Ownership Voucher Extension (OVE) key pair.","title":"Supply Chain \u2014 Ownership Voucher Extension"},{"location":"security-best-practices/security-best-practices/#ownership-voucher-extension-ove-environment","text":"The OVE environment shall be considered sensitive and part of the business-critical infrastructure. Adequate protection such as data-center access controls, firewalling, multi-tier deployment, and DMZ isolation techniques shall be applied. All RESTful API access SHALL be secured using TLS 1.2 and above. All RESTful API access SHOULD be secured using TLS 1.3 and above. All RESTful API access SHOULD be firewalled and load-balanced. Too many subsequent erroneous requests SHOULD lead to request throttling to reduce DoS attacks. Database backends SHOULD be deployed on separate servers in separate zones. Database connections SHOULD be secured using TLS (have \u201cuseSSL=true&requireSSL=true\" in the connection string). All implementation should use the Secure Device Onboard Reseller Tool to manage Ownership Vouchers, so that rules for Ownership Vouchers are maintained automatically: Ownership Voucher should be extended using the same key type and size as the original Owner public key in the Ownership Voucher header Supply chain stakeholders shall use Ownership Vouchers only to extend for the next Owner and shall not use them to run Secure Device Onboard TO protocols.","title":"Ownership Voucher Extension (OVE) Environment"},{"location":"security-best-practices/security-best-practices/#key-lifetime-agreement","text":"The lifetime of the OVE key pair used for extending an Ownership Voucher SHALL be limited to a reasonable duration or number of ownership extensions. From a supply chain perspective, sending the OVE\u2019s public key to the supplier (along with the order) and receiving one extended Ownership Voucher per ordered device is tightly coupled to the purchase order. The supplier knows how many Ownership Vouchers will be extended for a particular purchase order. The private key shall be kept until the device is purchased by the next owner or the device is retired. The key is needed to extend the Ownership Voucher to the next Owner.","title":"Key Lifetime Agreement"},{"location":"security-best-practices/security-best-practices/#service-provider-owner-implementation","text":"The Secure Device Onboard Owner Implementation is responsible for receiving the final Ownership Voucher in the supply chain and issuing the TO0 protocol to the Rendezvous Server. The owner implementation is typically tightly integrated into the IoT Platform Management service provider\u2019s environment, therefore developed, built, and managed by the provider. It is also the point where the device is logically associated with a particular Management service account. The owner implementation runs in a secured facility such as a data center.","title":"Service Provider \u2014 Owner Implementation"},{"location":"security-best-practices/security-best-practices/#owner-key-pair-usage","text":"The Management service administrator provides the public key to the previous entity in the supply chain. The associated private key is used during the TO0 protocol phase with the Rendezvous Server. Each service account should have individual key pairs. This allows the Management Service to differentiate incoming ownership vouchers by account and to refuse vouchers extended to the wrong account. Private keys shall be protected as mentioned in Section 2.1. If the private key is exposed, (a) adversary devices can be added to an account without authorization, (b) legitimate devices can be added to adversary accounts. Key pair retirement: Private keys have to be available for signing operations until all the associated Ownership Vouchers have been consumed using the TO2 protocol. The Owner may cycle keys so that new Ownership Vouchers use the newer keys, but the old keys are still needed for signing (in the TO0 and TO2 protocols) until all Ownership Vouchers that reference them are processed.","title":"Owner Key Pair Usage"},{"location":"security-best-practices/security-best-practices/#runtime-protection-of-owner-signing-keys","text":"The recommendation is to protect owner signing keys using security hardware. However, in large-scale operations with a significant number of accounts, the number of available hardware-protected keys might be limited. In this case, a two-step process should be deployed. The private key corresponding to the public key exposed to the account owner for ownership extension is protected only at rest. The ownership vouchers extended to that public key are then extended to a second public key where the corresponding private key is located in an HSM. The HSM is used to perform the signing operation for the final TO0 process. Since steps 1 and 2 are performed in temporal proximity, it is exactly known how long the private key is needed since Ownership Vouchers are never extended to the associated public key without performing TO0. The two-step process allows simplified key management and rolling the HSM key pair at a regular basis.","title":"Runtime Protection of Owner Signing Keys"},{"location":"security-best-practices/security-best-practices/#installer-notes","text":"Secure Device Onboard simplifies the onboarding process by eliminating cumbersome manual provisioning. Such form of automation, however, also creates risks of attacks based on social engineering that should be mitigated by proper installation and verification practices.","title":"Installer Notes"},{"location":"security-best-practices/security-best-practices/#verification-of-authenticity-of-devices","text":"Installers shall verify the origin of the devices to be installed. If a device\u2019s origin is not known and the device was exchanged, or tampered with between manufacturing and installation, an adversary can onboard a malicious Secure Device Onboard-enabled device in a target environment without much inside knowledge of the environment. After power-up, the Secure Device Onboard-enabled device would connect to the adversary\u2019s device management service and be under its control.","title":"Verification of Authenticity of Devices"},{"location":"security-best-practices/security-best-practices/#installation-complete-test","text":"The danger of introducing a rogue device into the customer\u2019s network is higher when automatic provisioning (including Secure Device Onboard) is used than when each device is manually configured. Under manual configuration, an attacker needs to compromise a device and a person to install it. Under automatic provisioning, the attacker needs only to compromise the device and fool a trusted person to install it. For example, the attacker can switch boxes. After the onboarding process has completed, the installer should verify that the device is under the control of the expected device management service. For example, by evaluating that the device\u2019s serial number shows up in the management console. Keeping a count of systems physically installed and systems newly seen at the management console is also useful. If the device does not report an onboarding error but cannot be verified in the Management service console, the device should not be left connected.","title":"Installation Complete Test"},{"location":"security-best-practices/security-best-practices/#network-restrictions-at-installation","text":"The following additional measures are useful to prevent a rogue device from successfully operating in a customer environment, and should be implemented whenever feasible: Network authentication for IoT devices. Secure Device Onboard itself may be used to configure the network authentication into trusted (\u201cnon-rogue\u201d) devices. When all devices must be authenticated to the local network in order to function, a rogue device may be unable to connect to its intended (rogue) manager and thus fail to exfiltrate data. Network security for IoT devices that prevents them from arbitrary connection to the Internet. In many cases, IoT devices need only connect to a few sites on the Internet (for example, for software update, device management, data upload). If network access can be restricted to these sites, a rogue device may be restricted from exfiltrating data. These measures overlap in their effectiveness. In some cases, one may be easier to implement than the other. For security measures, the best policy is to implement both; a belt and suspenders back each other up from embarrassing failures.","title":"Network Restrictions at Installation"},{"location":"security-best-practices/security-best-practices/#iot-security-practices-implementation-notes","text":"Secure Device Onboard does not guarantee the security of an IoT device; it just gives a good start. For most of the lifetime of the device, it must secure itself. Indeed, a failure in device security may also allow Secure Device Onboard security to fail. The following best practices are needed to ensure that an IoT device securely implements Secure Device Onboard. In general, these are good security practices that are always recommended. Secure or Verified boot. Ensure that only the desired operating system will load, so expected OS protections are implemented as predicted. Secure the OS and the file system, using one of the many best practices guides available. Secure the Secure Device Onboard programs and data stored on the OS. Deploy the Secure Device Onboard Owner in a protected data-center type environment, where physical and login access is strictly controlled. Protect the keys for the Secure Device Onboard Owner using hardware security (HSM, TPM, and others). Use secure protocols to communicate with IoT devices, and using two-way authentication (from manager to IoT device and IoT device to manager). Use standard protocols (For example, TLS 1.3) and standard implementations, to benefit from the additional security reviews done on them Use the latest versions of these implementations and update them as new ones appear Secure programming practices must be used when implementing Secure Device Onboard components Care must be taken when implementing Secure Device Onboard only to implement the Secure Device Onboard protocols that are needed for this implementation. For example, do not enable the Secure Device Onboard Device protocols for an Secure Device Onboard Owner implementation. Never enable the Secure Device Onboard Device Initialize implementation other than on a Device in manufacturing. EPID revocation information must be updated in a timely manner by Secure Device Onboard Owners. When the Intel\u00ae EPID verification service is used (this is the default), this happens automatically. Secure Device Onboard Devices with a single Trusted Computing Base (no Trusted Execution Environment) must have all the EPID keys in EPID groups only associated with the same product (for example, all keys in EPID groups for a given toaster product, or a given industrial actuator, but no groups with products mixed inside of them). This security practice is useful because Secure Device Onboard EPID authentication is by group membership. If groups contain mixed products, an attacker who penetrates a less valued target (for example, the toaster) may leverage this effort toward a more valued target (for example, a factory with industrial controllers in it). The exception is when Secure Device Onboard is implemented in a trusted execution environment with hardware protection of its own, that is, a separate Trusted Compute Base. In this case, the EPID group may follow the Trusted Compute Base (TCB) for the Secure Device Onboard implementation, and the main execution environment (outside the Trusted Execution Environment) may span many products.","title":"IoT Security Practices, Implementation Notes"},{"location":"supply-chain-tools/keystore-guide/","text":"Introduction \u00b6 Secure Device Onboard enhances the out-of-the-box setup and provisioning experience for connected IoT devices. The SDO reseller toolkit addresses the needs of resellers, manufacturers, and others in the supply chain to transfer ownership of SDO devices. To learn more about SDO, see Overview . Terminology \u00b6 Refer to the Secure Device Onboard Reference page . Reference Documents \u00b6 Refer to the Secure Device Onboard Reference page . Overview \u00b6 The SDO supply chain tools (manufacturer and reseller toolkits) require a key pair to be used to extend the ownership voucher and in the case of elliptic-curve cryptography (ECC)-based devices, to extend the device certificate chain. This key pair must be generated and be made available to the toolkits in either the key store file format or in the hardware key (secure key fob). The file option is typically used for development, test, and evaluation purposes while the hardware key must be used in a production environment. Choose the appropriate method for your situation. This process must be done for each key type you need to support. Key types used in SDO devices include RSA256, ECC256, and ECC384. Depending on the type of devices you plan to support you will need to generate from 1 to 3 key types, each type resulting in a key store file and a set of keys. Step 1: Key Store File Initialization \u00b6 Use the p12init.sh script provided along with the toolkit to generate the key store file. Before use, update the configuration in the file (For example, key store password and certificate validity period). The script can be run directly on a Linux* OS. For Windows* OS, you will need to install the Cygwin* DLL from https://www.cygwin.com/ and run the script from a Cygwin* shell. If running with Cygwin*, be sure to add Java* to your path variable. For example, in a Cygwin* command window: Export Path=\\$PATH:\"/cygdrive/C/program files/java/dk-11/bin\" You should now have a key store file that can be used by the toolkit. You will need to provide the name of this file and the password you used here to the toolkit web service later. Step 2: Hardware Key Initialization \u00b6 Sensitive cryptographic material is handled during the initialization of a hardware key. For this reason, the system used here needs to be secure. the Secure Device onboard project strongly recommends an air-gap system as detailed in Step 3: Prepare an Air-Gap System . The key pair backup must be stored securely where only authorized personnel have access to. Should this key pair be compromised, all active devices initialized with this key pair may be required to be re-initialized with SDO. Step 3: Prepare an Air-Gap System \u00b6 The air-gap system is a machine that is as follows: Has no network interface enabled (wired, wireless, or other such as Bluetooth \u00ae ). Is free from any viruses or malware. Can run the OpenSSL* toolkit. Has a USB* interface. Before the system is taken off the network, download the Yubikey* smart card driver and tools ( https://www.yubico.com/products/services-software/download/smart-card-drivers-tools/ ). Step 4: Setup the Secure Key Fob \u00b6 Use the ykinit.sh script provided along with the toolkit to set up the secure key fob (YubiKey* security key). You will need one YubiKey* security key for each key type you wish to support. Copy this script to the system prepared in Step 3: Prepare an Air-Gap System . Insert a YubiKey* security key into the system. Run the script and select the desired key type. (If running on Windows* OS, you will need to install the Cygwin* to run the script). Make a backup of the output files produced by the script. A backup copy of the key material is useful if any of your key fobs fail. You can use this backup to create a replacement key fob. Be sure to store this copy in a physically secure location that is only accessible by authorized personnel. Use the YubiKey manager to change the pin code on the YubiKey* security key. You will need to specify this pin code to the application later. Example: ykman piv -change-pin For each additional key type (For example, EC256, EC384, RSA2048), repeat steps 2 to 5. One Yubikey* security key is required for each key type. Step 5: Setting up a Secure Key Fob from an Existing Key and Cert \u00b6 Follow the steps in this section to set up a Yubikey* security key from the existing key material. These steps produce a backup Yubikey* security key or an additional Yubikey* security key for use with multiple Toolkit installations where all Toolkits need to use the same key pair. Locate the copies of the crt (refer to the definition at the end of this section) and key files from the original setup process. The following are steps to set up each Yubikey* security key required: ykman piv reset ykman piv import-key --management-key \\<mkey> 9a \\<key file> ykman piv import-certificate --management-key \\<mkey> 9a \\<crt file> Use the YubiKey* manager to change the pin code on the YubiKey* security key: ykman piv change-pin where mkey is the Yubikey* management key (default value is 010203040506070801020304050607080102030405060708) key file = filename containing the private key crt file = filename containing the certificate","title":"Keystore Guide"},{"location":"supply-chain-tools/keystore-guide/#introduction","text":"Secure Device Onboard enhances the out-of-the-box setup and provisioning experience for connected IoT devices. The SDO reseller toolkit addresses the needs of resellers, manufacturers, and others in the supply chain to transfer ownership of SDO devices. To learn more about SDO, see Overview .","title":"Introduction"},{"location":"supply-chain-tools/keystore-guide/#terminology","text":"Refer to the Secure Device Onboard Reference page .","title":"Terminology"},{"location":"supply-chain-tools/keystore-guide/#reference-documents","text":"Refer to the Secure Device Onboard Reference page .","title":"Reference Documents"},{"location":"supply-chain-tools/keystore-guide/#overview","text":"The SDO supply chain tools (manufacturer and reseller toolkits) require a key pair to be used to extend the ownership voucher and in the case of elliptic-curve cryptography (ECC)-based devices, to extend the device certificate chain. This key pair must be generated and be made available to the toolkits in either the key store file format or in the hardware key (secure key fob). The file option is typically used for development, test, and evaluation purposes while the hardware key must be used in a production environment. Choose the appropriate method for your situation. This process must be done for each key type you need to support. Key types used in SDO devices include RSA256, ECC256, and ECC384. Depending on the type of devices you plan to support you will need to generate from 1 to 3 key types, each type resulting in a key store file and a set of keys.","title":"Overview"},{"location":"supply-chain-tools/keystore-guide/#step-1-key-store-file-initialization","text":"Use the p12init.sh script provided along with the toolkit to generate the key store file. Before use, update the configuration in the file (For example, key store password and certificate validity period). The script can be run directly on a Linux* OS. For Windows* OS, you will need to install the Cygwin* DLL from https://www.cygwin.com/ and run the script from a Cygwin* shell. If running with Cygwin*, be sure to add Java* to your path variable. For example, in a Cygwin* command window: Export Path=\\$PATH:\"/cygdrive/C/program files/java/dk-11/bin\" You should now have a key store file that can be used by the toolkit. You will need to provide the name of this file and the password you used here to the toolkit web service later.","title":"Step 1: Key Store File Initialization"},{"location":"supply-chain-tools/keystore-guide/#step-2-hardware-key-initialization","text":"Sensitive cryptographic material is handled during the initialization of a hardware key. For this reason, the system used here needs to be secure. the Secure Device onboard project strongly recommends an air-gap system as detailed in Step 3: Prepare an Air-Gap System . The key pair backup must be stored securely where only authorized personnel have access to. Should this key pair be compromised, all active devices initialized with this key pair may be required to be re-initialized with SDO.","title":"Step 2: Hardware Key Initialization"},{"location":"supply-chain-tools/keystore-guide/#step-3-prepare-an-air-gap-system","text":"The air-gap system is a machine that is as follows: Has no network interface enabled (wired, wireless, or other such as Bluetooth \u00ae ). Is free from any viruses or malware. Can run the OpenSSL* toolkit. Has a USB* interface. Before the system is taken off the network, download the Yubikey* smart card driver and tools ( https://www.yubico.com/products/services-software/download/smart-card-drivers-tools/ ).","title":"Step 3: Prepare an Air-Gap System"},{"location":"supply-chain-tools/keystore-guide/#step-4-setup-the-secure-key-fob","text":"Use the ykinit.sh script provided along with the toolkit to set up the secure key fob (YubiKey* security key). You will need one YubiKey* security key for each key type you wish to support. Copy this script to the system prepared in Step 3: Prepare an Air-Gap System . Insert a YubiKey* security key into the system. Run the script and select the desired key type. (If running on Windows* OS, you will need to install the Cygwin* to run the script). Make a backup of the output files produced by the script. A backup copy of the key material is useful if any of your key fobs fail. You can use this backup to create a replacement key fob. Be sure to store this copy in a physically secure location that is only accessible by authorized personnel. Use the YubiKey manager to change the pin code on the YubiKey* security key. You will need to specify this pin code to the application later. Example: ykman piv -change-pin For each additional key type (For example, EC256, EC384, RSA2048), repeat steps 2 to 5. One Yubikey* security key is required for each key type.","title":"Step 4: Setup the Secure Key Fob"},{"location":"supply-chain-tools/keystore-guide/#step-5-setting-up-a-secure-key-fob-from-an-existing-key-and-cert","text":"Follow the steps in this section to set up a Yubikey* security key from the existing key material. These steps produce a backup Yubikey* security key or an additional Yubikey* security key for use with multiple Toolkit installations where all Toolkits need to use the same key pair. Locate the copies of the crt (refer to the definition at the end of this section) and key files from the original setup process. The following are steps to set up each Yubikey* security key required: ykman piv reset ykman piv import-key --management-key \\<mkey> 9a \\<key file> ykman piv import-certificate --management-key \\<mkey> 9a \\<crt file> Use the YubiKey* manager to change the pin code on the YubiKey* security key: ykman piv change-pin where mkey is the Yubikey* management key (default value is 010203040506070801020304050607080102030405060708) key file = filename containing the private key crt file = filename containing the certificate","title":"Step 5: Setting up a Secure Key Fob from an Existing Key and Cert"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/","text":"Introduction \u00b6 Secure Device Onboard (SDO) enhances the out-of-the-box setup and provisioning experience for connected IoT devices. The Secure Device Onboard project provides the manufacturer toolkit and reseller toolkit for manufacturers (OEMs, ODMs, or 3rd party integrators) to enable SDO on their devices. This document details how a manufacturer can use these tools to produce an SDO-enabled device. Terminology \u00b6 Refer to the Secure Device Onboard Reference page . Related Documents \u00b6 Your role as a supply chain integrator is combined with solutions implemented by manufacturers and device management service providers to enable a complete end-to-end experience. For more information, refer to the Secure Device Onboard Reference page . Overview \u00b6 To produce Secure Device Onboard (SDO)-enabled devices, a manufacturer must run the SDO device initialization (DI) protocol on the device. The DI process sets security credentials in secure storage in the device and creates the initial ownership voucher. The manufacturer makes use of the provided tools for this process: a manufacturer toolkit, an SDO Database, and software that runs on the device to perform DI. The manufacturer toolkit acts as a DI server for the devices. After running DI on the device, the resulting ownership voucher is stored in the SDO Database. At this point, the SDO security credentials have been stored in the device and the device is SDO ready. When the device is sold to a customer, the ownership voucher is extended and shipped along with the device. A complete integration and deployment of SDO in a manufacturing environment requires a fair amount of planning and effort. However, for development, test, and enabling purposes, a much simpler evaluation deployment can be done. Manufacturer Toolkit \u00b6 The main function of the manufacturer toolkit is to serve as a DI protocol server. The manufacturer toolkit runs as a web service and makes use of the SDO Database for configuration and storage of ownership vouchers. All configuration and data for the manufacturer toolkit is stored in the SDO Database. Views are used to read data while stored procedures are used to update the configuration. The following figure shows an overview of the SDO database. Figure 1. An Overview of the SDO Database Evaluation Deployment \u00b6 The evaluation deployment is useful for development, test, and enabling purposes. The evaluation deployment can fully initialize a device to the same extent as the production deployment but does not require any integration with business systems nor the setup of a secure key fob. Step 1: Prepare Hardware Infrastructure \u00b6 You need to have one machine that can run the manufacturer toolkit as well as host the Secure Device Onboard (SDO) database. A non-production environment has minimal requirements; the machine can run either the Linux* OS (version 18.04) or Windows* 10 OS. Step 2: Deploy Database and Toolkit \u00b6 Install the SDO database and toolkit, see Database and Toolkit Installation . It is recommended to choose the key store file option unless there is a specified need to test with a secure key fob. Step 3: Test \u00b6 Set up the device to run the SDO DI protocol (refer to device specific documentation for details). Run DI on the device against the manufacturer toolkit web service. Use the database view to query the device state and verification completion of the DI. Production Deployment \u00b6 Step 1: Integrate with Business System Processes \u00b6 Producing Secure Device Onboard (SDO)-enabled devices requires integration with your business systems and manufacturing processes. Your business system processes need to: Manage SDO public key(s) from customers, and the public key(s) storage in the SDO database. SDO requires the customer\u2019s SDO public key. Your customer interactions and processes must be modified as required to support this receipt of their public key and then to import this key into the SDO Database. See Import Customer Public Key . Whether this key is delivered with each order or done before separately depends on your processes and interaction with your customers. Manage ownership vouchers sent to customers. After a device is initialized with SDO, an initial ownership voucher is produced and stored in the SDO Database. This voucher must first be \u201csigned\u201d to a customer before sending to the customer. The ownership voucher management task has the following two steps: Assign a voucher (device) to a customer (technically, a customer public key) See Assign Device (Voucher) to Customer . Perform voucher extension. The resulting extended voucher can then be sent to the customer. The following are the implied requirements: It is assumed that you already have some way to track which device was shipped with which order. Most likely, this was done with serial numbers. With SDO, there is an additional requirement that you must match voucher(s) with physical devices such that the voucher(s) delivered to the customer are those that correspond to the actual physical devices that are delivered. You need to update or modify the existing B2B channel to include an ownership voucher for each physical device delivered to the customer. Typically, these vouchers would be linked to the order in a particular way, but the details will vary for each manufacturer. If a customer loses one of these vouchers and requires a replacement, then you must re-generate this voucher or retrieve the voucher from the device or order data if you choose to store the extended voucher with the device or order data. The following figure shows a typical usage scenario between your business systems and the SDO tools. The order and timing of each sequence may vary with your manufacturing, ordering, and inventory management processes. The only firm requirement is that Seq 1 and Seq 2 happens before Seq 3. Figure 2. A Typical Usage Scenario between Business Systems and SDO Tools Step 1.1: Device Serial Number \u00b6 SDO requires the correct ownership voucher to be delivered with each physical device. Therefore, an identifier that is present on the physical device, for example the serial number, can be used. Scanning an identifier on the physical device allows for the correct voucher to be selected (if an incorrect voucher is delivered, SDO will fail later in the supply chain when run). If, for example, the serial number is already known, the correct physical device can be selected. The same identifier must also be used when running the DI because the identifier is used as an index when storing vouchers in the SDO Database, and later when identifying vouchers. Step 1.2: Customer Descriptor \u00b6 A customer descriptor is used when importing customer public keys and assigning a voucher to a customer. This descriptor is a string value that must uniquely identify the customer. It is up to you, the manufacturer, to form this value. Duplicates are to be avoided because this value would be used when importing public keys and extending ownership vouchers. Step 1.3: Deploy for Multiple Key Types \u00b6 If you, as a manufacturer, produces both the Rivest\u2013Shamir\u2013Adleman (RSA)- and elliptic-curve cryptography (ECC)-based devices, you will need to support two different key types. However, because of the limitations of the secure key fob (For example, Yubikey*), the deployment of multiple key types requires that multiple secure key fobs, each with one type of key pair, be used. The following figure shows a usage example. Figure 3. An Example of Using Two Different Key Types Step 1.4: Deploy for Multiple Manufacturing Stations \u00b6 If you are manufacturing SDO devices at multiple geographic locations, then you will need to consider how best to deploy the SDO Manufacturer Toolkit. A typical option is shown below. Install the toolkit and an SDO Database at each location \u2013 both at the remote GEOs as well as the central location. Each manufacturing GEO performs device initialization while the central location performs the Ownership Voucher extension. A data collection process is periodically invoked to collect data from each GEO\u2019s SDO Database and import it into the central SDO Database. Step 2: Prepare Hardware Infrastructure \u00b6 You need to acquire and put into place the following: A system to host the manufacturer toolkit and SDO Database A private network to attach devices to the manufacturer toolkit Secure key fob(s) The following tables list the hardware infrastructure for Linux*- and Windows*-based manufacturer toolkits, respectively. Table 3. Linux* OS-based Manufacturer Toolkit Item Specification Connectivity Two Ethernet networks: one to connect to the IoT device and a separate network to connect to the backend to provide access to voucher data and the voucher extension operation. Secure Key Fobs YubiKey* security key (see https://www.yubico.com/products/yubikey-hardware/ ) Operating System Ubuntu* OS version 16.x or 18.x Software Java* Runtime Environment (JRE) software version 11 Oracle* software ( http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html ) or OpenJDK* ( http://openjdk.java.net/install/index.html ) \u00b7 Apache Tomcat* ( http://tomcat.apache.org/ ) software version 8 or later \u00b7 MariaDB* ( https://mariadb.org/ ) server version 10.4 or later Table 4. Windows* OS-based Manufacturer Toolkit Item Specification Connectivity Two Ethernet networks: one to connect to the IoT device and a separate network to connect to the backend to provide access to voucher data and the voucher extension operation. Secure Key Fobs YubiKey* security key (see https://www.yubico.com/products/yubikey-hardware/ ) Operating System Windows* 10 OS or Windows Server* OS version 2012 R2 or later, 64-bit version. Software Java Runtime Environment (JRE) software version 11 Oracle* software ( http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html ) or OpenJDK ( http://openjdk.java.net/install/index.html ) \u00b7 Apache Tomcat* ( http://tomcat.apache.org/ ) software version 8 or later \u00b7 MariaDB* ( https://mariadb.org/ ) server version 10.4 or later \u00b7 OpenSC Utilities ( https://github.com/OpenSC/OpenSC/releases/download/0.17.0/OpenSC-0.17.0-win64_vs12-Release.msi . After the installation, you will find the following DLL file installed: C:\\windows\\system32\\opensc-pkcs11.dll Step 3: Deploy Database and Manufacturer Toolkit \u00b6 Install the SDO database and toolkit, see Database and Toolkit Installation . Be sure to use the secure key fob option for the key storage. Step 4: Validate with Test Device \u00b6 Set up an SDO-capable device to run the SDO DI protocol (see Device DI Setup ). Run DI on the device against the manufacturer toolkit web service. Use the database view to query the device state and verify the completion of DI. Database and Toolkit Installation \u00b6 You can either use the Docker* script provided or deploy manually. Setup: Docker* Script \u00b6 The Docker* script requires a key store file containing the manufacturer keys. See Supply Chain Tools Key Store Setup Guide for details. For the remaining setup, follow the instructions in the readme file in the SDO Docker directory. Setup: Manual \u00b6 For the following steps, run as root or use sudo. Install the MariaDB* server from https://mariadb.org/ . For each of the following commands, use the \u2018root\u2019 user you defined in step 2 where you installed the MariaDB* server and run each script on the machine where the MariaDB* server is installed. You\u2019ll find the scripts in both the source (scripts/mysql) and binary (docker_*) files of the release. Edit rt_config.sql and mt_config.sql as directed by the comments in each file. (These files are located in the sources of the SDO release package under /SupplyChainTools/scripts/mysql or /SupplyChainTools/scripts/sqlserver). Run the rt_create.sql script: mysql -u <username> -p < rt_create.sql Run the mt_create.sql script: mysql -u <username> -p < mt_create.sql Run the rt_config.sql script: mysql -u <username> -p < rt_config.sql Run the mt_config.sql script: mysql -u <username> -p < mt_config.sql Create a key store containing the manufacturer keys. See Supply Chain Tools Key Store Setup Guide for details. Set up and deploy the toolkit web service. If this is an evaluation deployment, you have an option to run the web service directly from the command line. If you choose to do this, instructions are provided in the readme file included with the toolkit software. Follow those instructions. You can verify that the toolkit starts up correctly by looking at the output in the window where you ran the toolkit. Installation is then complete, and you can skip the following steps. For example, if running directly: java -Dspring.datasource.url=\"jdbc:mariadb://localhost:3306/sdo\" -Dspring.datasource.username=sdo_admin -Dspring.datasource.password=sdo -Dsdo.keystore=\"file:///sdo.p12\" -Dsdo.keystore.password=123456 -jar ./manufacturer-webapp-1.8.war Install the Apache Tomcat* software from http://tomcat.apache.org/ or equivalent. Update the listener port. Most likely this will be 8039 as the default for SDO Clients but this may vary because of your specific network environment. For example, with Apache Tomcat* version 8 on the Linux* machine, this setting can be found in var/lib/tomcat8/config/server.xml. Refer to the documentation specific to your Apache Tomcat* version and operating system. Copy the manufacturer toolkit war file into the Apache Tomcat* webapps directory (on the Linux* machine this would typically be /var/lib/tomcat8/webapps). Rename the war file to ROOT.war. Start the Apache Tomcat* service. This will trigger the Apache Tomcat* software to unpack the war file and create individual files in the webapps/ROOT directory. Add the remaining toolkit configuration for Apache Tomcat* (see the readme file included with the toolkit software for further details). For Apache Tomcat* version 8 running on the Linux machine, these settings are located in /var/lib/tomcat/webapps/ROOT/WEB-INF/classes/application.properties. An example is given as follows: spring.datasource.url=jdbc:mariadb://localhost:3306/sdo?useSSL=false spring.datasource.username=sdo_admin spring.datasource.password=sdo sdo.keystore=file:///var/lib/tomcat8/webapps/ROOT/sdo.p12 sdo.keystore.password=123456 Note: The database user and password should match those configured in rt_config.sql. datasource.url: be sure to use localhost rather than the IP address. sdo.keystore: this is either the pathname to the software key store (jks) or to the public key cryptography standards (PKCS#11) library if using secure key fob. Be sure to not use quotes around the value. sdo.keystore.password: this is the password for the software key store or the pin code of the secure key fob. Start or restart the Apache Tomcat* service. Test with the status page: http:// /api/v1/status. If the page does not load, look at the Apache Tomcat* logs to debug any errors. Setup: Troubleshooting \u00b6 Troubleshoot using the following steps if the toolkit web service does not start correctly: Verify that the JDBC* string is correct. An example is: jdbc:mariadb://localhost:3306/sdo. Be sure MariaDB* is included, the port is specified as 3306, and the host name is correct. Verify that the database user and password are correct. The user and password should be the same as those defined in rt_config.sql. You may wish to use some third-party database tool to log into the database to test that the user and password are correct. Verify the server settings Look at mt_config.sql and verify that the rendezvous info and validity intervals are specified. If the rendezvous info and validity intervals are not specified, the web service will not start up. Look at the Apache Tomcat* log (or run the web service from the command line and look at the output). The log messages will indicate the error. Usage Scenario \u00b6 Verify Device Initialization (DI) \u00b6 To determine the state of a device or devices, the database view, v_mt_device_state, is available. Data can be retrieved programmatically with a third-party database tool or through the command line: mysql -u <username> -p -h <SDO database server hostname or ip> -e \u201cuse sdo; select * from v_mt_device_state\u201d Import Customer Public Key \u00b6 Import the customer public key by calling the rt_add_customer_public_key stored procedure. In a production environment, the import would likely be invoked programmatically. For test, development, or evaluation purposes, run from the command line as follows: mysql -u <username> -p -h <SDO database server hostname or ip> -e \u201cuse sdo; call rt_add_customer_public_key('CUST_DIST_12345', '-----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCqGKukO1De7zhZj6+H0qtjTkVxwTCpvKe4eCZ0 FPqri0cb2JZfXJ/DgYSF6vUpwmJG8wVQZKjeGcjDOL5UlsuusFncCzWBQ7RKNUSesmQRMSGkVb1/ 3j+skZ6UtW+5u09lHNsj6tQ51s1SPrCBkedbNf0Tp0GbMJDyR4e9T04ZZwIDAQAB -----END PUBLIC KEY-----\u2019)\u201d Note Be sure this is the public key pem and not the certificate pem. The public key can be extracted from the certificate with OpenSSL*: openssl x509 -pubkey -noout -in <cert file>.pem > <pubkey>.pem Assign Device (Voucher) to Customer \u00b6 Assign the device (voucher) by calling the rt_assign_device_to_customer stored procedure. In a production environment, the assignment would likely be invoked programmatically. For test, development, or evaluation purposes, run from the command line as follows: mysql -u <username> -p -h <SDO database server hostname or ip> -e \u201cuse sdo; call rt_assign_device_to_customer(\u2018SN12345678\u2019, \u2019CUST_DIST_12345\u2019)\u201d Extend Ownership Voucher \u00b6 Ownership voucher is extended through the REST API. In a production environment, the extension would be done programmatically. For test purposes, you can use curl to invoke the extension: curl -X GET http://<mfr toolkit ip>:<PORT>/api/v1/vouchers/<device serial no> The result will be the extended voucher. Testing with an SDO Device \u00b6 Any device that can run the SDO DI protocol can be used to perform an end-to-end test of the Manufacturing Toolkit. If an SDO device is not available, then the SDO PRI Device can be used. This is a Java based Device Simulator that can run anywhere Java is supported. Please refer to the readme in the PRI directory of the SDO release package for details on how to run this device. Regardless of which device is used, care must be taken when specifying the value of the device m-string in the DI protocol. See next section for details. Device m-string \u00b6 The m-string is used to provide device-specific information that is used to manage ownership vouchers. The m-string must be present and cannot be empty (the manufacturer toolkit will output an error in such case). In the development, test, or enablement environment, any non-empty value can be used (For example, \u201cdeviceA\u201d or \u201cdeviceB\u201d). The manufacturer toolkit will take the entire m value as the device serial number. For the production environment, creating the m-string value is complex, therefore, it is recommended to use a script to generate the value. The m-string is a base 64-encoded set of null terminated string values as follows: <key type identifier><null-1><serial number><null-2><model number>[<null-3><CSR>] where: <null> translates to value 0x00 <null-1> and <null-2> are mandatory Key type identifier = 1 | 13 | 14 1 = RSA256, 13 = ECC256, 14 = ECC384 Identifies the type of cryptography used on the device. They key type used to extend ownership vouchers must match this type. Serial number = device serial number The serial number should uniquely identify the device and ideally, should be present on the device itself (such as, the label). It is used to correlate the device with its associated ownership voucher by manufacturers and resellers when shipping devices. Model number = device model number The model number should identify the type of device model. This data is not strictly required and can be empty if desired. CSR = certificate signing request. The CSR is optional and is only required for ECC devices. is required only if the CSR is included. The format of the CSR should be base 64-encoded public key cryptography standards (PKCS#10) in privacy-enhanced mail (PEM) format. An example of how to generate the m-string value is given below. This can be leveraged to programmatically generate the sdo_di -mi arg. $ echo -ne '1\\0serial\\0model' | base64 MQBzZXJpYWwAbW9kZWw= And a demonstration of what\u2019s in the encoding: $ echo -ne '1\\0serial\\0model' | base64 | base64 -d | xxd","title":"Manufacturing Tools"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#introduction","text":"Secure Device Onboard (SDO) enhances the out-of-the-box setup and provisioning experience for connected IoT devices. The Secure Device Onboard project provides the manufacturer toolkit and reseller toolkit for manufacturers (OEMs, ODMs, or 3rd party integrators) to enable SDO on their devices. This document details how a manufacturer can use these tools to produce an SDO-enabled device.","title":"Introduction"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#terminology","text":"Refer to the Secure Device Onboard Reference page .","title":"Terminology"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#related-documents","text":"Your role as a supply chain integrator is combined with solutions implemented by manufacturers and device management service providers to enable a complete end-to-end experience. For more information, refer to the Secure Device Onboard Reference page .","title":"Related Documents"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#overview","text":"To produce Secure Device Onboard (SDO)-enabled devices, a manufacturer must run the SDO device initialization (DI) protocol on the device. The DI process sets security credentials in secure storage in the device and creates the initial ownership voucher. The manufacturer makes use of the provided tools for this process: a manufacturer toolkit, an SDO Database, and software that runs on the device to perform DI. The manufacturer toolkit acts as a DI server for the devices. After running DI on the device, the resulting ownership voucher is stored in the SDO Database. At this point, the SDO security credentials have been stored in the device and the device is SDO ready. When the device is sold to a customer, the ownership voucher is extended and shipped along with the device. A complete integration and deployment of SDO in a manufacturing environment requires a fair amount of planning and effort. However, for development, test, and enabling purposes, a much simpler evaluation deployment can be done.","title":"Overview"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#manufacturer-toolkit","text":"The main function of the manufacturer toolkit is to serve as a DI protocol server. The manufacturer toolkit runs as a web service and makes use of the SDO Database for configuration and storage of ownership vouchers. All configuration and data for the manufacturer toolkit is stored in the SDO Database. Views are used to read data while stored procedures are used to update the configuration. The following figure shows an overview of the SDO database. Figure 1. An Overview of the SDO Database","title":"Manufacturer Toolkit"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#evaluation-deployment","text":"The evaluation deployment is useful for development, test, and enabling purposes. The evaluation deployment can fully initialize a device to the same extent as the production deployment but does not require any integration with business systems nor the setup of a secure key fob.","title":"Evaluation Deployment"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#step-1-prepare-hardware-infrastructure","text":"You need to have one machine that can run the manufacturer toolkit as well as host the Secure Device Onboard (SDO) database. A non-production environment has minimal requirements; the machine can run either the Linux* OS (version 18.04) or Windows* 10 OS.","title":"Step 1: Prepare Hardware Infrastructure"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#step-2-deploy-database-and-toolkit","text":"Install the SDO database and toolkit, see Database and Toolkit Installation . It is recommended to choose the key store file option unless there is a specified need to test with a secure key fob.","title":"Step 2: Deploy Database and Toolkit"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#step-3-test","text":"Set up the device to run the SDO DI protocol (refer to device specific documentation for details). Run DI on the device against the manufacturer toolkit web service. Use the database view to query the device state and verification completion of the DI.","title":"Step 3: Test"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#production-deployment","text":"","title":"Production Deployment"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#step-1-integrate-with-business-system-processes","text":"Producing Secure Device Onboard (SDO)-enabled devices requires integration with your business systems and manufacturing processes. Your business system processes need to: Manage SDO public key(s) from customers, and the public key(s) storage in the SDO database. SDO requires the customer\u2019s SDO public key. Your customer interactions and processes must be modified as required to support this receipt of their public key and then to import this key into the SDO Database. See Import Customer Public Key . Whether this key is delivered with each order or done before separately depends on your processes and interaction with your customers. Manage ownership vouchers sent to customers. After a device is initialized with SDO, an initial ownership voucher is produced and stored in the SDO Database. This voucher must first be \u201csigned\u201d to a customer before sending to the customer. The ownership voucher management task has the following two steps: Assign a voucher (device) to a customer (technically, a customer public key) See Assign Device (Voucher) to Customer . Perform voucher extension. The resulting extended voucher can then be sent to the customer. The following are the implied requirements: It is assumed that you already have some way to track which device was shipped with which order. Most likely, this was done with serial numbers. With SDO, there is an additional requirement that you must match voucher(s) with physical devices such that the voucher(s) delivered to the customer are those that correspond to the actual physical devices that are delivered. You need to update or modify the existing B2B channel to include an ownership voucher for each physical device delivered to the customer. Typically, these vouchers would be linked to the order in a particular way, but the details will vary for each manufacturer. If a customer loses one of these vouchers and requires a replacement, then you must re-generate this voucher or retrieve the voucher from the device or order data if you choose to store the extended voucher with the device or order data. The following figure shows a typical usage scenario between your business systems and the SDO tools. The order and timing of each sequence may vary with your manufacturing, ordering, and inventory management processes. The only firm requirement is that Seq 1 and Seq 2 happens before Seq 3. Figure 2. A Typical Usage Scenario between Business Systems and SDO Tools","title":"Step 1: Integrate with Business System Processes"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#step-11-device-serial-number","text":"SDO requires the correct ownership voucher to be delivered with each physical device. Therefore, an identifier that is present on the physical device, for example the serial number, can be used. Scanning an identifier on the physical device allows for the correct voucher to be selected (if an incorrect voucher is delivered, SDO will fail later in the supply chain when run). If, for example, the serial number is already known, the correct physical device can be selected. The same identifier must also be used when running the DI because the identifier is used as an index when storing vouchers in the SDO Database, and later when identifying vouchers.","title":"Step 1.1: Device Serial Number"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#step-12-customer-descriptor","text":"A customer descriptor is used when importing customer public keys and assigning a voucher to a customer. This descriptor is a string value that must uniquely identify the customer. It is up to you, the manufacturer, to form this value. Duplicates are to be avoided because this value would be used when importing public keys and extending ownership vouchers.","title":"Step 1.2: Customer Descriptor"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#step-13-deploy-for-multiple-key-types","text":"If you, as a manufacturer, produces both the Rivest\u2013Shamir\u2013Adleman (RSA)- and elliptic-curve cryptography (ECC)-based devices, you will need to support two different key types. However, because of the limitations of the secure key fob (For example, Yubikey*), the deployment of multiple key types requires that multiple secure key fobs, each with one type of key pair, be used. The following figure shows a usage example. Figure 3. An Example of Using Two Different Key Types","title":"Step 1.3: Deploy for Multiple Key Types"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#step-14-deploy-for-multiple-manufacturing-stations","text":"If you are manufacturing SDO devices at multiple geographic locations, then you will need to consider how best to deploy the SDO Manufacturer Toolkit. A typical option is shown below. Install the toolkit and an SDO Database at each location \u2013 both at the remote GEOs as well as the central location. Each manufacturing GEO performs device initialization while the central location performs the Ownership Voucher extension. A data collection process is periodically invoked to collect data from each GEO\u2019s SDO Database and import it into the central SDO Database.","title":"Step 1.4: Deploy for Multiple Manufacturing Stations"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#step-2-prepare-hardware-infrastructure","text":"You need to acquire and put into place the following: A system to host the manufacturer toolkit and SDO Database A private network to attach devices to the manufacturer toolkit Secure key fob(s) The following tables list the hardware infrastructure for Linux*- and Windows*-based manufacturer toolkits, respectively. Table 3. Linux* OS-based Manufacturer Toolkit Item Specification Connectivity Two Ethernet networks: one to connect to the IoT device and a separate network to connect to the backend to provide access to voucher data and the voucher extension operation. Secure Key Fobs YubiKey* security key (see https://www.yubico.com/products/yubikey-hardware/ ) Operating System Ubuntu* OS version 16.x or 18.x Software Java* Runtime Environment (JRE) software version 11 Oracle* software ( http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html ) or OpenJDK* ( http://openjdk.java.net/install/index.html ) \u00b7 Apache Tomcat* ( http://tomcat.apache.org/ ) software version 8 or later \u00b7 MariaDB* ( https://mariadb.org/ ) server version 10.4 or later Table 4. Windows* OS-based Manufacturer Toolkit Item Specification Connectivity Two Ethernet networks: one to connect to the IoT device and a separate network to connect to the backend to provide access to voucher data and the voucher extension operation. Secure Key Fobs YubiKey* security key (see https://www.yubico.com/products/yubikey-hardware/ ) Operating System Windows* 10 OS or Windows Server* OS version 2012 R2 or later, 64-bit version. Software Java Runtime Environment (JRE) software version 11 Oracle* software ( http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html ) or OpenJDK ( http://openjdk.java.net/install/index.html ) \u00b7 Apache Tomcat* ( http://tomcat.apache.org/ ) software version 8 or later \u00b7 MariaDB* ( https://mariadb.org/ ) server version 10.4 or later \u00b7 OpenSC Utilities ( https://github.com/OpenSC/OpenSC/releases/download/0.17.0/OpenSC-0.17.0-win64_vs12-Release.msi . After the installation, you will find the following DLL file installed: C:\\windows\\system32\\opensc-pkcs11.dll","title":"Step 2: Prepare Hardware Infrastructure"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#step-3-deploy-database-and-manufacturer-toolkit","text":"Install the SDO database and toolkit, see Database and Toolkit Installation . Be sure to use the secure key fob option for the key storage.","title":"Step 3: Deploy Database and Manufacturer Toolkit"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#step-4-validate-with-test-device","text":"Set up an SDO-capable device to run the SDO DI protocol (see Device DI Setup ). Run DI on the device against the manufacturer toolkit web service. Use the database view to query the device state and verify the completion of DI.","title":"Step 4: Validate with Test Device"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#database-and-toolkit-installation","text":"You can either use the Docker* script provided or deploy manually.","title":"Database and Toolkit Installation"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#setup-docker-script","text":"The Docker* script requires a key store file containing the manufacturer keys. See Supply Chain Tools Key Store Setup Guide for details. For the remaining setup, follow the instructions in the readme file in the SDO Docker directory.","title":"Setup: Docker* Script"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#setup-manual","text":"For the following steps, run as root or use sudo. Install the MariaDB* server from https://mariadb.org/ . For each of the following commands, use the \u2018root\u2019 user you defined in step 2 where you installed the MariaDB* server and run each script on the machine where the MariaDB* server is installed. You\u2019ll find the scripts in both the source (scripts/mysql) and binary (docker_*) files of the release. Edit rt_config.sql and mt_config.sql as directed by the comments in each file. (These files are located in the sources of the SDO release package under /SupplyChainTools/scripts/mysql or /SupplyChainTools/scripts/sqlserver). Run the rt_create.sql script: mysql -u <username> -p < rt_create.sql Run the mt_create.sql script: mysql -u <username> -p < mt_create.sql Run the rt_config.sql script: mysql -u <username> -p < rt_config.sql Run the mt_config.sql script: mysql -u <username> -p < mt_config.sql Create a key store containing the manufacturer keys. See Supply Chain Tools Key Store Setup Guide for details. Set up and deploy the toolkit web service. If this is an evaluation deployment, you have an option to run the web service directly from the command line. If you choose to do this, instructions are provided in the readme file included with the toolkit software. Follow those instructions. You can verify that the toolkit starts up correctly by looking at the output in the window where you ran the toolkit. Installation is then complete, and you can skip the following steps. For example, if running directly: java -Dspring.datasource.url=\"jdbc:mariadb://localhost:3306/sdo\" -Dspring.datasource.username=sdo_admin -Dspring.datasource.password=sdo -Dsdo.keystore=\"file:///sdo.p12\" -Dsdo.keystore.password=123456 -jar ./manufacturer-webapp-1.8.war Install the Apache Tomcat* software from http://tomcat.apache.org/ or equivalent. Update the listener port. Most likely this will be 8039 as the default for SDO Clients but this may vary because of your specific network environment. For example, with Apache Tomcat* version 8 on the Linux* machine, this setting can be found in var/lib/tomcat8/config/server.xml. Refer to the documentation specific to your Apache Tomcat* version and operating system. Copy the manufacturer toolkit war file into the Apache Tomcat* webapps directory (on the Linux* machine this would typically be /var/lib/tomcat8/webapps). Rename the war file to ROOT.war. Start the Apache Tomcat* service. This will trigger the Apache Tomcat* software to unpack the war file and create individual files in the webapps/ROOT directory. Add the remaining toolkit configuration for Apache Tomcat* (see the readme file included with the toolkit software for further details). For Apache Tomcat* version 8 running on the Linux machine, these settings are located in /var/lib/tomcat/webapps/ROOT/WEB-INF/classes/application.properties. An example is given as follows: spring.datasource.url=jdbc:mariadb://localhost:3306/sdo?useSSL=false spring.datasource.username=sdo_admin spring.datasource.password=sdo sdo.keystore=file:///var/lib/tomcat8/webapps/ROOT/sdo.p12 sdo.keystore.password=123456 Note: The database user and password should match those configured in rt_config.sql. datasource.url: be sure to use localhost rather than the IP address. sdo.keystore: this is either the pathname to the software key store (jks) or to the public key cryptography standards (PKCS#11) library if using secure key fob. Be sure to not use quotes around the value. sdo.keystore.password: this is the password for the software key store or the pin code of the secure key fob. Start or restart the Apache Tomcat* service. Test with the status page: http:// /api/v1/status. If the page does not load, look at the Apache Tomcat* logs to debug any errors.","title":"Setup: Manual"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#setup-troubleshooting","text":"Troubleshoot using the following steps if the toolkit web service does not start correctly: Verify that the JDBC* string is correct. An example is: jdbc:mariadb://localhost:3306/sdo. Be sure MariaDB* is included, the port is specified as 3306, and the host name is correct. Verify that the database user and password are correct. The user and password should be the same as those defined in rt_config.sql. You may wish to use some third-party database tool to log into the database to test that the user and password are correct. Verify the server settings Look at mt_config.sql and verify that the rendezvous info and validity intervals are specified. If the rendezvous info and validity intervals are not specified, the web service will not start up. Look at the Apache Tomcat* log (or run the web service from the command line and look at the output). The log messages will indicate the error.","title":"Setup: Troubleshooting"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#usage-scenario","text":"","title":"Usage Scenario"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#verify-device-initialization-di","text":"To determine the state of a device or devices, the database view, v_mt_device_state, is available. Data can be retrieved programmatically with a third-party database tool or through the command line: mysql -u <username> -p -h <SDO database server hostname or ip> -e \u201cuse sdo; select * from v_mt_device_state\u201d","title":"Verify Device Initialization (DI)"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#import-customer-public-key","text":"Import the customer public key by calling the rt_add_customer_public_key stored procedure. In a production environment, the import would likely be invoked programmatically. For test, development, or evaluation purposes, run from the command line as follows: mysql -u <username> -p -h <SDO database server hostname or ip> -e \u201cuse sdo; call rt_add_customer_public_key('CUST_DIST_12345', '-----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCqGKukO1De7zhZj6+H0qtjTkVxwTCpvKe4eCZ0 FPqri0cb2JZfXJ/DgYSF6vUpwmJG8wVQZKjeGcjDOL5UlsuusFncCzWBQ7RKNUSesmQRMSGkVb1/ 3j+skZ6UtW+5u09lHNsj6tQ51s1SPrCBkedbNf0Tp0GbMJDyR4e9T04ZZwIDAQAB -----END PUBLIC KEY-----\u2019)\u201d Note Be sure this is the public key pem and not the certificate pem. The public key can be extracted from the certificate with OpenSSL*: openssl x509 -pubkey -noout -in <cert file>.pem > <pubkey>.pem","title":"Import Customer Public Key"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#assign-device-voucher-to-customer","text":"Assign the device (voucher) by calling the rt_assign_device_to_customer stored procedure. In a production environment, the assignment would likely be invoked programmatically. For test, development, or evaluation purposes, run from the command line as follows: mysql -u <username> -p -h <SDO database server hostname or ip> -e \u201cuse sdo; call rt_assign_device_to_customer(\u2018SN12345678\u2019, \u2019CUST_DIST_12345\u2019)\u201d","title":"Assign Device (Voucher) to Customer"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#extend-ownership-voucher","text":"Ownership voucher is extended through the REST API. In a production environment, the extension would be done programmatically. For test purposes, you can use curl to invoke the extension: curl -X GET http://<mfr toolkit ip>:<PORT>/api/v1/vouchers/<device serial no> The result will be the extended voucher.","title":"Extend Ownership Voucher"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#testing-with-an-sdo-device","text":"Any device that can run the SDO DI protocol can be used to perform an end-to-end test of the Manufacturing Toolkit. If an SDO device is not available, then the SDO PRI Device can be used. This is a Java based Device Simulator that can run anywhere Java is supported. Please refer to the readme in the PRI directory of the SDO release package for details on how to run this device. Regardless of which device is used, care must be taken when specifying the value of the device m-string in the DI protocol. See next section for details.","title":"Testing with an SDO Device"},{"location":"supply-chain-tools/manufacturing/manufacturer-enablement-guide/#device-m-string","text":"The m-string is used to provide device-specific information that is used to manage ownership vouchers. The m-string must be present and cannot be empty (the manufacturer toolkit will output an error in such case). In the development, test, or enablement environment, any non-empty value can be used (For example, \u201cdeviceA\u201d or \u201cdeviceB\u201d). The manufacturer toolkit will take the entire m value as the device serial number. For the production environment, creating the m-string value is complex, therefore, it is recommended to use a script to generate the value. The m-string is a base 64-encoded set of null terminated string values as follows: <key type identifier><null-1><serial number><null-2><model number>[<null-3><CSR>] where: <null> translates to value 0x00 <null-1> and <null-2> are mandatory Key type identifier = 1 | 13 | 14 1 = RSA256, 13 = ECC256, 14 = ECC384 Identifies the type of cryptography used on the device. They key type used to extend ownership vouchers must match this type. Serial number = device serial number The serial number should uniquely identify the device and ideally, should be present on the device itself (such as, the label). It is used to correlate the device with its associated ownership voucher by manufacturers and resellers when shipping devices. Model number = device model number The model number should identify the type of device model. This data is not strictly required and can be empty if desired. CSR = certificate signing request. The CSR is optional and is only required for ECC devices. is required only if the CSR is included. The format of the CSR should be base 64-encoded public key cryptography standards (PKCS#10) in privacy-enhanced mail (PEM) format. An example of how to generate the m-string value is given below. This can be leveraged to programmatically generate the sdo_di -mi arg. $ echo -ne '1\\0serial\\0model' | base64 MQBzZXJpYWwAbW9kZWw= And a demonstration of what\u2019s in the encoding: $ echo -ne '1\\0serial\\0model' | base64 | base64 -d | xxd","title":"Device m-string"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/","text":"Introduction \u00b6 Secure Device Onboard (SDO) enhances the out-of-the-box setup and provisioning experience for connected IoT devices. The SDO reseller toolkit addresses the needs of resellers, manufacturers, and others in the supply chain to transfer ownership of SDO devices. To learn more about SDO, see the Overview . Terminology \u00b6 Refer to the Secure Device Onboard Reference page . Related Documents \u00b6 Your role as a supply chain integrator is combined with solutions implemented by manufacturers and device management service providers to enable a complete end-to-end experience. Refer to the Secure Device Onboard Reference page . Overview \u00b6 As an Secure Device Onboard (SDO)-enabled device progresses through the supply chain, associated with the device are SDO ownership vouchers. Ownership vouchers are electronic documents that are ultimately used by the end recipient of the device to prove ownership. For SDO to function properly, it is important that these vouchers are extended from each entity to the next in the supply chain. As a member of the supply chain, you are responsible for extending ownership vouchers to the next owner when devices are ordered or transferred. Extending ownership vouchers entails the following: If you have purchased SDO-enabled devices, receiving a list of ownership vouchers from the previous owner (such as a manufacturer or other reseller/distributor). This can be done via email, a flat file, or an established B2B process to synchronize orders and associated ownership voucher data. Importing received ownership vouchers from devices you purchase into the SDO Database. Receiving public keys from device purchasers. This is to establish trust of the ownership voucher before it is transmitted or accessed. This receipt operation should be incorporated into your e-commerce flow so public keys are included as part of the device ordering process. Extending ownership vouchers based on customer public keys \u2013 once a public key from a customer is known and an order is fulfilled, the devices\u2019 associated ownership vouchers are extended to the customer. The resulting vouchers are exported and transmitted to the customer, usually in conjunction with an advanced shipping notice (ASN). To enable support for SDO, the Secure Device Onboard project provides the following: A reseller toolkit to perform ownership voucher extension. SDO database to store customer public keys and vouchers received from suppliers (The project provides the definition for all the database artifacts while the reseller is responsible for providing the actual database instance). The following diagram shows the interfaces between the SDO database, reseller toolkit, business systems, suppliers, and customers. Evaluation Deployment \u00b6 The evaluation deployment is useful for development, test, and enabling purposes. The evaluation deployment can fully initialize a device to the same extent as the production deployment but does not require any integration with business systems nor the setup of a secure key fob. Step 1: Prepare Hardware Infrastructure \u00b6 You need to have one machine that can run the reseller toolkit as well as host the Secure Device Onboard (SDO) database. A non-production environment has minimal requirements; the machine can run either the Linux* OS (version 18.04) or Windows* 10 OS. Step 2: Deploy Database and Toolkit \u00b6 Install the SDO database and toolkit, see Database and Toolkit Installation . It is recommended to choose the key store file option unless there is a specified need to test with a secure key fob. Production Deployment \u00b6 Step 1: Modify business system processes \u00b6 Your business system processes need to: Manage receipt of ownership vouchers from suppliers and the ownership voucher storage in the SDO Database. When physical devices are received from your supplier, you should also receive the ownership vouchers. Typically, these are through an electronic communication channel. Each of these vouchers must be inserted in the SDO Database so they can be available for voucher extension (assignment to one of your customers). See Import Ownership Voucher for details. Manage SDO public key(s) from customers, and the public key(s) storage in the SDO database. SDO requires the customer\u2019s SDO public key. Your customer interactions and processes must be modified as required to support this receipt of their public key and then to import this key into the SDO Database. See Import Customer Public Key . Whether this key is delivered with each order or done before separately depends on your processes and interaction with your customers. Provide your SDO public key to your suppliers. During the initial setup of the reseller toolkit, you will create a key pair (if you support a device with multiple cryptography standards, you will have more than one key pair). This key pair needs to be provided to your suppliers. The key pair needs only be supplied once or be supplied with each order. The details would be determined by you and your suppliers. Manage ownership vouchers sent to customers. After a device is initialized with SDO, an initial ownership voucher is produced and stored in the SDO Database. This voucher must first be \u201csigned\u201d to a customer before sending to the customer. The ownership voucher management task has the following two steps: Assign a voucher (device) to a customer (technically, a customer public key) See Assign Device (Voucher) to Customer . Perform voucher extension. The resulting extended voucher can then be sent to the customer. The following are the implied requirements: It is assumed that you already have some way to track which device was shipped with which order. Most likely, this was done with serial numbers. With SDO, there is an additional requirement that you must match voucher(s) with physical devices such that the voucher(s) delivered to the customer are those that correspond to the actual physical devices that are delivered. You need to update or modify the existing B2B channel to include an ownership voucher for each physical device delivered to the customer. Typically, these vouchers would be linked to the order in a particular way, but the details will vary for each reseller or distributor. If a customer loses one of these vouchers and requires a replacement, then you must re-generate this voucher or retrieve the voucher from the device or order data if you choose to store the extended voucher with the device or order data. The following figure shows a typical usage scenario of various sequences involved in supporting SDO-enabled devices. The order and timing of each sequence may vary with your ordering and inventory management processes. The only firm requirement is that Seq 1 happens before Seq 2, and Seq 2 and 3 happen before Seq 4. Step 1.1: Device Serial No \u00b6 SDO requires the correct ownership voucher to be delivered with each physical device. Therefore, an identifier that is present on the physical device, for example the serial number, can be used. Scanning an identifier on the physical device allows for the correct voucher to be selected (if an incorrect voucher is delivered, SDO will fail later in the supply chain when run). If, for example, the serial number is already known, the correct physical device can be selected. In practice, the device serial number is used as the identifier. The vouchers you receive from your suppliers will include this \u201cindex\u201d value along with each voucher. Step 1.2: Customer Descriptor \u00b6 A customer descriptor is used when importing customer public keys and assigning a voucher to a customer. This descriptor is a string value that must uniquely identify the customer. It is up to you, the reseller or distributor, to form this value. Duplicates are to be avoided because this value would be used when importing public keys and extending ownership vouchers. Step 1.3: Deploy for Multiple Key Types \u00b6 If you, as a reseller or distributor, produces both the Rivest\u2013Shamir\u2013Adleman (RSA)- and elliptic-curve cryptography (ECC)-based devices, you will need to support two different key types. However, because of the limitations of the secure key fob (For example, Yubikey*), the deployment of multiple key types requires that multiple secure key fobs, each with one type of key pair, be used. The following figure shows a usage example. Step 2: Setup Infrastructure \u00b6 You need to acquire and put into place the following: \u2022 A system to host the reseller toolkit and SDO Database \u2022 Secure key fob(s) The following tables list the hardware infrastructure for Linux*- and Windows*-based reseller toolkits, respectively. Table 1. Linux* OS-based Reseller Toolkit Item Specification Connectivity An Ethernet network to connect to the IoT device. Secure Key Fobs YubiKey* security key (see https://www.yubico.com/products/yubikey-hardware/ ) Operating System Ubuntu* OS version 16.x or 18.x Software \u00b7 Java* Runtime Environment (JRE) software version 11 Oracle* software ( http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html ) or Open JRE ( http://openjdk.java.net/install/index.html ) \u00b7 Apache Tomcat* ( http://tomcat.apache.org/ ) software version 8 or later \u00b7 MariaDB* ( http://mariadb.org/ ) server version 10.4 or later Table 2. Windows* OS-based Reseller Toolkit Item Specification Connectivity An Ethernet network to connect to the IoT device. Secure Key Fobs YubiKey* security key (see https://www.yubico.com/products/yubikey-hardware/ ) Operating System Ubuntu* OS version 16.x or 18.x Software \u00b7 Java* Runtime Environment (JRE) software version 11 Oracle software ( http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html ) or Open JRE ( http://openjdk.java.net/install/index.html ) \u00b7 Apache Tomcat* ( http://tomcat.apache.org/ ) software version 8 or later \u00b7 MariaDB* ( http://mariadb.org/ ) server version 10.4 or later Step 3: Deploy Database and Reseller Toolkit \u00b6 Install the SDO database and toolkit, see Database and Toolkit Installation . Be sure to use the secure key fob option for the key storage. Step 4: Test \u00b6 Import test voucher and public key. Assign voucher to customer. Invoke voucher extension command. Database and Toolkit Installation \u00b6 You can either use the Docker* script provided or deploy manually. Setup: Docker* Script \u00b6 The Docker* script requires a key store file containing the SDO reseller keys. See Supply Chain Tools Key Store Setup Guide for details. For the remaining setup, follow the instructions in the readme file in the SDO Docker* directory. Setup: Manual \u00b6 For the following steps, run as root or use sudo. Install the MariaDB* server from https://mariadb.org/. For each of the following commands, use the \u2018root\u2019 user you defined in step 2 where you installed the MariaDB* server, and run each script on the machine where the MariaDB* server is installed. You\u2019ll find the scripts in both the source and binary files of the release. Edit the rt_config.sql and mt_config.sql as directed by the comments in each file. Run the rt_create.sql script: mysql -u <username> -p < rt_create.sql Run the rt_config.sql script: mysql -u <username> -p < rt_config.sql Create a key store containing the SDO reseller keys. See Supply Chain Tools Key Store Setup Guide for details. Setup and deploy the toolkit web service. If this is an evaluation deployment, you have an option to run the web service directly from the command line. If you choose to do this, instructions are provided in the readme file included with the toolkit software. Follow those instructions. You can verify that the toolkit starts up correctly by looking at the output in the window where you ran the toolkit. Installation is then complete, and you can skip the following steps. An example if running directly: java -Dspring.datasource.url=\"jdbc:mariadb://localhost:3307/sdo\" -Dspring.datasource.username=sdo_admin -Dspring.datasource.password=sdo -Dsdo.keystore=\"file:///sdo.p12\" -Dsdo.keystore.password=123456 -jar ./reseller-webapp-1.8.war Install the Apache Tomcat* software from http://tomcat.apache.org/ or equivalent. Copy the reseller toolkit war file into the Apache Tomcat* webapps directory (on a Linux* machine this would typically be /var/lib/tomcat8/webapps). Rename the war file to ROOT.war. Start the Apache Tomcat service. This will trigger Apache Tomcat to unpack the war file and create individual files in the webapps/ROOT directory. Add the remaining toolkit configuration for the Apache Tomcat* software (see the readme file included with the toolkit software for further details). For Apache Tomcat* version 8 running on the Linux* machine, these settings are located in /var/lib/tomcat/webapps/ROOT/WEB-INF/classes/application.properties. An example is given as follows: spring.datasource.url=jdbc:mariadb://localhost:3307/sdo?useSSL=false spring.datasource.username=sdo_admin spring.datasource.password=sdo sdo.keystore=file:///var/lib/tomcat8/webapps/ROOT/sdo.p12 sdo.keystore.password=123456 Note: The database user and password should match those configured in rt_config.sql. datasource.url: be sure to use localhost rather than the IP address. sdo.keystore: this is either the pathname to the software key store (jks) or to the public key cryptography standards (PKCS#11) library if using the secure key fob. Be sure to not use quotes around the value. sdo.keystore.password: this is the password for the software key store or the pin code of the secure key fob. Start the Apache Tomcat* service. Test with the status page: http:// /api/v1/status. If the page does not load, look at the Apache Tomcat* logs to debug any errors. Setup: Troubleshooting \u00b6 Troubleshoot using the following steps if the toolkit web service does not start correctly: Verify that the JDBC* string is correct. An example is: jdbc:mariadb://localhost:3307/sdo. Be sure mariadb is included, the port is specified as 3307 , and the host name is correct. Verify that the database user and password are correct. The user and password should be the same as those defined in rt_config.sql. You may wish to use some third-party database tool to log into the database to test that the user and password are correct. Usage Scenarios \u00b6 Import Customer Public Key \u00b6 Import the customer public key by calling the rt_add_customer_public_key stored procedure. In a production environment, the import would likely be invoked programmatically. For test, development, or evaluation purposes, run from the command line as follows: mysql -u <username> -p -h <SDO database server hostname or ip> -P <server port> -e \u201cuse sdo; call rt_add_customer_public key('CUST_DIST_12345', '-----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCqGKukO1De7zhZj6+H0qtjTkVxwTCpvKe4eCZ0 FPqri0cb2JZfXJ/DgYSF6vUpwmJG8wVQZKjeGcjDOL5UlsuusFncCzWBQ7RKNUSesmQRMSGkVb1/ 3j+skZ6UtW+5u09lHNsj6tQ51s1SPrCBkedbNf0Tp0GbMJDyR4e9T04ZZwIDAQAB -----END PUBLIC KEY-----\u2019)\u201d Note Be sure this is the public key PEM and not the certificate PEM. The public key can be extracted from the certificate with the OpenSSL* toolkit: openssl x509 -pubkey -noout -in <cert file>.pem > <pubkey>.pem Import Ownership Voucher \u00b6 Import the ownership voucher by calling the rt_add_voucher stored procedure. In a production environment, the import would likely be invoked programmatically. For test, development, or evaluation purposes, run from the command line as follows: mysql -u <username> -p -h <SDO database server hostname or ip> -P <server port> -e \u201cuse sdo; call rt_add_voucher('SN1342599', '{\"sz\":0,\"oh\":{\"pv\":112,\"pe\":3,\"r\":[2,[4,{\"dn\":\"localhost\",\"only\":\"owner\",\"pow\":8040,\"pr\":\"http\"}],[4,{\"dn\":\"localhost\",\"only\":\"dev\",\"po\":8040,\"pr\":\"http\"}]],\"g\":\"UNqKf+WjRi6sFBXybKASPg==\",\"d\":\"NOT SET\",\"pk\":[1,3,[257,\"AL6FIK4LAS+7ppX07aoDwJyD0dCjH0730+7sD/PiqEez9/xlwLJqt0M33/eRclchNoHcAIpZFX8tTzu3gVVaJzp73SO2gnTGwhE7SuVr+nzdYh1HksrItnUgx1uVxA3hnUHXy1J7aiZAS4DLUHsWf6gAdVF2VEZpRYupNLo+X6Xt9sZ2Wxt1oy0C/oSG4O8oY9i2wvTSreclafIYKUP8lJIOQt4MZsbcgJWL1Mr1CEBsZ8xwCJiIdmP292WaV8f3zraCAzyjDS0BVrv/0JGfFSjkPzsK8kajtKUPDVTPRLT67M2K1DkQeZLdj1bbVZdXZo7aGW2X0H3JPOuY+CbO0w8=\",3,\"AQAB\"]]},\"hmac\":[32,108,\"PB+PtWcCFRa6nJcGQM3P4JJUUR/hBmWobFBGxjyBdRs=\"],\"en\":[]}')\u201d Assign Device (Voucher) to Customer \u00b6 Assign the device (voucher) by calling the rt_assign_device_to_customer stored procedure. In a production environment, the assignment would likely be invoked programmatically. For test, development, or evaluation purposes, run from the command line as follows: mysql -u <username> -p -h <SDO database server hostname or ip> -P <server port> -e \u201cuse sdo; call rt_assign_device_to_customer(\u2018SN12345678\u2019, \u2019CUST_DIST_12345\u2019)\u201d Extend Ownership Voucher \u00b6 Ownership voucher is extended through the REST API. In a production environment, the extension would be done programmatically. For test purposes, you can use curl to invoke the extension: curl -X GET http://<reseller toolkit ip>:<port>/api/v1/vouchers/<device serial no> The result will be the extended voucher.","title":"Reseller Tools"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#introduction","text":"Secure Device Onboard (SDO) enhances the out-of-the-box setup and provisioning experience for connected IoT devices. The SDO reseller toolkit addresses the needs of resellers, manufacturers, and others in the supply chain to transfer ownership of SDO devices. To learn more about SDO, see the Overview .","title":"Introduction"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#terminology","text":"Refer to the Secure Device Onboard Reference page .","title":"Terminology"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#related-documents","text":"Your role as a supply chain integrator is combined with solutions implemented by manufacturers and device management service providers to enable a complete end-to-end experience. Refer to the Secure Device Onboard Reference page .","title":"Related Documents"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#overview","text":"As an Secure Device Onboard (SDO)-enabled device progresses through the supply chain, associated with the device are SDO ownership vouchers. Ownership vouchers are electronic documents that are ultimately used by the end recipient of the device to prove ownership. For SDO to function properly, it is important that these vouchers are extended from each entity to the next in the supply chain. As a member of the supply chain, you are responsible for extending ownership vouchers to the next owner when devices are ordered or transferred. Extending ownership vouchers entails the following: If you have purchased SDO-enabled devices, receiving a list of ownership vouchers from the previous owner (such as a manufacturer or other reseller/distributor). This can be done via email, a flat file, or an established B2B process to synchronize orders and associated ownership voucher data. Importing received ownership vouchers from devices you purchase into the SDO Database. Receiving public keys from device purchasers. This is to establish trust of the ownership voucher before it is transmitted or accessed. This receipt operation should be incorporated into your e-commerce flow so public keys are included as part of the device ordering process. Extending ownership vouchers based on customer public keys \u2013 once a public key from a customer is known and an order is fulfilled, the devices\u2019 associated ownership vouchers are extended to the customer. The resulting vouchers are exported and transmitted to the customer, usually in conjunction with an advanced shipping notice (ASN). To enable support for SDO, the Secure Device Onboard project provides the following: A reseller toolkit to perform ownership voucher extension. SDO database to store customer public keys and vouchers received from suppliers (The project provides the definition for all the database artifacts while the reseller is responsible for providing the actual database instance). The following diagram shows the interfaces between the SDO database, reseller toolkit, business systems, suppliers, and customers.","title":"Overview"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#evaluation-deployment","text":"The evaluation deployment is useful for development, test, and enabling purposes. The evaluation deployment can fully initialize a device to the same extent as the production deployment but does not require any integration with business systems nor the setup of a secure key fob.","title":"Evaluation Deployment"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#step-1-prepare-hardware-infrastructure","text":"You need to have one machine that can run the reseller toolkit as well as host the Secure Device Onboard (SDO) database. A non-production environment has minimal requirements; the machine can run either the Linux* OS (version 18.04) or Windows* 10 OS.","title":"Step 1: Prepare Hardware Infrastructure"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#step-2-deploy-database-and-toolkit","text":"Install the SDO database and toolkit, see Database and Toolkit Installation . It is recommended to choose the key store file option unless there is a specified need to test with a secure key fob.","title":"Step 2: Deploy Database and Toolkit"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#production-deployment","text":"","title":"Production Deployment"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#step-1-modify-business-system-processes","text":"Your business system processes need to: Manage receipt of ownership vouchers from suppliers and the ownership voucher storage in the SDO Database. When physical devices are received from your supplier, you should also receive the ownership vouchers. Typically, these are through an electronic communication channel. Each of these vouchers must be inserted in the SDO Database so they can be available for voucher extension (assignment to one of your customers). See Import Ownership Voucher for details. Manage SDO public key(s) from customers, and the public key(s) storage in the SDO database. SDO requires the customer\u2019s SDO public key. Your customer interactions and processes must be modified as required to support this receipt of their public key and then to import this key into the SDO Database. See Import Customer Public Key . Whether this key is delivered with each order or done before separately depends on your processes and interaction with your customers. Provide your SDO public key to your suppliers. During the initial setup of the reseller toolkit, you will create a key pair (if you support a device with multiple cryptography standards, you will have more than one key pair). This key pair needs to be provided to your suppliers. The key pair needs only be supplied once or be supplied with each order. The details would be determined by you and your suppliers. Manage ownership vouchers sent to customers. After a device is initialized with SDO, an initial ownership voucher is produced and stored in the SDO Database. This voucher must first be \u201csigned\u201d to a customer before sending to the customer. The ownership voucher management task has the following two steps: Assign a voucher (device) to a customer (technically, a customer public key) See Assign Device (Voucher) to Customer . Perform voucher extension. The resulting extended voucher can then be sent to the customer. The following are the implied requirements: It is assumed that you already have some way to track which device was shipped with which order. Most likely, this was done with serial numbers. With SDO, there is an additional requirement that you must match voucher(s) with physical devices such that the voucher(s) delivered to the customer are those that correspond to the actual physical devices that are delivered. You need to update or modify the existing B2B channel to include an ownership voucher for each physical device delivered to the customer. Typically, these vouchers would be linked to the order in a particular way, but the details will vary for each reseller or distributor. If a customer loses one of these vouchers and requires a replacement, then you must re-generate this voucher or retrieve the voucher from the device or order data if you choose to store the extended voucher with the device or order data. The following figure shows a typical usage scenario of various sequences involved in supporting SDO-enabled devices. The order and timing of each sequence may vary with your ordering and inventory management processes. The only firm requirement is that Seq 1 happens before Seq 2, and Seq 2 and 3 happen before Seq 4.","title":"Step 1: Modify business system processes"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#step-11-device-serial-no","text":"SDO requires the correct ownership voucher to be delivered with each physical device. Therefore, an identifier that is present on the physical device, for example the serial number, can be used. Scanning an identifier on the physical device allows for the correct voucher to be selected (if an incorrect voucher is delivered, SDO will fail later in the supply chain when run). If, for example, the serial number is already known, the correct physical device can be selected. In practice, the device serial number is used as the identifier. The vouchers you receive from your suppliers will include this \u201cindex\u201d value along with each voucher.","title":"Step 1.1: Device Serial No"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#step-12-customer-descriptor","text":"A customer descriptor is used when importing customer public keys and assigning a voucher to a customer. This descriptor is a string value that must uniquely identify the customer. It is up to you, the reseller or distributor, to form this value. Duplicates are to be avoided because this value would be used when importing public keys and extending ownership vouchers.","title":"Step 1.2: Customer Descriptor"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#step-13-deploy-for-multiple-key-types","text":"If you, as a reseller or distributor, produces both the Rivest\u2013Shamir\u2013Adleman (RSA)- and elliptic-curve cryptography (ECC)-based devices, you will need to support two different key types. However, because of the limitations of the secure key fob (For example, Yubikey*), the deployment of multiple key types requires that multiple secure key fobs, each with one type of key pair, be used. The following figure shows a usage example.","title":"Step 1.3: Deploy for Multiple Key Types"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#step-2-setup-infrastructure","text":"You need to acquire and put into place the following: \u2022 A system to host the reseller toolkit and SDO Database \u2022 Secure key fob(s) The following tables list the hardware infrastructure for Linux*- and Windows*-based reseller toolkits, respectively. Table 1. Linux* OS-based Reseller Toolkit Item Specification Connectivity An Ethernet network to connect to the IoT device. Secure Key Fobs YubiKey* security key (see https://www.yubico.com/products/yubikey-hardware/ ) Operating System Ubuntu* OS version 16.x or 18.x Software \u00b7 Java* Runtime Environment (JRE) software version 11 Oracle* software ( http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html ) or Open JRE ( http://openjdk.java.net/install/index.html ) \u00b7 Apache Tomcat* ( http://tomcat.apache.org/ ) software version 8 or later \u00b7 MariaDB* ( http://mariadb.org/ ) server version 10.4 or later Table 2. Windows* OS-based Reseller Toolkit Item Specification Connectivity An Ethernet network to connect to the IoT device. Secure Key Fobs YubiKey* security key (see https://www.yubico.com/products/yubikey-hardware/ ) Operating System Ubuntu* OS version 16.x or 18.x Software \u00b7 Java* Runtime Environment (JRE) software version 11 Oracle software ( http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html ) or Open JRE ( http://openjdk.java.net/install/index.html ) \u00b7 Apache Tomcat* ( http://tomcat.apache.org/ ) software version 8 or later \u00b7 MariaDB* ( http://mariadb.org/ ) server version 10.4 or later","title":"Step 2: Setup Infrastructure"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#step-3-deploy-database-and-reseller-toolkit","text":"Install the SDO database and toolkit, see Database and Toolkit Installation . Be sure to use the secure key fob option for the key storage.","title":"Step 3: Deploy Database and Reseller Toolkit"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#step-4-test","text":"Import test voucher and public key. Assign voucher to customer. Invoke voucher extension command.","title":"Step 4: Test"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#database-and-toolkit-installation","text":"You can either use the Docker* script provided or deploy manually.","title":"Database and Toolkit Installation"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#setup-docker-script","text":"The Docker* script requires a key store file containing the SDO reseller keys. See Supply Chain Tools Key Store Setup Guide for details. For the remaining setup, follow the instructions in the readme file in the SDO Docker* directory.","title":"Setup: Docker* Script"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#setup-manual","text":"For the following steps, run as root or use sudo. Install the MariaDB* server from https://mariadb.org/. For each of the following commands, use the \u2018root\u2019 user you defined in step 2 where you installed the MariaDB* server, and run each script on the machine where the MariaDB* server is installed. You\u2019ll find the scripts in both the source and binary files of the release. Edit the rt_config.sql and mt_config.sql as directed by the comments in each file. Run the rt_create.sql script: mysql -u <username> -p < rt_create.sql Run the rt_config.sql script: mysql -u <username> -p < rt_config.sql Create a key store containing the SDO reseller keys. See Supply Chain Tools Key Store Setup Guide for details. Setup and deploy the toolkit web service. If this is an evaluation deployment, you have an option to run the web service directly from the command line. If you choose to do this, instructions are provided in the readme file included with the toolkit software. Follow those instructions. You can verify that the toolkit starts up correctly by looking at the output in the window where you ran the toolkit. Installation is then complete, and you can skip the following steps. An example if running directly: java -Dspring.datasource.url=\"jdbc:mariadb://localhost:3307/sdo\" -Dspring.datasource.username=sdo_admin -Dspring.datasource.password=sdo -Dsdo.keystore=\"file:///sdo.p12\" -Dsdo.keystore.password=123456 -jar ./reseller-webapp-1.8.war Install the Apache Tomcat* software from http://tomcat.apache.org/ or equivalent. Copy the reseller toolkit war file into the Apache Tomcat* webapps directory (on a Linux* machine this would typically be /var/lib/tomcat8/webapps). Rename the war file to ROOT.war. Start the Apache Tomcat service. This will trigger Apache Tomcat to unpack the war file and create individual files in the webapps/ROOT directory. Add the remaining toolkit configuration for the Apache Tomcat* software (see the readme file included with the toolkit software for further details). For Apache Tomcat* version 8 running on the Linux* machine, these settings are located in /var/lib/tomcat/webapps/ROOT/WEB-INF/classes/application.properties. An example is given as follows: spring.datasource.url=jdbc:mariadb://localhost:3307/sdo?useSSL=false spring.datasource.username=sdo_admin spring.datasource.password=sdo sdo.keystore=file:///var/lib/tomcat8/webapps/ROOT/sdo.p12 sdo.keystore.password=123456 Note: The database user and password should match those configured in rt_config.sql. datasource.url: be sure to use localhost rather than the IP address. sdo.keystore: this is either the pathname to the software key store (jks) or to the public key cryptography standards (PKCS#11) library if using the secure key fob. Be sure to not use quotes around the value. sdo.keystore.password: this is the password for the software key store or the pin code of the secure key fob. Start the Apache Tomcat* service. Test with the status page: http:// /api/v1/status. If the page does not load, look at the Apache Tomcat* logs to debug any errors.","title":"Setup: Manual"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#setup-troubleshooting","text":"Troubleshoot using the following steps if the toolkit web service does not start correctly: Verify that the JDBC* string is correct. An example is: jdbc:mariadb://localhost:3307/sdo. Be sure mariadb is included, the port is specified as 3307 , and the host name is correct. Verify that the database user and password are correct. The user and password should be the same as those defined in rt_config.sql. You may wish to use some third-party database tool to log into the database to test that the user and password are correct.","title":"Setup: Troubleshooting"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#usage-scenarios","text":"","title":"Usage Scenarios"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#import-customer-public-key","text":"Import the customer public key by calling the rt_add_customer_public_key stored procedure. In a production environment, the import would likely be invoked programmatically. For test, development, or evaluation purposes, run from the command line as follows: mysql -u <username> -p -h <SDO database server hostname or ip> -P <server port> -e \u201cuse sdo; call rt_add_customer_public key('CUST_DIST_12345', '-----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCqGKukO1De7zhZj6+H0qtjTkVxwTCpvKe4eCZ0 FPqri0cb2JZfXJ/DgYSF6vUpwmJG8wVQZKjeGcjDOL5UlsuusFncCzWBQ7RKNUSesmQRMSGkVb1/ 3j+skZ6UtW+5u09lHNsj6tQ51s1SPrCBkedbNf0Tp0GbMJDyR4e9T04ZZwIDAQAB -----END PUBLIC KEY-----\u2019)\u201d Note Be sure this is the public key PEM and not the certificate PEM. The public key can be extracted from the certificate with the OpenSSL* toolkit: openssl x509 -pubkey -noout -in <cert file>.pem > <pubkey>.pem","title":"Import Customer Public Key"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#import-ownership-voucher","text":"Import the ownership voucher by calling the rt_add_voucher stored procedure. In a production environment, the import would likely be invoked programmatically. For test, development, or evaluation purposes, run from the command line as follows: mysql -u <username> -p -h <SDO database server hostname or ip> -P <server port> -e \u201cuse sdo; call rt_add_voucher('SN1342599', '{\"sz\":0,\"oh\":{\"pv\":112,\"pe\":3,\"r\":[2,[4,{\"dn\":\"localhost\",\"only\":\"owner\",\"pow\":8040,\"pr\":\"http\"}],[4,{\"dn\":\"localhost\",\"only\":\"dev\",\"po\":8040,\"pr\":\"http\"}]],\"g\":\"UNqKf+WjRi6sFBXybKASPg==\",\"d\":\"NOT SET\",\"pk\":[1,3,[257,\"AL6FIK4LAS+7ppX07aoDwJyD0dCjH0730+7sD/PiqEez9/xlwLJqt0M33/eRclchNoHcAIpZFX8tTzu3gVVaJzp73SO2gnTGwhE7SuVr+nzdYh1HksrItnUgx1uVxA3hnUHXy1J7aiZAS4DLUHsWf6gAdVF2VEZpRYupNLo+X6Xt9sZ2Wxt1oy0C/oSG4O8oY9i2wvTSreclafIYKUP8lJIOQt4MZsbcgJWL1Mr1CEBsZ8xwCJiIdmP292WaV8f3zraCAzyjDS0BVrv/0JGfFSjkPzsK8kajtKUPDVTPRLT67M2K1DkQeZLdj1bbVZdXZo7aGW2X0H3JPOuY+CbO0w8=\",3,\"AQAB\"]]},\"hmac\":[32,108,\"PB+PtWcCFRa6nJcGQM3P4JJUUR/hBmWobFBGxjyBdRs=\"],\"en\":[]}')\u201d","title":"Import Ownership Voucher"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#assign-device-voucher-to-customer","text":"Assign the device (voucher) by calling the rt_assign_device_to_customer stored procedure. In a production environment, the assignment would likely be invoked programmatically. For test, development, or evaluation purposes, run from the command line as follows: mysql -u <username> -p -h <SDO database server hostname or ip> -P <server port> -e \u201cuse sdo; call rt_assign_device_to_customer(\u2018SN12345678\u2019, \u2019CUST_DIST_12345\u2019)\u201d","title":"Assign Device (Voucher) to Customer"},{"location":"supply-chain-tools/reseller/reseller-enablement-guide/#extend-ownership-voucher","text":"Ownership voucher is extended through the REST API. In a production environment, the extension would be done programmatically. For test purposes, you can use curl to invoke the extension: curl -X GET http://<reseller toolkit ip>:<port>/api/v1/vouchers/<device serial no> The result will be the extended voucher.","title":"Extend Ownership Voucher"}]}